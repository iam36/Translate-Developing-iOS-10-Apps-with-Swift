1
00:00:00,401 --> 00:00:04,869
[MUSIC]
(音乐)

2
00:00:04,938 --> 00:00:07,906
Stanford University, >> So
斯坦福大学> >
斯坦福大学

3
00:00:07,974 --> 00:00:12,577
welcome to Stanford CS193P, this is Developing iOS
欢迎来到斯坦福CS193P,这是开发iOS
欢迎参加 2017 年冬季学期斯坦福 CS193P 课程

4
00:00:12,646 --> 00:00:17,115
Applications, winter of 2017, So today I'm gonna give
应用程序,2017年冬天,所以今天我要给
iOS 应用程序开发

5
00:00:17,184 --> 00:00:20,918
another brief set of slides on Model View Controller, this
另一个简单的幻灯片在模型-视图-控制器,这个
今天的幻灯片是关于 MVC，模型——视图——控制器

6
00:00:20,987 --> 00:00:24,355
design methodology that we're gonna use to build all of our
设计方法,我们将使用我们所有的
一个编写所有 iOS 程序都会用到的设计模式

7
00:00:24,424 --> 00:00:27,825
iOS apps, And then I'm gonna continue the demo that we
iOS应用程序,然后继续我们的演示
之后就接着完成星期一开始的

8
00:00:27,894 --> 00:00:31,196
started on Monday, We're gonna actually incorporate MVC into
周一开始,我们会结合MVC
那个程序。我们会把这种设计模式

9
00:00:31,265 --> 00:00:33,931
the calculator, And it's also gonna be an opportunity for
计算器,它也会是一个机会
运用到计算其中。这也是一个大好机会

10
00:00:34,000 --> 00:00:38,870
me to show you a lot of other cool Swift, language features,
我给你很多其他降温迅速、语言特性,
能让我展示 Swift 的许多优点、语法和特性

11
00:00:38,939 --> 00:00:42,373
So what is MVC? Model view controller, what is that?
MVC是什么?
什么是 MVC，模型——视图——控制器呢？

12
00:00:42,442 --> 00:00:46,477
Basically, it starts out being a way that we divide up
基本上,它开始成为我们划分
从大体上看，这是我们把代码

13
00:00:46,546 --> 00:00:51,182
all of the code in our app into three different camps,
所有的代码在我们的应用程序分成三个不同的阵营,
分割成了三个“阵营”

14
00:00:51,251 --> 00:00:54,453
These three different camps are the model camp, the model
这三个不同阵营的阵营的模型,模型
“阵营”的一个是 Model，模型

15
00:00:54,521 --> 00:00:59,057
is the "what" of your app, so what your app is, So,
是你的应用的“什么”,所以你的应用是什么,所以,
模型体现了你的程序“是什么”，也就是你的程序是干什么的

16
00:00:59,126 --> 00:01:02,261
in the calculator case, it's the brains of the calculator,
计算器,计算器的大脑,
用计算器来举例子，那模型就是它的大脑

17
00:01:02,329 --> 00:01:04,496
it's the thing that calculates, tha's the model,
这是计算的东西,那是模型,
负责计算的那个部分就是模型

18
00:01:04,564 --> 00:01:08,500
and tha's a UI independent part, It's what the app is,
和那一个UI的独立部分,它的应用是什么,
和 UI 是没有关系的。仅仅是背后的逻辑

19
00:01:08,569 --> 00:01:10,569
not how it displays or anything like that,
不是它如何显示或类似的东西,
和具体怎么展示出来是没有关系的

20
00:01:10,637 --> 00:01:13,838
How it displays is the controlle's job, So
它显示是怎样controlle的工作,所以呢
决定如何展示的是 Controller，控制器

21
00:01:13,907 --> 00:01:16,508
the controller decides how to take this UI independent
控制器独立决定如何把这个UI
控制器决定如何把这个与 UI 无关的

22
00:01:16,577 --> 00:01:18,610
thing, the model, and display it on your screen and
模型,并将其显示在你的屏幕上
这个模型显示到你的屏幕上

23
00:01:18,679 --> 00:01:21,580
interact with the user, That's what the controller job does,
与用户交互,控制器的工作是什么,
来和用户交互。这就是控制器的作用

24
00:01:21,648 --> 00:01:25,683
It's the, how it displays, Model is the what it is,
它是,它显示,模型是什么,
决定如何展示出来。模型是程序的本体

25
00:01:25,752 --> 00:01:27,352
Controller is how it displays,
控制器是如何显示,
控制器决定如何展示

26
00:01:27,421 --> 00:01:31,723
The view is the minions of the controller, okay?
视图控制器的奴才,好吗?
View，视图，是控制器手下的用人

27
00:01:31,792 --> 00:01:34,726
Things that the controller uses to do its job,
控制器用来做它的工作的事情,
控制器通过视图来实现它的功能

28
00:01:34,795 --> 00:01:39,231
almost always, these things in the view are generic,
几乎总是,这些东西在视图中是通用的,
通常视图都是能通用的

29
00:01:39,299 --> 00:01:42,968
things like UIButton or UIScrollView, okay?
UIButton或UIScrollView,好吗?
比如 UIButton 或者 UIScrollView

30
00:01:43,037 --> 00:01:45,303
Things that come from Apple or somewhere else,
来自苹果或其他地方的事情,
由苹果或是其它平台提供的

31
00:01:45,372 --> 00:01:48,306
even things you write, and you generally try to write them to
即使是你写,你通常试着写
包括你自己编写的。你应该尽量写通用的

32
00:01:48,375 --> 00:01:52,010
be pretty generic reusable UI things, And the controller is
非常通用的可重用的UI,以及控制器
能够重用的 UI 控件。而控制器

33
00:01:52,079 --> 00:01:56,214
trying to use those generic things to build a specific UI,
试图建立一个特定的UI使用这些通用的东西,
则是使用这些通用的控件构成特有的 UI

34
00:01:56,283 --> 00:01:59,551
Now the key to making MVC work is managing the communication
现在使MVC工作的关键是管理沟通
使用 MVC 的关键是组织联系

35
00:01:59,620 --> 00:02:02,220
between these camps because if we don't manage
这些阵营之间,因为如果我们不管理
这几个阵营。如果我们

36
00:02:02,289 --> 00:02:03,488
that communication,
沟通,
没有控制好交互

37
00:02:03,557 --> 00:02:06,224
we might as well just put them all in the big camp,
我们不妨把它们全部在大营地,
而只是把这些代码都堆在一起

38
00:02:06,293 --> 00:02:08,726
And they can all talk to each other however they want, So
他们都能互相交谈但是他们想要的,所以
三个阵营之间都能随便调用的话

39
00:02:08,795 --> 00:02:09,627
if we're gonna have three camps,
如果我们要有三个阵营,
那这分类也就没什么实际意义了

40
00:02:09,696 --> 00:02:11,230
we gotta think about how they communicate,
我们必须考虑他们如何沟通,
所以我们要考虑好三者之间是如何交互的

41
00:02:11,298 --> 00:02:14,799
So I've used this road sign kind of imagery here, okay,
所以我用这个路标的意象,好吧,
我这里用的道路交通标线来表示

42
00:02:14,868 --> 00:02:17,669
the roads, like the road lines in the middle of a road
的道路,就像路行中间的路
就是马路中间的那些线

43
00:02:17,737 --> 00:02:21,406
between them to help you visualize what is allowed
他们之间帮助你想象什么是允许的
让你们能形象地理解

44
00:02:21,475 --> 00:02:22,740
in terms of communication,
在沟通方面,
哪些沟通是被允许的

45
00:02:22,809 --> 00:02:25,677
So, let's talk about every boundary here between all of
所以,让我们来谈谈每一边界之间的所有
让我们来逐个分析阵营之间的交互

46
00:02:25,745 --> 00:02:29,280
these camps, Let's start with the controller talking to
这些营地,先从控制器
我们从控制器访问模型开始

47
00:02:29,349 --> 00:02:31,783
the model, okay, Can the controller talk to
模型,控制器能跟
控制器能和模型通信吗？

48
00:02:31,852 --> 00:02:34,920
the model? Absolutely, it can say anything to the model that
这个模型吗?
肯定是可以的。控制器能够访问

49
00:02:34,989 --> 00:02:38,590
the model publicly allows to be said to itself, So,
模型公开允许说本身,所以,
模型所有公开允许访问的内容

50
00:02:38,658 --> 00:02:41,893
it's a green arrow, It's a dashed white line on the road,
这是一个绿色的箭头,这是一个白色虚线在路上,
所以我用绿箭头。这是白虚线

51
00:02:41,962 --> 00:02:43,428
You can go across there all you want,
你可以在那里所有你想要的,
你可以随便跨过去

52
00:02:43,497 --> 00:02:44,930
And you can see why this is,
你可以看到为什么这是
这是可以理解的

53
00:02:44,998 --> 00:02:48,300
It is the controller job to get that model onto screen,
控制器的工作得到模型在屏幕上,
因为控制器的功能就是把模型展示到屏幕上

54
00:02:48,369 --> 00:02:50,702
It has to be able to talk to it all at once, So, there's no
它能够跟它一次,所以,没有
控制器应该是有全权处理的

55
00:02:50,770 --> 00:02:53,238
restriction of the controller talking to the model, And
控制器与模型的限制,
控制器访问模型是没有限制的

56
00:02:53,307 --> 00:02:56,741
similarly, there's no restriction of the controller
同样的,没有限制的控制器
同样的，也不会限制控制器

57
00:02:56,810 --> 00:02:59,912
talking to the view, because the view are the controller's
说到视图,因为视图控制器
与视图的沟通，因为视图和控制器

58
00:02:59,980 --> 00:03:02,480
minions, Right, so you gotta be able to tell your minions
奴才,对吧,所以你必须能够告诉你的仆从
是从属关系。你肯定要能够和下属沟通

59
00:03:02,549 --> 00:03:04,917
what to do without restriction, Now,
没有什么限制,现在,
告诉它们该做什么。这不应该被限制

60
00:03:04,985 --> 00:03:07,285
these connections between the controller and
这些控制器和之间的连接
这些控制器和视图之间的关连

61
00:03:07,354 --> 00:03:10,255
a view, we call them outlets, And you've already seen one in
一个视图,我们称之为媒体,你已经看过的
叫做 Outlet，出口。你们已经在计算器里见到过了

62
00:03:10,324 --> 00:03:13,058
the calculator, we created an outlet, if you remember,
计算器,我们创建了一个出口,如果你还记得,
如果你还记得的话，我们创建的那个出口

63
00:03:13,127 --> 00:03:15,426
it was called display, right?
它被称为显示,对吧?
就是叫做 display 的那个

64
00:03:15,495 --> 00:03:18,162
It was an instance variable in our controller, Remember that
这是一个实例变量在我们的控制器,记住这一点
控制器的实例变量

65
00:03:18,231 --> 00:03:20,265
class ViewController we saw on Monday,
类ViewController周一我们看到,
星期一看到的那个 ViewController 类

66
00:03:20,333 --> 00:03:24,069
that's the controller of the MVC that we built on Monday,
MVC的控制器,我们建立了周一,
我们周一就是构建了那个控制器

67
00:03:24,138 --> 00:03:26,238
And that display var, was an outlet,
显示变量,是一个出口,
那个变量 display 就是 outlet 出口

68
00:03:26,306 --> 00:03:30,508
and it's just wired up to a UILabel in our view, UILabel
这是连接到UILabel在我们看来,UILabel
和视图里面的 UILabel 关连起来的

69
00:03:30,577 --> 00:03:34,045
is one of the minions for the controller in the view, Okay,
是一个奴才的控制器在视图中,好吧,
那个 UILabel 就是视图中、控制器下属的其中一个

70
00:03:34,114 --> 00:03:38,450
so you've already seen that happen, The model and the view
所以你已经看到这种情况发生,模型和视图
所以你们已经见过这种交互了。模型和视图

71
00:03:38,518 --> 00:03:43,355
can never speak to each other, Double orange line there,
不能说话,双橙线,
它们之间是不能有交互的。双黄线

72
00:03:43,424 --> 00:03:46,892
no crossing either way across here, And this makes perfect
没有交叉穿过,这使得完美
两边都不能跨线。这也是很有道理的

73
00:03:46,961 --> 00:03:50,128
sense because the model is completely UI independent,
因为模型是完全独立于UI,
因为模型是完全和 UI 分开的

74
00:03:50,197 --> 00:03:53,064
and the view is completely UI, That's all the view is,
和观点是完全的UI,所有的观点是,
而视图全部是 UI 相关的

75
00:03:53,133 --> 00:03:54,299
So, they have nothing to talk about,
所以,他们没有谈论,
所以它们并没有共同语言

76
00:03:54,367 --> 00:03:58,170
these two guys, okay? Cuz they're completely, you know,
这两个家伙,好吗?
这两者之间，你知道的

77
00:03:58,238 --> 00:04:00,372
different camps that make no sense to talk to each other,
不同的阵营,相互交谈没有任何意义,
它们的交互完全是天方夜谭

78
00:04:00,440 --> 00:04:03,574
It's up to the controller to manage communication between
由控制器来管理之间的通信
控制器才是负责它们之间交互的

79
00:04:03,643 --> 00:04:08,113
these two, So, never shall you just communicate between those
这两个,所以,从不将之间的沟通
所以永远不要让模型和视图互相调用

80
00:04:08,181 --> 00:04:13,018
two camps, all right? How about the view talking back to
两个阵营?
好吧？那视图反过来，和控制器交互呢？

81
00:04:13,087 --> 00:04:16,288
its controller? Can the view, those minions, can they talk
它的控制器?
视图，作为仆从，能够联系

82
00:04:16,357 --> 00:04:18,890
to its controller? Now this is something you would clearly
其控制器吗?
它的控制器吗？很明显的，这是我们希望有的

83
00:04:18,959 --> 00:04:21,993
want because the minions gotta work with the controller, but
希望因为奴才要处理控制器,但是
因为它们是给控制器干活的

84
00:04:22,062 --> 00:04:23,895
it's a bit of a problem here,
这是一个问题,
但存在一个小问题

85
00:04:23,964 --> 00:04:26,498
Because these things in the view are generic,
因为这些东西在视图中是通用的,
那就是这些控件都是通用的

86
00:04:26,566 --> 00:04:30,035
They're things like UIButton, The class UIButton shipped
他们像UIButton,类UIButton装船
就像 UIButton 那样的

87
00:04:30,104 --> 00:04:33,338
from Apple last year, It knows nothing about a calculator,
从去年的苹果,它一个计算器,一无所知
苹果去年编写的 UIButton 类对我们计算器一无所知

88
00:04:33,407 --> 00:04:37,843
so how can that UIButton talk to a calculator? Well, we can
所以如何UIButton跟计算器吗?
那么 UIButton 要怎么和我们计算器通信呢？

89
00:04:37,911 --> 00:04:41,513
do it, We just have to sort of do it in a blind, meaning
这样做,我们只需要用一个盲人,意思吗
可是可以，不过它是被蒙在鼓里的

90
00:04:41,582 --> 00:04:43,815
we don't know the class of the thing we're talking to,
我们不知道的事情我们说的类,
因为我们并不知道我们联系的究竟是谁

91
00:04:43,884 --> 00:04:47,385
And structured manner, so that we can clearly understand what
和结构化的方式,这样我们就可以清楚地理解
这个通信也是规范化的，才能保证大家都能理解

92
00:04:47,454 --> 00:04:50,189
communication is happening, So you've already seen a blind
通信正在发生,所以你已经看到一个盲人
发送的是什么信息。你已经看到过这样的

93
00:04:50,257 --> 00:04:51,957
structured communication between the view and
结构化视图和之间的沟通
规范化的匿名通讯，在视图

94
00:04:52,025 --> 00:04:54,926
the controller, It's target action, okay, So
控制器,它的目标行动,所以
和控制器之间使用。这叫 target-action，目标对象-操作模式

95
00:04:54,995 --> 00:04:57,529
the controller can drop a target on itself
控制器可以降低目标
控制器可以把自己设置为目标

96
00:04:57,598 --> 00:05:00,665
by basically creating a method with that @IBAction,
通过与这@IBAction基本上创建一个方法,
然后创建个响应对应 @IBAction 操作的方法

97
00:05:00,734 --> 00:05:05,303
remember that from Monday? And then you just control drag and
还记得从周一吗?
还记得我们星期一的时候干的吗？按住 Control 键拖拽

98
00:05:05,372 --> 00:05:08,006
that lets the view UIButton talk,
让视图UIButton说话,
来创建 UIButton 视图的通讯

99
00:05:08,074 --> 00:05:11,509
basically connect up to that target, And now every
基本上连接这一目标,现在每一个
也就是关连那个通讯目标

100
00:05:11,578 --> 00:05:14,279
time that the UIButton wants to talk to the controller,
次UIButton想跟控制器,
现在每次那个 UIButton 想要给控制器发送消息

101
00:05:14,348 --> 00:05:17,382
it's just sending that target action, So that is
只是发送目标动作,这就是
只需要把操作发送给目标对象即可

102
00:05:17,451 --> 00:05:21,920
super simple blind structured communication from the view
超级简单盲目的结构化的沟通从视图
这就是视图使用的标准化匿名通讯机制

103
00:05:21,989 --> 00:05:26,425
back to the controller, But, that's a little too simple for
控制器,但这有点太简单了
并以此来联系控制器。但是有的时候

104
00:05:26,493 --> 00:05:30,128
all the communication that these minions might wanna do,
所有这些奴才的沟通可能要做,
这种方式不足以实现这些下属的需求

105
00:05:30,197 --> 00:05:32,697
For example, sometimes, something in the view wants to
例如,有时候,在视图中想要的东西
比如有时候视图想要

106
00:05:32,766 --> 00:05:34,799
synchronize itself with the controller,
同步控制器本身,
和控制器保持同步

107
00:05:34,868 --> 00:05:37,903
Or it wants to know what the controller intends as it's
也想知道控制器的计划
或了解控制器使用自己想达到的目标

108
00:05:37,972 --> 00:05:41,239
being used, Let's use the example of a scroll view,
正在使用,让我们使用滚动视图的例子,
拿 UIScrollView 举例子

109
00:05:41,308 --> 00:05:43,108
Okay, a scroll view,
好的,滚动视图,
滚动视图

110
00:05:43,177 --> 00:05:44,709
when it's scrolling around,
滚动的时候,
在四处滑动的时候

111
00:05:44,778 --> 00:05:46,444
might wanna ask the controller,
可能想问控制器,
可能会想问控制器

112
00:05:46,513 --> 00:05:48,914
should I allow the user to scroll over here? Or
我应该允许用户滚动呢?
我能让用户滑动到这里吗？

113
00:05:48,982 --> 00:05:51,750
they might just wanna tell the controller, hey, the user
他们可能只是想告诉控制器,嘿,用户
或者想要告诉控制器

114
00:05:51,819 --> 00:05:55,486
scrolled down here, These kind of notifications and
和滚动,这样的通知
用户已经滑动到这里了。这种通知

115
00:05:55,555 --> 00:05:58,957
questions about whether it can do things, they kind of end up
问题是否能做事情,他们最终
和询问能否做某些事情的行为

116
00:05:59,026 --> 00:06:01,760
in things that start with these words I have up here,
的东西从上面这些话我已经开始,
通常都能被这样归类

117
00:06:01,828 --> 00:06:03,996
"will," "should," and "did," Like,
“将”、“应该”和“,”,
“will”（将要），“should”（能否）和“did”（已经）

118
00:06:04,064 --> 00:06:07,399
should I scroll to here? I will scroll right here,
我要滚动到这里吗?
“我应该滑动到这里吗”？“我将要滑动到这里”

119
00:06:07,468 --> 00:06:08,800
if the scroll view was about to scroll, And
如果滚动视图滚动,
如果滚动视图要开始滑动了

120
00:06:08,869 --> 00:06:11,637
then I did scroll down here after the scroll view is done,
我往下滚动视图完成后,
以及完成之后的“我已经滑动到这里了”

121
00:06:11,705 --> 00:06:14,373
So those kinds of communications,
这些类型的通信,
就是这类的通讯

122
00:06:14,441 --> 00:06:16,641
And the way we make that communication work,
和我们进行沟通的方式工作,
我们实现这类沟通的方法

123
00:06:16,710 --> 00:06:19,377
we can't just do this simple one method control drag,
我们不能只做这简单的一个方法控制阻力,
并不只是简单的按 Control 拖拽

124
00:06:19,446 --> 00:06:22,380
instead we use what's called a delegate, And I'm gonna talk
相反,我们使用所谓的代表,我要说话
而是通过 delegate，委托代理

125
00:06:22,449 --> 00:06:25,984
a lot more about a delegate in future lectures, But basically
更多关于一个委托在以后的讲座,但基本上
之后的课程里我会细讲委托模式

126
00:06:26,053 --> 00:06:29,788
the idea of a delegate is, it's a var in the view, so
一个委托的想法是,这是一个var在视图中,
简单来说代理是视图里的一个变量

127
00:06:29,857 --> 00:06:34,192
like a var on scroll view, And it's of a special type; that
像一个var滚动视图,这是一种特殊类型,
比如 UIScrollView 里的一个属性，类型十分特殊

128
00:06:34,261 --> 00:06:37,295
type is called a protocol, I know that a lot of you,
类型被称为一个协议,我知道你们很多人,
叫做 protocol，协议。我知道你们大部分人

129
00:06:37,364 --> 00:06:38,664
even though you have object oriented experience,
即使你有面向对象的经验,
即使有使用面向对象编程的经验

130
00:06:38,732 --> 00:06:40,699
maybe you don't have experience with protocols, But
也许你没有经验的协议,但是
也很有可能没有使用过协议

131
00:06:40,768 --> 00:06:42,000
essentially, a protocol is a way of
从本质上讲,一个协议的一种方式
协议本质上是一种

132
00:06:42,069 --> 00:06:45,804
saying that this type, this thing that I'm talking about,
说这个类型,这个东西,我说的是,
我这里的这个变量

133
00:06:45,873 --> 00:06:49,908
it responds to a certain set of methods, I don't know what
这对一个特定的方法,我不知道
能够响应这些方法

134
00:06:49,977 --> 00:06:52,344
class it is, I don't know if it's a view controller,
类,我不知道这是一个视图控制器,
我不知道它具体是什么类型，也不知道是不是 ViewController

135
00:06:52,413 --> 00:06:53,678
I don't know what it is, but
我不知道那是什么,但是
虽然我不知道具体是什么

136
00:06:53,747 --> 00:06:56,215
I know it's gonna respond to these methods like will
我知道它会回应这些方法等
但是我知道它拥有这些方法，比如

137
00:06:56,283 --> 00:06:58,783
scroll, did scroll, should scroll,
滚动,滚动,滚动,
willScroll, didScroll, shouldScroll

138
00:06:58,852 --> 00:07:01,420
those kinds of methods, That's all I know about it, So
这些方法,这就是我知道的,所以
我所知道的就是它有这类的方法

139
00:07:01,488 --> 00:07:05,423
the controller, it signs up to listen to those methods,
控制器,它报名听这些方法,
所以控制器如果想要监听这些事件

140
00:07:05,492 --> 00:07:08,994
and then it sets itself as the delegate in the view,
然后它集本身为委托在视图中,
就可以把自己设为视图的 delegate

141
00:07:09,062 --> 00:07:10,862
Okay, and we're gonna see this in action, so
好的,我们会看到在行动,
我们还会实际用到的

142
00:07:10,931 --> 00:07:13,097
don't worry about too much now, but that's how we can
现在不要担心太多,但我们可以
所以现在理解不了不用担心

143
00:07:13,166 --> 00:07:15,534
have structured communication where they're agreeing,
结构化的沟通,他们同意,
不过这就是规范通讯的方法

144
00:07:15,602 --> 00:07:18,136
The view, this generic object is agreeing to
看来,这个通用的对象是同意
通用的视图同意

145
00:07:18,205 --> 00:07:20,605
send certain messages to the controller,
某些消息发送到控制器,
给控制器发送一定的信息

146
00:07:20,674 --> 00:07:23,208
not where the controller can be of any type and
并不是任何类型的控制器可以
所以控制器可以是任何类型的

147
00:07:23,277 --> 00:07:26,144
still serve this purpose of controlling its view,
仍然服务于这一目的的控制它的视图,
同时又能实现控制视图的功能

148
00:07:26,213 --> 00:07:30,616
Now there's a special kind of communication between the view
现在有一种特殊的视图之间的沟通
控制器和视图之间还有一种特殊的联系

149
00:07:30,684 --> 00:07:34,686
and the controller that arises because a view cannot own
视图和控制器,是因为不能自己
起因是视图不会包含它所需要的数据

150
00:07:34,755 --> 00:07:38,356
the data it displays, And what does that mean? That means you
数据显示,这是什么意思?
这是什么意思呢？

151
00:07:38,425 --> 00:07:41,460
don't want to have inside your view class, and remember, view
不想在你的视图类,记住,视图
这意味着你不希望在视图

152
00:07:41,528 --> 00:07:43,928
classes are like scroll views, buttons, things like that,
类就像滚动视图、按钮,
也就是比如滚动视图，按钮这些类中

153
00:07:43,997 --> 00:07:46,531
You don't wanna have data in there that is
你不想有数据
你不希望有特定的数据

154
00:07:46,600 --> 00:07:49,701
the data you're displaying, I'll give you an example,
你显示的数据,我将给你一个例子,
也就是要展示的数据。我们举个例子

155
00:07:49,770 --> 00:07:51,870
Let's say your entire iPod music library,
假设你的整个iPod音乐库,
比如你 iPod 里面的音乐库

156
00:07:51,939 --> 00:07:54,640
let's say you have hundreds of thousands of songs in there,
假设你有成千上万的歌曲,
里面有成千上万的歌曲

157
00:07:54,708 --> 00:07:58,410
Okay, so I wanna have a list of them on screen, So
好的,所以我想有一个列表在屏幕上,所以
我希望把它们展示出来

158
00:07:58,479 --> 00:08:02,314
I'm gonna use a generic item in my view called table view,
我将使用一个通用的项目在我看来称为表视图,
因此我用一个通用的 UITableView 来展示

159
00:08:02,383 --> 00:08:04,783
Table view just shows a big long list of something,
表视图只显示一大长串的东西,
表格视图的功能是显示一长串内容

160
00:08:04,852 --> 00:08:08,320
It can be a list a million items long, okay? So
它可以是一个一百万个条目的列表,好吗?
比如一个有一百万项内容的列表

161
00:08:08,388 --> 00:08:11,422
if I really had to take my entire iPod library and
如果我真的要把我整个图书馆和iPod
如果我需要把整个音乐库里的歌曲

162
00:08:11,491 --> 00:08:13,592
put it in the value of a var of
把它放在的var的价值
放到 UITableView 的某个变量中

163
00:08:13,660 --> 00:08:17,696
the table view to display it, that would be ridiculous,
表视图显示它,那将是荒谬的,
让它去展示，那这样做是很荒唐的

164
00:08:17,764 --> 00:08:20,131
Not just from a performance standpoint, but
不仅从性能的角度来看,但是
先不考虑程序的性能

165
00:08:20,200 --> 00:08:22,000
now I have two copies of my iPad, or
现在我有两个我的iPad的副本,或
因为我现在相当于有两个 iPad

166
00:08:22,069 --> 00:08:25,003
my iPod music library, one inside this table view, and
我的iPod音乐库,一个在这个表格视图,
有两个 iPad 的音乐库：一个在表格视图里

167
00:08:25,072 --> 00:08:27,973
one in some database somewhere in my phone, That's bad, where
一个在某些数据库在我的电话,那就糟糕了,
一个在 iPhone 上的某个数据库里。这是不合适的

168
00:08:28,041 --> 00:08:30,742
they could get out of sync, managing the synchronicity,
他们可能会不同步,管理同步,
它们无法保持同步，内容可能会过时

169
00:08:30,811 --> 00:08:32,644
what if I have multiple apps doing that? Ugh,
那如果我有多个应用程序做什么?
又比如我有很多个程序都在这么做呢？

170
00:08:32,713 --> 00:08:36,481
it's a mess, so the view never wants to own that data, okay?
这是一片混乱,所以从来没有想自己的数据视图,好吗?
那简直是一团糟。所以视图不应该保存一份数据

171
00:08:36,550 --> 00:08:38,483
So how the heck is it gonna get the data then?
所以到底是如何得到的数据呢?
那又要从哪里获得数据呢？

172
00:08:38,551 --> 00:08:41,486
I've got 100,000 songs, I need to show it in this table,
我有100000首歌曲,我需要显示这个表,
我这里有很多首歌，我需要把它们显示到列表里

173
00:08:41,555 --> 00:08:45,123
how's it gonna do it? Well, it's gonna use another one of
它会怎么做?
实现的方法是通过另一个

174
00:08:45,191 --> 00:08:49,227
these protocol based vars, okay, called the data source,
这些协议基于var,所谓的数据源,
存储协议类型的变量，这个叫做 dataSource

175
00:08:49,296 --> 00:08:51,496
And the data source has different methods in it,
数据源有不同的方法,
数据源拥有和代理不一样的方法

176
00:08:51,565 --> 00:08:54,666
it's not will, should, did, it's how many items are in
这不是应该会做的,有多少物品
就不是 will，should 和 did 了。数据源知道有多少

177
00:08:54,735 --> 00:08:59,904
this piece of data? Give me the data at this location, And
这段数据?
也就是数据的具体个数，这个位置的数据是什么

178
00:08:59,973 --> 00:09:03,508
that, again, is a var that controllers
再次,这是一个控制器的var
控制器会把 dataSource

179
00:09:03,576 --> 00:09:06,444
set in the table view, let's say, that points back to it,
设置在表视图中,比方说,点回来,
表格视图里的变量设为自己

180
00:09:06,513 --> 00:09:08,380
And so now every time the table view wants data,
现在每次表视图要数据,
之后表格视图想要数据的时候

181
00:09:08,448 --> 00:09:11,182
it asks the controller, And the controller almost
它要求控制器,控制器几乎
就会问 dataSource，也就是控制器

182
00:09:11,251 --> 00:09:14,886
always turns around and asks the model, give me that data,
总是在问模型,给我这些数据,
接着控制器一般会问模型，让它提供数据

183
00:09:14,955 --> 00:09:17,789
Now this also allows something like table view that's showing
这还允许类似的表视图显示
所以对于那些需要显示大量数据的表单视图

184
00:09:17,857 --> 00:09:21,760
100,000 items, It can only show 10 on a screen at a time,
100000件,它只能显示10在屏幕上,
因为实际屏幕上每次只能显示 10 个

185
00:09:21,828 --> 00:09:25,163
so it only asks for 10 and shows them, And if you scroll
所以它只要求10,显示了他们,如果你滚动
可以只临时获得 10 条数据来显示。如果你向下滑

186
00:09:25,232 --> 00:09:28,167
down to somewhere else, it's gonna ask for that 10,
到别的地方,它会要求10,
滑动到了其它地方，它又去要另外 10 条

187
00:09:28,235 --> 00:09:31,135
And it's only keeping the ones it's displaying, So
只有保持的显示,所以
每次只缓存当前展示部分的数据

188
00:09:31,204 --> 00:09:34,105
it's transferring a lot less data, only the data you're
将少了很多数据,只有你的数据
所以每次传送的数据都很少，只是实际上

189
00:09:34,174 --> 00:09:37,642
actually viewing, 10 out of 100,000 songs, And so it's
实际上看,10的100000首歌曲,这是
在展示的部分，比如十万首歌只选十首

190
00:09:37,711 --> 00:09:40,779
a lot more efficient, both in terms of memory usage and
更高效,无论是内存使用
因此也变得更加高效，包括使用更少的内存

191
00:09:40,848 --> 00:09:42,848
everything, Now you might be a little scared,
一切,现在你可能会有点害怕,
和其它的方面。现在你可能会担心

192
00:09:42,917 --> 00:09:44,749
like, every single time I'm gonna scroll,
每一次我要滚动,
每次我滑动的时候

193
00:09:44,818 --> 00:09:45,583
I'm gonna be asking for
我要要求
我都要去获取这些数据啊

194
00:09:45,652 --> 00:09:48,152
this data, But keep in mind, the model for
这些数据,但记住,模型
这你不必担心，你想想

195
00:09:48,221 --> 00:09:51,290
the iPod's music library is probably a SQL database or
iPod的音乐库可能是一个SQL数据库或
iPod 音乐库很有可能是类似于 SQL 的数据库

196
00:09:51,358 --> 00:09:54,626
something, something that can serve up data super fast,
东西,可以提供数据非常快,
能够快速地获得数据

197
00:09:54,695 --> 00:09:58,564
That's it's job as a model to be the source of that data,
它的工作模式是数据的来源,
这是它作为模型的任务就是提供数据

198
00:09:58,632 --> 00:10:02,167
okay? So that is usually not your performance bottleneck,
好吧?
所以一般不会在性能上拖你的后腿

199
00:10:02,236 --> 00:10:03,936
We're gonna talk about performance later in this
我们将讨论性能在稍后
之后的课程我们会讲到性能

200
00:10:04,004 --> 00:10:06,104
class, by the way, Usually the performance bottleneck is
类,顺便说一下,通常性能瓶颈
这方面你通常会遇到的瓶颈

201
00:10:06,173 --> 00:10:08,707
drawing on the screen, Things like getting data out of
在屏幕上绘图,得到数据
是在屏幕上绘制内容。像这种从数据库中获取数据

202
00:10:08,776 --> 00:10:12,243
databases, forget it, Drawing on the screen is much slower
数据库,忘记它,画在屏幕上是慢得多
你可以忽略不计。在屏幕上绘制很慢

203
00:10:12,312 --> 00:10:14,880
and then going over the network is even slower,
然后通过网络更慢,
通过网络加载内容更慢

204
00:10:14,949 --> 00:10:17,082
So those things tend to dominate the performance of
所以这些东西往往主宰的性能
这些才是影响你程序性能的主要原因

205
00:10:17,150 --> 00:10:20,418
your app, Okay, so don't worry about that, So anyway, so
你的应用,所以不要担心,总之,
所以可以放心大胆地从模型加载数据

206
00:10:20,487 --> 00:10:23,021
that's a couple of examples how we have the structured
这是几个例子如何结构化
通过这几个例子，我们具体了解了

207
00:10:23,090 --> 00:10:25,056
communication from generic objects back to our
回到我们的沟通从通用的对象
通用控件是如何采用规范化的通讯模式

208
00:10:25,125 --> 00:10:30,696
controller, Now what about sorry, one statement that's
控制器,那么对不起,一个声明
联系控制器的。等等，还有一句话

209
00:10:30,764 --> 00:10:33,198
good to put in your mind that has all three camps in it,
好把你脑海中有三个阵营,
你最好记住，在这三个阵营中

210
00:10:33,266 --> 00:10:37,035
is that the controller interprets and formats
这是控制器解释和格式吗
控制器负责把模型里的数据

211
00:10:37,103 --> 00:10:40,939
the model for its views, Cuz its views are generic, they
模型的观点,因为其观点是通用的,他们
转化为视图能接受的类型。因为视图是通用的

212
00:10:41,007 --> 00:10:43,175
don't really know how to deal with any particular model,
真的不知道如何处理任何特定的模型,
它们并不知道如何处理任何特定的模型

213
00:10:43,243 --> 00:10:46,011
A controller knows about both, so that's part of its job,
一个控制器知道,这是其工作的一部分,
但控制器知道，所以由它负责

214
00:10:46,079 --> 00:10:47,846
So a lot of times I'll be saying,
很多时候我会说,
以后我会常说

215
00:10:47,915 --> 00:10:50,882
the controller's job is to do this, and you'll be like,
控制器的工作是要做到这一点,你会喜欢,
“控制器负责这个”。这时候

216
00:10:50,951 --> 00:10:53,886
yeah, I remember him saying that, All right, now what
是的,我记得他说,好吧,现在
你最好能想起我提到过这个。好，下一个

217
00:10:53,954 --> 00:10:56,422
about the model communicating with the controller?
模型与控制器通信呢?
模型去联系控制器呢？

218
00:10:57,991 --> 00:11:02,060
Now this can never happen as well because the model is
这也永远不会发生,因为模型
这是不应该发生的，就像模型不依赖 UI 一样

219
00:11:02,129 --> 00:11:04,796
UI independent, It knows nothing about any particular
UI独立,它任何特定一无所知
模型对用户界面一无所知

220
00:11:04,865 --> 00:11:07,298
UI, so there's no way it could talk to a UI guy like
UI,所以没有办法和一个UI的家伙说话
所以它不能够和负责 UI 的控制器交流

221
00:11:07,367 --> 00:11:11,803
the controller, okay? So what happens, though, if the model
控制器,好吗?
那如果模型发生了变化呢？

222
00:11:11,871 --> 00:11:15,741
changes, the data changes? That controller needs to know,
变化,数据变化?
数据发生了改变呢？控制器必须要知道啊

223
00:11:15,809 --> 00:11:18,243
because it wants to update the screen in that case,
因为它想更新屏幕在这种情况下,
这样它才能更新显示的数据

224
00:11:18,311 --> 00:11:20,813
Well, the way we do that is with a model that
我们做的模型
我们实现的方法是

225
00:11:20,881 --> 00:11:24,049
kind of looks like a radio station, okay? The model
看起来像一个电台,好吗?
在模型中建立一个“电台”

226
00:11:24,117 --> 00:11:26,985
basically has a radio station, and it broadcasts on that
主要有一个广播电台,广播
通过这个电台发送广播通知

227
00:11:27,054 --> 00:11:31,289
radio station, hey, I changed, or this about me changed, And
广播电台,嘿,我改变了,或者对我改变,
说“数据发生变化了”，或者是“这部分数据发生了变化”

228
00:11:31,358 --> 00:11:34,926
then the controller tunes in to that radio station, And
然后控制器音乐电台,和
控制器通过观察收听的那个电台

229
00:11:34,995 --> 00:11:38,997
when it hears a broadcast, it asks the model what changed,
当它听到广播,它问模型改变,
在接到通知的时候，就问模型什么数据变了

230
00:11:39,066 --> 00:11:42,400
down that green arrow there, you see? Okay, so
绿色箭头,你看到了吗?
还是通过我们这里的这个绿色通道

231
00:11:42,469 --> 00:11:45,670
that's the model we're gonna use, that's the mechanism
我们将使用的模型,这是机制
所以这就是我们用的机制

232
00:11:45,739 --> 00:11:49,141
we're gonna use to get stuff for our model that changes
我们会使用更改为我们的模型得到的东西
通过这种方式让模型

233
00:11:49,210 --> 00:11:52,610
to notify our controller, Some people ask, can
通知我们的控制器,有些人问,可以
通知控制器。有人会问

234
00:11:52,679 --> 00:11:55,347
a view tune in to a radio station? And the answer is,
一个视图收听电台?
视图应该收听那个电台吗？当然你可以

235
00:11:55,415 --> 00:11:58,216
yeah, it probably could, It wouldn't necessarily violate
是的,它可能不一定会违反
也并不一定会违背 MVC 的原则

236
00:11:58,285 --> 00:12:01,052
MVC, But the problem is a generic view wouldn't know
MVC,但问题是不知道通用视图
但问题是，通用的视图并不知道

237
00:12:01,121 --> 00:12:03,888
what radio station to tune into anyway, so it's really
什么电台收听,这是真的
具体要收听哪个电台。因为这是无法实现的

238
00:12:03,957 --> 00:12:07,726
not an issue there, All right, so an MVC like this, though,
没有一个问题,所以MVC,不过,
所以不会成为我们考虑的问题。然而，这样的一个 MVC

239
00:12:07,795 --> 00:12:11,897
really is not, like your whole app isn't one big MVC,
真的不是,喜欢你的整个应用程序并不是一个大的MVC,
不可能代表你整个程序，它不会只是一个大的 MVC

240
00:12:11,965 --> 00:12:15,166
Each MVC controls either one screen on an iPhone or
每一个屏幕在iPhone或MVC控制
每个 MVC 只会控制屏幕上的一个部分

241
00:12:15,235 --> 00:12:18,103
maybe even a subpart of a screen on an iPhone or
甚至iPhone屏幕上或组成部分
甚至只会是屏幕上的一小部分

242
00:12:18,172 --> 00:12:19,338
an iPad, Maybe there's two or
iPad,也许有两个或两个
有可能 iPhone 或 iPad 上

243
00:12:19,406 --> 00:12:23,442
three MVCs controlling what's going on on the screen, so
三个mvc控制在屏幕上正在发生的事情,所以
一个屏幕同时有两三个 MVC 来控制

244
00:12:23,510 --> 00:12:25,977
how do we build a big app? An app, you know,
我们如何建立一个大型应用程序?
那我们如何构建一个大型项目呢？

245
00:12:26,046 --> 00:12:29,214
it's building an Instagram app, I gotta have MVCs for
这是构建一个Instagram应用程序,我需要mvc
比如 Instagram 这种图片社交程序

246
00:12:29,283 --> 00:12:32,117
posting, I gotta have MVCs for image editing so
帖子,我需要mvc图像编辑
我需要发图片的 MVC，我需要编辑图片的 MVC

247
00:12:32,186 --> 00:12:35,653
I can do my sepia tone, I gotta have an MVC for
我能做的深褐色的语气,我需要的MVC
加个棕褐色的怀旧滤镜。我还需要一个 MVC

248
00:12:35,722 --> 00:12:37,856
scrolling through the latest posts that are coming up,
滚动的最新的帖子,
让我通过滑动查看最新发布的内容

249
00:12:37,925 --> 00:12:40,793
I mean, I need all kinds of MVCs, How do these things, how
我的意思是,我需要各种各样的mvc,这些东西,怎么怎么做
我想说的就是我们需要各种各样的 MVC

250
00:12:40,861 --> 00:12:43,696
do we combine them together? Well, looks like this,
我们把它们组合到一起呢?
这些 MVC 是如何协同工作的呢？实际上看起来是这样的

251
00:12:45,466 --> 00:12:50,235
MVCs, when other MVCs point to them, it's always as
mvc,当其他mvc指向他们,总是
当一个 MVC 指向另一个 MVC 的时候

252
00:12:50,304 --> 00:12:54,573
part of another MVC's view, So look at the three
另一个MVC的视图,看看这三个
被指像的那个会被作为当前 MVC 的视图

253
00:12:56,076 --> 00:12:58,242
MVCs that are down here in the lower right corner,
mvc是在右下角,
看这里右下角的三个 MVC

254
00:12:58,311 --> 00:13:01,579
You see these three MVCs? See this MVC up here, this purple
你看到这三个mvc吗?
看到这三个了吗？看到上面中间的这个紫色的控制器了吗？

255
00:13:01,648 --> 00:13:05,049
one? Look how it points to them as if they were part of
一个?
它就是通过像连接自己视图一样指向这些 MVC

256
00:13:05,118 --> 00:13:09,655
its view, You see that? There are no other arrows that point
它的视图中,您看到了吗?
看到了吗？这里所有的箭头

257
00:13:09,723 --> 00:13:12,725
from one controller to another MVC except for
从一个控制器来另一个MVC除外
其中从一个控制器到另一个控制器的那些

258
00:13:12,793 --> 00:13:16,394
that goes through this view side of the MVC,
通过这个视图的MVC,
无一不是通过视图这边连接的

259
00:13:16,463 --> 00:13:21,599
Let me help you make that more concrete why that is,
让我帮你做更具体的原因,
我再具体解释为什么是这样

260
00:13:21,668 --> 00:13:24,136
Let's say I had an app and it was a calendar app, and it was
假设有一个应用程序,这是一个日历应用程序,它是
比如我有一个日历程序

261
00:13:24,205 --> 00:13:27,973
showing me the year, okay, a whole year's worth of my
告诉我,好的,我一整年的
展示了整整一年，一年里所有的日期

262
00:13:28,042 --> 00:13:31,743
calendar entries, Well, on a tiny screen it's barely gonna
日历条目,在小屏幕上几乎要
对于比较小的屏幕来说，很难让它

263
00:13:31,811 --> 00:13:34,212
be able to show me the 12 months, let alone the days and
可以给我12个月,更不用说天了
展示十二个月里全部的日子和其它内容

264
00:13:34,281 --> 00:13:36,715
the things, right? So it's got this picture of the months,
的事情,对吧?
所以我选择只显示每个月

265
00:13:36,783 --> 00:13:40,352
So that's a year MVC, let's say, in my calendar app, So
这是一年MVC,比方说,在我的日历应用程序,所以
这就是这个日历应用里负责每一年的 MVC

266
00:13:40,420 --> 00:13:42,821
I click on one of the months cuz I want some more detail,
我点击一个月因为我想要一些更多的细节,
如果我需要更多细节，就点对应的月份

267
00:13:42,890 --> 00:13:45,623
And now that year MVC moves out of the way and
现在那一年和MVC的移动方式
这个时候每年的 MVC 就隐藏了

268
00:13:45,692 --> 00:13:49,761
puts up an MVC that's showing all the days of a month, okay?
提出一个显示所有的MVC的日子一个月,好吗?
同时换上显示这个月每一天的 MVC

269
00:13:49,830 --> 00:13:53,031
Well, that month MVC, which is a totally separate MVC,
这月MVC,这是一个完全独立的MVC,
这个负责每个月的 MVC 和之前的是完全分开的

270
00:13:53,100 --> 00:13:55,833
do you see how it's part of the year MVC's view?
你看到它是如何MVC的视图的一部分吗?
可以看出为什么是作为年这个 MVC 的视图了吗？

271
00:13:55,902 --> 00:13:58,136
Because the year MVC is showing months,
因为今年MVC显示几个月,
因为每年里会展示这些月份

272
00:13:58,205 --> 00:14:00,438
You wanna look at it, it's trying to zoom in on it,
你想看它,它试图放大,
你会在看了之后尝试放大到每个月的视图

273
00:14:00,507 --> 00:14:03,808
it does it with another MVC, And same thing, in the month,
它与另一个MVC,同样的事情,在这个月,
这是通过另一个 MVC 实现的。同理，在每个月里

274
00:14:03,877 --> 00:14:06,745
if I click on a day, the month MVC's gonna move out of
如果我点击一天,本月MVC会搬出
如果我点具体一天，负责那个月的 MVC 就消失了

275
00:14:06,814 --> 00:14:11,983
the way, Put a day MVC that shows me all my appointments,
的方式,把一天的MVC显示我所有的约会,
换成现实当天日程的 MVC

276
00:14:12,052 --> 00:14:15,721
for a day and that day MVC would be part of the view of
一天,那一天MVC视图的一部分
这个每一天的 MVC 又是那个月 MVC 的视图

277
00:14:15,790 --> 00:14:19,157
the month MVC, okay, make sense? So that's why,
本月MVC,好的,有意义吗?
我说的有道理吧？这就是为什么

278
00:14:19,226 --> 00:14:21,860
that's the only relationship we have between MVCs is across
这是唯一的mvc之间的关系
MVC 间的关系只会是

279
00:14:21,929 --> 00:14:24,662
this view boundary, Now there can be other communication,
这个视图边界,现在可以有其他交流,
作为另一个的视图。我们再看看其它种类的通信

280
00:14:24,731 --> 00:14:26,798
however, Look right here,
然而,看这里,
比如看这里

281
00:14:26,867 --> 00:14:29,634
This MVC, the purple one in the top middle there,
这个MVC,紫色一个在顶部,
这个上面中间的紫色控制器

282
00:14:29,703 --> 00:14:32,905
it's communicating to a model that is the same model as some
它的通信模型,一些是相同的模型
它联系的模型和另一个 MVC 是相同的

283
00:14:32,973 --> 00:14:36,542
other MVC, So MVCs can share the same model, That's
其他MVC,MVC可以共享相同的模型,
也就是 MVC 之间可以共享模型

284
00:14:36,610 --> 00:14:38,944
perfectly fine, The models are completely UI independent,
非常好,模型UI是完全独立的,
这是允许的，因为模型不会和 UI 挂钩

285
00:14:39,012 --> 00:14:42,014
They don't care how many MVCs are looking at them, okay?
他们不在乎有多少mvc看着他们,好吗?
因此并不会介意被多个 MVC 共享

286
00:14:42,082 --> 00:14:45,050
Cuz they don't even know about controllers,
因为他们甚至不知道控制器,
它们也不了解具体的控制器

287
00:14:45,119 --> 00:14:46,985
Right, they're completely independent of that,
对的,他们是完全独立的,
所以也是能保持独立的

288
00:14:47,054 --> 00:14:49,421
Also notice these two models down at the bottom,
还请注意这两个模型在底部,
还要注意这下面的两个模型

289
00:14:49,489 --> 00:14:52,890
they're talking to each other, That's okay, too, because
他们相互交谈,没关系,,因为
它们在相互传递信息。这也是可以的

290
00:14:52,959 --> 00:14:56,794
a model can be defined any way it wants, It's UI independent,
一个模型可以定义任何它想要的,它的UI独立,
因为模型想怎么实现就怎么实现，和 UI 不相关

291
00:14:56,863 --> 00:14:58,196
it can talk to other models, whatever,
它可以与其他模型,无论如何,
所以能够联系其它模型

292
00:14:58,264 --> 00:15:00,966
Now of course, it's still gonna wanna radio broadcast if
当然,它仍然会想无线电广播
当然，如果模型的内容会发生改变

293
00:15:01,034 --> 00:15:04,203
maybe this model changes something in it, But
也许这模型变更,但是
还是要通过“电台”通知

294
00:15:04,271 --> 00:15:06,004
it still can talk directly to the model, so
这样模型,还可以直接对话
同时直接联系当然是可以的

295
00:15:06,072 --> 00:15:08,941
that's the other communication that can happen, But
这是可能发生的其他沟通,但是
这就是最后一种沟通的方式

296
00:15:09,009 --> 00:15:10,675
no other communication can happen,
没有其他通信可以发生,
除此以外就没有了

297
00:15:10,744 --> 00:15:13,545
We do not want our apps to look like this, Okay,
我们不希望我们的应用程序是这样的,好吧,
我们不希望程序最后变成这样

298
00:15:13,613 --> 00:15:17,048
we've got these MVCs, and look, see this view over here?
我们有这些mvc,看,看到这一观点呢?
我们有一团 MVC。看这里的这个视图

299
00:15:17,117 --> 00:15:19,984
It's talking to a different controller, This controller is
这是与不同的控制器,这个控制器
它在和不同的控制器通信

300
00:15:20,053 --> 00:15:22,554
talking directly to another one, not out of view, but
直接说另一个,而不是视图,但是
这个控制器不是通过视图

301
00:15:22,623 --> 00:15:25,691
just off to this side, You don't want this mess, If you
只是这一边,你不想要这个烂摊子,如果你
而是直接操作另一个控制器。你不会想要这样的乱局

302
00:15:25,759 --> 00:15:28,594
do this mess, you really, you're not even doing an MVC,
做这个烂摊子,你真的,你连做一个MVC,
如果最后变成了这样，其实你是没有使用 MVC 的

303
00:15:28,662 --> 00:15:29,694
Cuz everybody's in the same camp,
因为每个人都在同一阵营,
因为没有分工，都在一个阵营里

304
00:15:29,763 --> 00:15:31,463
they're all just talking to each other,
他们都只是交谈,
想说就说，为所欲为

305
00:15:31,532 --> 00:15:34,967
okay? So this is a no-go, And, of course,
好吧?
所以这是不被允许的

306
00:15:35,035 --> 00:15:37,769
I'll be showing you, not next week, but the week after,
下周我将向您展示,而不是,但一周后,
我会在再下一周展示

307
00:15:37,838 --> 00:15:40,672
how we build these connections between MVCs, For the first
我们如何构建这些mvc之间的连接,第一
如何建立 MVC 之间的联系

308
00:15:40,741 --> 00:15:42,874
two weeks, we're just gonna focus on building one MVC,
两个星期,我们要专注于构建一个MVC,
我们前两周的时间，只会用到一个 MVC

309
00:15:42,943 --> 00:15:44,976
our calculators, one MVC, But
我们的计算器,一个MVC,但是
我们的计算器只是一个 MVC

310
00:15:45,045 --> 00:15:48,146
we're gonna add another MVC to our calculator in week three,
我们要添加另一个MVC计算器在三周,
第三周的时候再加入另一个 MVC

311
00:15:48,214 --> 00:15:52,283
And you're gonna see, that's how we wire these things up,
你会看到,这就是我们线这些东西,
然后你就知道如何把它们链接起来了

312
00:15:52,352 --> 00:15:54,953
okay? So that's MVCs, We're gonna dive back into
好吧?
MVC 就讲完了

313
00:15:55,021 --> 00:15:57,155
continuing our calculator demo here, Again,
继续我们的计算器演示,
我们继续完成计算器

314
00:15:57,224 --> 00:15:59,058
this is a slide you're gonna look at later and
这是一个幻灯片你要看之后
同样的，这一页是给你们之后看的

315
00:15:59,126 --> 00:16:02,194
say, did I learn all these things? I hope so,
说,我学习所有这些东西吗?
问问自己是否学会了。我希望是的

316
00:16:02,263 --> 00:16:03,962
And I'm not going back to these slides,
我不会回到这些幻灯片,
我准备现在把课件放完

317
00:16:04,031 --> 00:16:06,631
So let me talk about what's coming up, On Friday, we have
让我谈谈接下来会发生什么,在周五,我们有
所以讲讲接下来几节课的内容

318
00:16:06,700 --> 00:16:09,367
this debugging Friday session, I still don't have a room for
这个星期五调试会话,我仍然没有一个房间
星期五是讲调试，我还没有找到教室

319
00:16:09,436 --> 00:16:10,769
it, but it will be announced on Piazza,
它,但它将宣布在广场,
找到后会在 Piazza 上通知

320
00:16:10,837 --> 00:16:13,371
It's gonna be around noon, maybe 1 o' clock,
它会在中午,也许1 o '时钟,
课程大概在中午的时候吧，也许是下午一点

321
00:16:13,440 --> 00:16:15,907
maybe 11, I know some of you have conflicting things
也许11,我知道你们中的一些人有冲突的事情
或者是上午十一点。我知道你们那个时候都很忙

322
00:16:15,976 --> 00:16:17,943
in that time and might not be able to make it,
在此期间,可能无法使
很有可能没法来上课

323
00:16:18,012 --> 00:16:21,045
It's optional, I hope you're all able to make it, however,
它是可选的,我希望你们都可以,但是,
这是选修课，不过我还是希望你们能尽量参加

324
00:16:21,114 --> 00:16:24,082
We'll also in that one, be going over some like Xcode
我们也会在,会在一些像Xcode
不过我们还会讲些 Xcode 里常用的快捷键

325
00:16:24,151 --> 00:16:27,753
shortcuts, how to get around in Xcode a little more easily,
快捷方式,如何规避在Xcode中更容易,
如何更便捷地使用 Xcode

326
00:16:27,822 --> 00:16:29,621
Cuz I always end up clicking on everything, so
因为我总是点击结束一切,所以
我总是通过点击操作

327
00:16:29,690 --> 00:16:30,455
you can see what I'm doing, But
你可以看到我在做什么,但是
好让你们看清我在干什么

328
00:16:30,524 --> 00:16:34,092
there's command keys you can do to really master Xcode, And
有命令键你可以真正掌握Xcode和
不过你可以掌握 Xcode 提供的快捷键

329
00:16:34,161 --> 00:16:35,426
then don't forget Monday's a holiday, so
不要忘记周一假日,所以
星期一放假

330
00:16:35,495 --> 00:16:36,661
don't show up here,
别在这里出现,
你们不要跑来上课

331
00:16:36,730 --> 00:16:39,798
And then next Wednesday, the reading assignment I
然后下个星期三,我阅读作业
下周三，要完成我星期一布置的阅读作业

332
00:16:39,866 --> 00:16:42,267
assigned on Monday, plus the programming assignment that
安排周一,加上编程任务
以及编程作业

333
00:16:42,336 --> 00:16:44,836
I just put on Piazza today, are both due
我把今天在广场,都是由于
我今天才放上 Piazza 的那个

334
00:16:44,905 --> 00:16:47,405
next Wednesday, And then next Wednesday, you'll get another
下星期三,然后在下周三,你会得到另一个
下周三两个都要交。下周三

335
00:16:47,474 --> 00:16:49,074
reading assignment and another programming assignment,
阅读作业,另一个编程任务,
我还会布置另一个阅读作业和编程作业

336
00:16:49,143 --> 00:16:53,712
which will be due a week later, okay? Okay,
这将是由于一个星期后,好吗?
再下周交，好吧

337
00:16:53,780 --> 00:16:58,550
here we go, back to our calculator, here's where,
好了,回到我们的计算器,在这里,
好了，可以开始编计算器了

338
00:16:58,618 --> 00:17:03,221
exactly where we left off right here, And as I said when
哪里我们离开这里,当我说时
这是我们之前讲到的地方

339
00:17:03,290 --> 00:17:07,058
we were there, this is a great little calculator,
我们在那里,这是一个很棒的小计算器,
之前说这个计算器看起来不错

340
00:17:07,127 --> 00:17:11,963
it's nice, But it's kind of bad that this code right here,
这很好,但有点糟糕,这个代码,
只不过金玉其外，败絮其中

341
00:17:12,032 --> 00:17:15,734
which is the what of this calculator, what is this?
这个计算器的什么,这是什么?
主要是这部分实现计算器功能的代码

342
00:17:15,802 --> 00:17:18,737
This is a calculator, Here's the calculations happening,
这是一个计算器,计算发生,
这是什么？一个计算器，由这里完成计算

343
00:17:18,805 --> 00:17:20,905
That really needs to be in a different camp,
真的需要在一个不同的阵营,
这应该放到另一个阵营里

344
00:17:20,974 --> 00:17:24,342
It can't be in the controller like this, So that's the main
它不可能在这样的控制器,这是主要的
并不应该放在控制器中。所以我们主要的内容

345
00:17:24,411 --> 00:17:26,511
thing we're gonna do in this demo right here,
我们要做的事情在这个演示,
也就是我们今天要完成的是

346
00:17:26,580 --> 00:17:28,080
is we're gonna create a model for
我们要创建一个模型吗
给这个计算器

347
00:17:28,148 --> 00:17:28,981
this calculator,
这个计算器,
创建一个模型

348
00:17:29,049 --> 00:17:31,149
where we're gonna put all this calculation,
我们要把这些计算,
负责所有的计算

349
00:17:31,217 --> 00:17:33,685
And then we're gonna make this model really powerful and
然后我们会让这个模型真的很强大
然后我们要把这个计算器编的很强大

350
00:17:33,754 --> 00:17:35,687
extensible as you'll see, So,
可扩展您将看到,所以,
同时可高度定制

351
00:17:35,755 --> 00:17:39,657
we need to create a new data structure for our model, and
我们需要为我们的模型,创建一个新的数据结构
我们控制器需要一个新的数据结构

352
00:17:39,726 --> 00:17:41,927
we do that with File > New > File,
我们使用File > New >文件,
所以通过菜单栏中的 File > New > File

353
00:17:41,995 --> 00:17:44,396
Any time we wanna create a new class or new structure or
任何时候我们想要创建一个新的类或新结构
任何时候我们想要新建一个类，结构体

354
00:17:44,464 --> 00:17:46,764
any kinda new data structure, this is what we do,
任何新的数据结构,这是我们做的,
或是其它数据类型的时候，我们都这样新建一个文件

355
00:17:46,833 --> 00:17:51,937
So we hit this, it's gonna be a Swift File right here,
所以我们点击这个,它会迅速文件在这里,
我们点这个 Swift File

356
00:17:52,005 --> 00:17:53,472
We'll look at it, maybe one or two of these others,
我们来看看它,也许一两个,
我们也许会用到这些

357
00:17:53,541 --> 00:17:54,940
actually we probably won't even look at those,
实际上我们甚至可能不会看那些,
其实基本上不会用到

358
00:17:55,008 --> 00:17:57,675
It's almost always gonna be a Swift File that you create
这是几乎总是会迅速创建的文件
我们基本都会选 Swift File

359
00:17:57,744 --> 00:18:01,547
here, Here it is, it wants to know the name, So this is
这里,在这里,它想要知道这个名字,这是
点 Next 之后问你文件的名字

360
00:18:01,615 --> 00:18:04,015
the brain of my calculator, right, the guts of it,
计算器的大脑,它的勇气,
因为它是计算器的“大脑”，内部结构

361
00:18:04,084 --> 00:18:06,818
So I'm gonna call this CalculatorBrain, That's gonna
所以我要调用这个计算器大脑的
所以叫做 CalculatorBrain

362
00:18:06,887 --> 00:18:10,088
be the name of the data structure that I'm gonna use
的名字我要使用的数据结构
我们把它作为这个数据结构的名字

363
00:18:10,157 --> 00:18:13,992
here, And I'm gonna make sure I put it in the same group,
在这里,我要确保我把它放在同一组,
确认我下面选择把它放在

364
00:18:14,061 --> 00:18:16,861
down here, as all the rest of my
下面,我所有的其余部分
和其它文件同一个 Group 中

365
00:18:16,930 --> 00:18:19,431
classes like ViewController, see that ViewController,swift?
类像ViewController、看到ViewController迅速?
比如 ViewController，看到 ViewController.swift 了吗？

366
00:18:19,500 --> 00:18:22,034
I'm gonna put it in the same place there,
我要把它放在同一个地方,
我要把它们放在一起

367
00:18:22,103 --> 00:18:24,236
All right, so here it is on the left and right,
好吧,这是左和右,
好了，一左一右

368
00:18:24,305 --> 00:18:27,139
actually, let's just make it fill the whole screen,
实际上,我们先把它填满整个屏幕,
还是隐藏 Assistant Editor 好了，全屏

369
00:18:27,208 --> 00:18:30,175
If we look in the navigator, now we have three files,
如果我们看在navigator,现在我们有三个文件,
如果我们看这里的导航面板，现在就有三个文件了

370
00:18:30,244 --> 00:18:33,512
okay, there's our controller, there's our view, and
好的,这就是我们的控制器,我们的观点,
ViewController 是控制器，Storyboard 负责视图

371
00:18:33,580 --> 00:18:38,216
there's our model, MVC, voila, okay, it's that easy, Now,
我们的模型,MVC,瞧,好吧,那就是容易,现在,
最后是模型。MVC，看吧，就这么简单

372
00:18:38,285 --> 00:18:42,854
we need (in this model) to think a little bit about what its
我们需要在这个模型中考虑一下它
要好好想想这个模型应该包含哪些公共 API

373
00:18:42,922 --> 00:18:46,457
public API is, In other words, what does this model allow
公共API,换句话说,这个模型允许
公共接口，也就是这个模型允许其它人

374
00:18:46,526 --> 00:18:48,393
other people, like controllers,
其他人,如控制器,
比如控制器

375
00:18:48,462 --> 00:18:51,896
to do? Okay, that's one of the most fundamental things that
做什么?
实现的操作。最基础的部分

376
00:18:51,965 --> 00:18:54,166
you wanna do whenever you're doing design,
你想当你做设计,
你设计数据结构的时候都要考虑的

377
00:18:54,234 --> 00:18:57,636
Just think about what the public API, does everyone know
只是想想公共API,大家都知道
设计好公共接口。大家都知道什么是应用程序编程接口吗？

378
00:18:57,704 --> 00:19:00,538
what API means? Application programming interface,
API意味着什么吗?
Application Programming Interface，API

379
00:19:00,607 --> 00:19:03,508
It's all the methods and properties, Snd so
它的所有方法和属性,先期
即所有的方法和属性

380
00:19:03,577 --> 00:19:06,744
your public API is the methods and properties you're gonna
你的公共API是你要的方法和属性
public API，公共的接口是

381
00:19:06,813 --> 00:19:09,848
allow other classes or other data structures to access,
允许其他类或其他数据结构访问,
你允许其它类和结构体访问的方法和属性

382
00:19:09,916 --> 00:19:13,051
So we really, really wanna think about that, Quickly also
所以我们真的,真的要想想,也很快
所以我们要好好考虑

383
00:19:13,120 --> 00:19:16,254
notice that we've imported Foundation here, not UIKit,
注意,我们进口的基础,不是UIKit,
注意到这里是 import Foundation，而不是 UIKit

384
00:19:16,323 --> 00:19:20,258
because this is not going to be a UI class, right? This
因为这不是一个UI类,对吧?
因为这不会是和 UI 相关的类

385
00:19:20,327 --> 00:19:24,630
is UI independent, this is the model, Now I could say here,
是UI独立,这是模型,现在我可以说,
这是模型，是独立于用户界面的。我在这里可以写

386
00:19:24,698 --> 00:19:28,433
okay, let's create a class called CalculatorBrain, Nope,
好的,让我们创建一个类称为计算器大脑不,
class CalculatorBrain，创建一个类

387
00:19:28,502 --> 00:19:32,203
not Brian, brain, So I could do that, but I'm actually not
布莱恩,大脑,所以我可以这样做,但我不是
打错了，是 Brain，不是 Brian。我可以这么做

388
00:19:32,272 --> 00:19:35,307
going to do that, I'm gonna use a different data structure
要这样做,我将使用一个不同的数据结构
但我不会这么做。因为我会使用另一种数据类型

389
00:19:35,376 --> 00:19:39,711
here than a class, all right? I'm gonna use a struct, Now,
这里比一个类,对吧?
不是 class（类）而是 struct（结构体）

390
00:19:39,780 --> 00:19:42,347
you're probably used to using struct in other languages, but
你可能习惯使用结构体在其他语言中,但是
你可能在其它语言中使用过结构体

391
00:19:42,416 --> 00:19:44,983
you probably think of it as just like a little collection
你可能认为它就像一个小的收集
认为那就是个集合

392
00:19:45,052 --> 00:19:48,753
of other variables is a struct, In Swift,
其他变量是一个结构体,迅速、
包含了些其它的变量

393
00:19:48,822 --> 00:19:50,889
struct is a first class citizen,
结构体是一等公民,
在 Swift 中 struct 是一等公民

394
00:19:50,957 --> 00:19:53,691
very much like the class, okay? And I'm gonna talk about
很像,好吗?
和 class 是差不多的

395
00:19:53,760 --> 00:19:55,928
the difference between that in a second, And in fact,
在第二个的区别,事实上,
我马上会讲到底有什么区别

396
00:19:55,996 --> 00:20:00,298
most of the commonly used classes in Swift are structs,
最迅速的常用类结构、
事实上 Swift 里常用的“类”其实都是结构体

397
00:20:00,367 --> 00:20:04,202
like string, double, array, dictionary,
如字符串、双数组,字典,
比如 String，Double，Array，Dictionary

398
00:20:04,271 --> 00:20:07,005
these are all structs, they're not classes, So
这些都是结构,它们不是类
都是结构体，不是类

399
00:20:07,074 --> 00:20:09,340
what's the difference between a struct and a class?
什么是结构体和类的区别?
那结构体和类的区别在哪里呢？

400
00:20:09,409 --> 00:20:11,143
I'm gonna talk in detail about it next week, but
下周我将详细讨论,但是
我下周会详细说明

401
00:20:11,211 --> 00:20:12,978
I'm gonna tell you two important differences,
我要告诉你两个重要的差异,
但接下来会先说说两个重要区别

402
00:20:13,046 --> 00:20:14,880
the two most important differences,
两个最重要的差异,
非常重要的区别

403
00:20:14,949 --> 00:20:18,217
One thing, classes have inheritance,
类有继承,有一件事
第一个，类是可以继承的

404
00:20:18,285 --> 00:20:21,386
structs do not, okay? So if you're building
结构不?
但结构体不行。所以如果你想

405
00:20:21,454 --> 00:20:23,956
something that you think is gonna need to be sub classed
你认为需要的子分类
构造一个能扩展的对象

406
00:20:24,024 --> 00:20:26,658
to be extensible, you probably wanna make it a class, I'm
是可扩展的,你可能想要把它一个类,我
就必须用类

407
00:20:26,727 --> 00:20:29,194
gonna make my CalculatorBrain extensible in a different way
将计算器大脑可扩展的方式不同
我用其它方式扩展 CalculatorBrain

408
00:20:29,263 --> 00:20:30,195
as you'll see, so
如您所见,
如你马上所见的

409
00:20:30,264 --> 00:20:33,265
it doesn't need to be a class, I could possibly change
它不需要一个类,我可能会改变
所以我没有使用类。如果我稍后改变主意

410
00:20:33,333 --> 00:20:35,534
it back to a class if I change my idea later, but
它返回一个类如果我改变我的想法之后,但是
可以随时改为类

411
00:20:35,602 --> 00:20:38,303
my current architecture does not need to be sub classed,
我目前的架构不需要子分类,
但我当前的结构不需要 CalculatorBrain 的子类

412
00:20:38,372 --> 00:20:41,239
so that's one difference, The other difference,
这是一个差异,其他差异,
这是其一。另外一个区别

413
00:20:41,308 --> 00:20:42,073
huge difference, and
巨大的差异,
本质的区别

414
00:20:42,142 --> 00:20:44,343
the one that's gonna take the most getting used to for
的最适应需要
也是你需要理解的概念

415
00:20:44,411 --> 00:20:49,180
you conceptually, is that classes live in the heap, and
你从概念上讲,这类活在堆中,
类存储在堆中

416
00:20:49,249 --> 00:20:53,151
you have pointers to them, Structs do not live in
你有指针,结构不生活在
通过指针传递。结构体存储在栈上

417
00:20:53,220 --> 00:20:58,156
the heap, and they are passed around by copying them, okay?
堆,传递通过复制它们,好吗?
通过拷贝值传递

418
00:20:58,225 --> 00:21:02,293
We call the copying style value types,
我们所说的复制样式值类型,
我把拷贝值传递叫值类型

419
00:21:02,362 --> 00:21:06,564
We call the, in the heap file, style, reference types,
我们所说的,在堆中文件,风格,引用类型,
存储在堆中的方式叫引用类型

420
00:21:06,633 --> 00:21:09,067
Because we have a reference to them in the class case,
因为我们班上有一个参考的情况下,
类通过引用来使用

421
00:21:09,136 --> 00:21:10,902
we actually copy them around in the struct case,
我们复制他们在结构的情况下,
而结构体需要拷贝值使用

422
00:21:10,971 --> 00:21:14,105
Now, you know, that might seem like a big restriction,
现在,你知道,这可能看起来像一个大的限制,
那看起来，使用结构体会有很大的限制

423
00:21:14,174 --> 00:21:16,207
I gotta copy these things around, what if they're big?
我要复制这些事情,如果他们大吗?
结构体很大的时候，也会拷贝吗？

424
00:21:16,276 --> 00:21:19,912
But as I mentioned on Monday, these things are passed around
周一,但正如我所提到的,这些东西都是传递
星期一提到的，凡是通过拷贝值传递的

425
00:21:19,980 --> 00:21:23,048
copy on right, So when you pass them around, if you don't
在正确的拷贝,所以当你通过他们,如果你不
都会采用“写时复制”，也就是如果

426
00:21:23,117 --> 00:21:26,819
actually change them, then no copy is actually made, Okay,
实际上改变它们,那么实际上是由没有副本,好吧,
没有改变它的值，那么是不会进行拷贝的

427
00:21:26,887 --> 00:21:30,155
but it's all behind the scenes for you, all right?
但这都是在幕后,好吗?
这些都是在内部自动完成的

428
00:21:30,224 --> 00:21:31,155
So that's a huge difference,
这是一个巨大的差异,
这就是本质的差别

429
00:21:31,224 --> 00:21:33,992
Now why would I want my CalculatorBrain to be a struct
为什么我想要计算器大脑结构
为什么我会把 CalculatorBrain 定义为结构体而不用类呢？

430
00:21:34,060 --> 00:21:37,095
instead of a class? Well, I don't imagine I'm gonna have
而不是一个类?
因为我想象不到会有

431
00:21:37,164 --> 00:21:39,064
a whole bunch of different people referencing it,
一大堆不同的人引用它,
其它地方需要引用它

432
00:21:39,133 --> 00:21:42,334
The CalculatorBrain is a brain for an MVC,
MVC的计算器大脑是一个大脑,
CalculatorBrain 是 MVC 的核心

433
00:21:42,402 --> 00:21:45,137
So that MVC is gonna access it, but I, I don't see a lot
MVC将访问它,但是我,我没有看到很多
所以 MVC 会访问它，除此之外

434
00:21:45,205 --> 00:21:49,008
of other entities somehow trying to point to this thing,
其他实体不知怎么想的,
没有其它实体会尝试引用它

435
00:21:49,076 --> 00:21:50,875
So I don't really need to be reference type,
所以我真的不需要引用类型,
所以我不需要引用类型

436
00:21:50,944 --> 00:21:55,814
okay, I can have it be a value type from that standpoint, So
好吧,我可以是一个值类型的角度来看,
基于这点，我使用值类型

437
00:21:55,883 --> 00:21:58,250
it's probably fine, Also it's a great opportunity for
它也可能很好,这是一个伟大的机会
而且这是个很好机会

438
00:21:58,319 --> 00:22:01,286
me to show you what it looks like to make a struct because
我向你们展示一个结构,因为它是什么样子
让我展示如何使用结构体

439
00:22:01,355 --> 00:22:03,621
making a struct looked almost just like being a class,
做一个struct看起来几乎就像被一个类,
像使用类一样使用结构体

440
00:22:03,690 --> 00:22:05,024
but there's a couple minor differences,
但是有一些细微的差别,
但多多少少还是有些区别的

441
00:22:05,092 --> 00:22:07,726
which you're gonna see real soon here, okay?
很快,你会看到的,好吗?
你很快就会知道

442
00:22:07,795 --> 00:22:09,895
So now back to the public API,
所以现在回到公共API,
OK，回到 public API（公共接口）

443
00:22:09,963 --> 00:22:12,764
what is the public API of this? Well, I know that
这的公共API是什么?
这里需要定义什么公共接口呢？

444
00:22:12,832 --> 00:22:15,466
this CalculatorBrain is gonna need a func that performs
这个计算器并用是需要执行的函数
我知道 CalculatorBrain 需要一个方法来执行数学计算

445
00:22:15,535 --> 00:22:19,304
operation, Okay, for sure because that's fundamentally
操作,因为这是根本
这是最基本的要求

446
00:22:19,373 --> 00:22:22,508
what it does, It performs an operation, And we'll use
它做什么,它执行一个操作,我们将使用
它需要执行数学计算

447
00:22:22,576 --> 00:22:25,210
the same mechanism we used on Monday to define it,
相同的机制我们周一用于定义它,
我们用周一使用的方式来定义它

448
00:22:25,279 --> 00:22:29,982
I will have some mathematical symbol be the thing that
我将有一些数学符号的东西
我会通过数学符号

449
00:22:30,050 --> 00:22:35,620
defines what operation we're performing, okay? And notice
定义了我们执行什么操作?
来判断需要执行什么计算

450
00:22:35,689 --> 00:22:40,125
that I made the external name be blank, It's a close call
我做外部的名字是空白,这是千钧一发
注意，这里实参标签（argument label）为空

451
00:22:40,194 --> 00:22:42,561
here as whether you would want it to be symbol,
在这里你是否想要的象征,
但你可能觉得实参标签叫 symbol 更好

452
00:22:42,629 --> 00:22:45,697
In other words, would I call performOperation like this,
换句话说,我叫performOperation中像这样,
或者说，我会这样调用 performOperation

453
00:22:45,766 --> 00:22:48,567
okay, performOperation(symbol, whatever, Or
好的,performOperation中(象征,无论如何,或
performOperation(symbol: XXXXX)

454
00:22:48,636 --> 00:22:53,939
whether I want it to be blank, and I say performOperation,
我是否想要一片空白,我说performOperation中,
相比之下，我觉得留空更好，我会这样读 performOperation

455
00:22:54,007 --> 00:22:56,475
and I just put the string, the symbol in here like pi or
我只是把字符串,在这里像π或象征
然后把像 pi 或者其它符号放进去

456
00:22:56,543 --> 00:22:59,244
whatever, It's a close call here,
无论如何,这是一场势均力敌的电话,
这更贴近调用的意思

457
00:22:59,313 --> 00:23:02,014
this is a close judgement call as to which is better,
这是一个接近判断调用哪个更好,
很容看出哪种调用方式更好

458
00:23:02,082 --> 00:23:04,015
I'm gonna go with this because I think reading this code,
我要用这个,因为我认为阅读这段代码,
我会保留这样，因为我觉得代码更通顺易读

459
00:23:04,084 --> 00:23:07,586
performOperation pi makes perfect sense to me,
performOperation中π对我意义非凡,
performOperation("π") 读起来更通顺

460
00:23:07,655 --> 00:23:10,121
Adding the word symbol in there doesn't really
添加这个词没有真正象征
在这里增加 symbol 字符作为实参标签

461
00:23:10,190 --> 00:23:11,489
make it any clearer to me, so
我让它更清楚,所以
并没有提高可读性

462
00:23:11,558 --> 00:23:14,492
that's the way I'm gonna go with this one, Okay,
这就是我要用这个,好吧,
所以我选择这样写

463
00:23:14,561 --> 00:23:17,228
what else do I need? Well, if you're performing operations,
我需要什么?
OK，接下来还要做什么？很明显，如果要执行计算

464
00:23:17,297 --> 00:23:19,531
you have to have operands to perform one, right?
你必须执行一个操作数,对吧?
就必须要一个操作数

465
00:23:19,600 --> 00:23:20,365
If you're doing square root,
如果你做的平方根,
如果要执行平方根

466
00:23:20,434 --> 00:23:22,234
you have to do square root of something, whatever, So
你要做根,不管,所以
那么你必须对某个操作数执行平方根

467
00:23:22,303 --> 00:23:25,236
I'm gonna have to have some func that sets the operand as
我要有一些函数,设置操作数
所以我必须定义一个方法来设置操作数

468
00:23:25,305 --> 00:23:28,206
well, okay? And again, I'm gonna have no external name,
好吧,好吧?
参数这里依然没有实参标签

469
00:23:28,275 --> 00:23:32,544
and we'll call it the operand, And I'm gonna have my
我们会称它为操作数,我要有我
形参名称（parameter name）叫 operand

470
00:23:32,612 --> 00:23:35,814
entire CalculatorBrain work in doubles, It's
整个的计算器大脑工作双打,这是
我让整个 CalculatorBrain 都使用 double（浮点类型）

471
00:23:35,883 --> 00:23:39,084
gonna be a double precision CalculatorBrain, so I'm gonna
将双精度的计算器大脑,所以我将
所以 CalculatorBrain 是浮点精度的

472
00:23:39,152 --> 00:23:42,120
have the operand be a double, Now, here's a case where I
操作数是一个双,现在,这里有一个情况吗
所以我定义 operand 也是浮点类型

473
00:23:42,188 --> 00:23:45,223
definitely know that I don't wanna have an external name,
肯定知道我不想有一个外部的名字,
这里我也没有定义实参标签

474
00:23:45,292 --> 00:23:48,393
because saying setOperand (operand: 5,0), that's
因为说setOperand(操作数:5,0),这是
因为 setOperand(operand: 5.0) 并不通顺

475
00:23:48,461 --> 00:23:51,830
ridiculous, that's completely redundant, don't need it,
荒谬,完全是多余的,不需要它,
有点累赘，完全是多余的，所以不需要

476
00:23:51,899 --> 00:23:55,467
It's very clear, if I do this, setOperand(5,0),
很明显,如果我这样做,setOperand(5,0),
setOperand(5.0) 更容易理解

477
00:23:55,536 --> 00:23:58,102
That's clear what I'm talking about, So no question in my
很清楚我在说什么,所以我没有问题
而且读起来也更通顺，我觉得

478
00:23:58,171 --> 00:24:01,173
mind that that's better, And then you set the operand,
注意,这是更好的,然后你设置操作数,
这样更好。然后这里设置 operand

479
00:24:01,242 --> 00:24:03,775
you perform operations, guess what? You gotta
你执行操作,你猜怎么着?
执行了某个运算，然后呢？

480
00:24:03,843 --> 00:24:08,013
get the result, Now, I could have a func to getResult or
得到的结果,现在,我可以有一个func getResult或
你需要一个方法来获取计算结果。我可以定义一个方法

481
00:24:08,081 --> 00:24:12,150
something like that, That returns a double, right?
这样,返回一个双,对吗?
像 getResult 之类的，返回的是浮点类型

482
00:24:12,218 --> 00:24:15,420
That's one thing I do, But that's really not very Swift,
这是我做的一件事,但真的不是很迅速,
就像这样，但不推荐在 Swift 这么做

483
00:24:15,489 --> 00:24:18,556
Really in Swift what you would do is you say, here's a result
在斯威夫特你所要做的是你说,这是一个结果
在 Swift 里，最好这样，定义一个 result 变量

484
00:24:18,625 --> 00:24:24,128
var, that returns result, Now the only problem with that UI,
var,返回结果,现在唯一的问题,UI,
这就是计算返回的结果。唯一要注意的是

485
00:24:24,197 --> 00:24:28,800
or that API rather, is I don't want anyone to set my result,
或API,而我不希望任何人把我的结果,
对于这个 API（应用程序接口），我不希望其它人能修改结果

486
00:24:28,869 --> 00:24:31,670
I'm the calculator brain, I calculate the result, So
我大脑计算器,计算结果
结果应该计算器来计算

487
00:24:31,739 --> 00:24:33,438
this needs to be read-only,
这需要只读的,
所以要定义这个变量为只读

488
00:24:33,507 --> 00:24:38,210
Anyone remember how we can make a var read-only?
谁记得我们如何做一个var只读?
有谁知道怎么设置变量为只读？

489
00:24:38,279 --> 00:24:44,349
No? Someone suggest let, And that's kinda
没有?
没人知道吗？有人说用 let

490
00:24:44,418 --> 00:24:47,819
not exactly what let does, Let makes it to constant,
不是什么让,让让它不变,
用 let 有点不太准确。因为 let 定义的是常量

491
00:24:47,888 --> 00:24:50,922
meaning that it's read-only, But it can only set once,
这意味着它是只读的,但它只能设置一次,
虽然也是只读，但 let 只能在定义的时候赋值

492
00:24:50,991 --> 00:24:54,059
Whereas result is constantly changing, So we can't do let,
而结果是不断变化的,所以我们不能做,
计算结果需要不断变化，所以不能用 let

493
00:24:54,127 --> 00:24:56,528
unfortunately, But it's a really good guess,
不幸的是,但它是一个很好的猜测,
但这是个好想法

494
00:24:56,596 --> 00:25:00,365
Actually we do it with the computed property thing, Okay,
实际上我们做计算属性的东西,好吧,
实际上可以使用 computed property（计算型属性）

495
00:25:00,434 --> 00:25:02,467
remember we computed that display value and
记得我们计算和显示值
记得之前定义 displayValue 变量的

496
00:25:02,536 --> 00:25:05,170
we had get and set? Well, we just don't do the set, right?
我们已经获取和设置?
get 和 set 属性吗？只要去掉 set 就可以了

497
00:25:05,239 --> 00:25:07,706
In this case we're just not gonna do, Just not put that on
在这种情况下,我们不只是要做的,不是把它
在这里，把 set 去掉，留下 get

498
00:25:07,775 --> 00:25:09,741
there, Boom, this is a read-only property,
繁荣,这是一个只读属性,
这就是只读属性

499
00:25:09,810 --> 00:25:13,945
Everybody got that? It's like currentTitle on button,
大家都明白了吗?
就像 button 的 currentTitle 属性

500
00:25:14,014 --> 00:25:15,981
It's get only, All right now,
现在只能得到,所有,
也是只读的。接下来

501
00:25:16,050 --> 00:25:18,917
I'm gonna think a little bit about the internal
我要想一下内部
在使用之前，我需要考虑下

502
00:25:18,985 --> 00:25:22,287
implementation of this before I go and start using this
实现在我走之前,开始使用这个
这里内部如何实现

503
00:25:22,355 --> 00:25:26,091
thing, I know that a calculator brain, internally,
的事情,我知道一个计算器的大脑,在内部,
我知道计算器内部

504
00:25:26,160 --> 00:25:30,728
it kind of accumulates its answer as it's going, And
它的回答会累积到一定程度,和
需要保存计算的结果

505
00:25:30,797 --> 00:25:34,700
so I'm actually gonna have an internal var, and watch this,
所以我要有一个内部的var,看这个,
所以我定义一个私有变量，看这里

506
00:25:34,769 --> 00:25:40,004
private var, I'm gonna call it accumulator, I'm
私人var,我会叫它蓄电池,我
private var（私有变量），命名为 accumulator

507
00:25:40,073 --> 00:25:43,441
gonna make it a double, okay? So this is gonna be internal,
要使它成为一个双,好吗?
类型为 double（浮点类型）。这是一个私有变量

508
00:25:43,510 --> 00:25:46,178
So now, other people can't access this,
现在,其他人无法访问,
其它外部成员无法访问它

509
00:25:46,246 --> 00:25:49,414
That's what private means, And for all your homeworks for
这就是私人的意思,你所有的作业
这就是私有的含义。在这季的所有作业里

510
00:25:49,483 --> 00:25:52,184
this entire quarter, I want you to put private in front of
整个季度,我想让你把私人的面前
我希望你在所有你认为是内部使用的变量前

511
00:25:52,252 --> 00:25:56,087
things that you think are internal implementation,
什么东西你认为是内部实现,
都增加 private 关键字

512
00:25:56,156 --> 00:25:59,191
To any class you've create in this, in this course, okay?
在这你创建任何类,在本课程中,好吗?
任何本课程中写的代码都这么做

513
00:25:59,260 --> 00:26:01,326
So get used to doing that, It's very important,
所以习惯了这样做,这是非常重要的,
要成为一种习惯，这很重要

514
00:26:01,394 --> 00:26:04,529
These three are not private, They're public,
这三个都不是私有的,这些画是公开的。
这三个不是私有的，是公有的

515
00:26:04,598 --> 00:26:07,065
I'm gonna allow other people to call these, But
我要让别人称这些,但是
其它外部成员可以访问调用它们

516
00:26:07,133 --> 00:26:12,070
this one is internal, Now, one thing you notice is
这是内部的,现在,你注意到的一件事是
这个是内部私有的。有一点要注意

517
00:26:12,138 --> 00:26:16,441
I don't have any error up here that says no initializer,
我没有任何错误在这里说没有初始化,
这里没有初始化，但没有提示任何错误

518
00:26:16,510 --> 00:26:18,810
Remember that when I created a var in
还记得,当我创建了一个var
记得之前在 ViewController 中

519
00:26:18,879 --> 00:26:20,178
the view controller,
视图控制器,
创建变量吗？

520
00:26:20,247 --> 00:26:22,714
and it said that there's no initializers, And I had to
说没有初始化,我不得不
会抛出没有初始化的错误

521
00:26:22,782 --> 00:26:25,984
make userInTheMiddleOfTyping equal false, Why don't
使userInTheMiddleOfTyping等于错误,为什么不
必须初始化 userInTheMiddleOfTyping 等于 false

522
00:26:26,053 --> 00:26:30,255
I have to do it here? That's because this is a struct, And
我在这里有什么关系呢?
为什么这里不需要呢？这是因为这是结构体

523
00:26:30,324 --> 00:26:33,258
structs automatically get an initializer,
结构自动初始化,
结构体会自动提供一个构造器

524
00:26:33,327 --> 00:26:36,495
That will initialize all of their uninitialized vars,
将初始化所有的未初始化,var,
通过那个构造器来初始化所有未初始化的属性

525
00:26:36,563 --> 00:26:38,163
okay? You get a free initializer,
好吧?
所以你并不需要自己提供一个构造器

526
00:26:38,231 --> 00:26:40,365
You don't get that with class, Only with the structs, so
你不会用类,只与结构,所以
但在类中就不能这样做，只有结构体可以

527
00:26:40,433 --> 00:26:42,033
there is one difference between class and structs,
类和结构体之间有一个区别,
这也是类和结构体的一个区别

528
00:26:42,102 --> 00:26:44,570
So we're gonna have a struct, for CalculatorBrain, or
所以我们要有一个结构体,计算器大脑或
好，现在已经有个叫 CalculatorBrain 的结构体

529
00:26:44,638 --> 00:26:47,139
an initializer for CalculatorBrain, That will
计算器大脑的初始值设定项
它自动提供的构造器

530
00:26:47,207 --> 00:26:50,375
take a double and it'll initialize as accumulator,
双,蓄电池会初始化,
会通过浮点类型的参数来初始化 accumulator 变量

531
00:26:50,444 --> 00:26:52,344
But actually, I don't wanna do that,
但事实上,我不想那样做,
但实际上，我并不希望它这么做

532
00:26:52,413 --> 00:26:56,114
Because let me think of what is accumulator's initial value
因为我认为蓄电池的初始值是什么
我们真正想把 accumulator 初始化为什么？

533
00:26:56,182 --> 00:26:59,084
really wanna be? When someone creates a CalculatorBrain,
真的想要吗?
当 CalculatorBrain 被创建的时候

534
00:26:59,152 --> 00:27:02,020
I don't wanna have them to tell me what the accumulator's
我不想让他们来告诉我蓄电池的
我并不想知道 accumulator 变量的

535
00:27:02,089 --> 00:27:02,854
initial value is,
初始值,
初始化值是多少

536
00:27:02,923 --> 00:27:05,724
Because I know what the initial accumulator internally
因为我知道最初的蓄电池内部
因为我认为 accumulator

537
00:27:05,793 --> 00:27:10,929
its initial value is when I start up, It's not set,
它的初始值是当我启动时,它不是,
在我使用之前是不应该有值的

538
00:27:10,998 --> 00:27:13,098
So I'm gonna make this be an optional,
所以我要使这是一个可选的,
所以我把它的改为 optional（可选）类型

539
00:27:13,167 --> 00:27:15,467
Do you see why I'm making that an optional?
你知道为什么我做出一个可选的吗?
知道为什么吗？

540
00:27:15,535 --> 00:27:18,102
Because the accumulator when I create my brain, I haven't
由于蓄电池当我创建我的大脑,我没有
因为我在创建 CalculatorBrain 的时候

541
00:27:18,171 --> 00:27:21,306
accumulated any result, So I'm in this not set state,
积累的任何结果,所以我在这没有设置状态,
accumulator 没有记录任何结果，所以它是缺省值的可选类型

542
00:27:21,375 --> 00:27:24,009
So, it's a perfect opportunity to make this a double or
所以,这是一个绝佳的机会让这双
这是完美的解决方案，我可以在代码中把它设置为

543
00:27:24,078 --> 00:27:29,147
an optional so I can express that in my code, All right? So
一个可选的所以我可以表达我的代码,对吧?
使用可选的浮点类型

544
00:27:29,216 --> 00:27:31,549
if I have this internal accumulator right here,
如果我有这个内部蓄电池,
如果 accumulator 是私有的

545
00:27:31,618 --> 00:27:33,218
how can I use that to implement these?
我如何用它来实现这些?
这些怎么实现呢？

546
00:27:33,286 --> 00:27:36,354
Well, two of them are easy, Okay, setOperand
嗯,好的,setOperand,其中两个是容易
这两个地方都很容易实现

547
00:27:36,423 --> 00:27:39,958
just sets the accumulator equal to that operand, Okay,
设置蓄电池等于操作数,好吧,
setOperand 方法只要设置 accumulator 等于入参 operand

548
00:27:40,026 --> 00:27:42,227
cuz when you set a new operand to operate on,
因为当你设置一个新的操作数操作,
因为当你传入新的 operand 时

549
00:27:42,296 --> 00:27:45,096
that replaces anything you have on your accumulator,
替换任何你对蓄电池,
就会覆盖掉 accumulator 的旧值

550
00:27:45,165 --> 00:27:47,999
It's what you're now accumulating, So that, that
现在你的积累,所以,
这就是当前 accumulator 的值

551
00:27:48,068 --> 00:27:52,604
could be any, any easier than that, And then we get results,
可以是任何,任何比这更容易,然后我们得到结果,
这很容易做到。当你获取 result

552
00:27:52,673 --> 00:27:57,842
you're just gonna return the accumulator, Now,
你要返回蓄电池,现在,
你只要返回 accumulator 的值就可以了

553
00:27:57,911 --> 00:27:59,544
we've got a couple of errors here that we
我们这儿有几个错误
我们看到这里提示有几个错误

554
00:27:59,613 --> 00:28:01,813
have to deal with, What's this one right here?
必须处理,这个是什么?
需要我们处理。这一个是什么错误？

555
00:28:01,882 --> 00:28:03,381
This looks perfectly fine, How could this be bad?
这看起来非常好,这怎么可能坏呢?
这看起来并没问题，为什么会出错呢？

556
00:28:03,450 --> 00:28:06,284
Accumulator is an optional double, I'm setting it to
蓄电池是一个可选的两倍,我设置它
accumulator 是可选浮点类型

557
00:28:06,353 --> 00:28:09,287
a double, It's gotta work, what's the problem?
双,这是必须的工作,是什么问题?
赋给它一个浮点类型。这应该是可以的，会有什么问题？

558
00:28:09,356 --> 00:28:13,758
Says I cannot assign to this property, because self is
说我不能指定该属性,因为自我
这里提示 “I cannot assign to this property, because

559
00:28:13,827 --> 00:28:18,296
immutable, Self meaning the calculator brain is immutable,
不可变的,自我即计算器大脑是不可变的,
 self is immutable”。说因为 self 不能被修改

560
00:28:18,365 --> 00:28:21,834
And it's saying, do you wanna fix this by making this method
这是说,你想解决这个问题,使这个方法
提示还说，如果你想修复这个错误

561
00:28:21,902 --> 00:28:25,403
be mutating? You see he's trying to add this here,
是变异?
需要在该方法前增加 mutating。它已经提示这么做了

562
00:28:25,472 --> 00:28:26,738
Another difference between structs and
另一个结构体和之间的区别
这是结构体和类的另一个区别

563
00:28:26,806 --> 00:28:30,475
classes, if you have a method, okay? Or a property
类,如果你有一个方法,好吗?
如果你有一个方法，或者属性

564
00:28:30,543 --> 00:28:33,879
that you're setting, that well, if you have a method and
你设置,,,如果你有一个方法
当你在某个方法内

565
00:28:33,947 --> 00:28:36,715
it changes the value of this thing,
它改变了这个东西的价值,
修改它的值

566
00:28:36,784 --> 00:28:41,753
you have to mark it mutating, You have to tell Swift, this
你必须标记变异,你必须告诉迅速、
必须加上 mutating 关键字。你必须要告诉 Swift

567
00:28:41,821 --> 00:28:45,924
method can change the value of this struct, Why is that?
方法可以改变这个结构的值,这是为什么呢?
这个方法可以修改结构体的值。为什么会这样呢？

568
00:28:45,993 --> 00:28:48,627
It's because of that copy on write thing, Remember,
因为文案写的东西,记住,
这和写时复制有关

569
00:28:48,696 --> 00:28:51,530
I told you that structs are passed around by copying them,
我告诉你周围结构传递通过复制他们,
记得之前说过结构体通过拷贝传递

570
00:28:51,598 --> 00:28:53,632
And when you write to them, then it copies it, So
当你写信给他们,然后复制它
但当发生修改时，才会实际进行拷贝

571
00:28:53,700 --> 00:28:56,067
it has to know you're writing it by calling setOperand,
它必须知道它通过调用setOperand你写,
所以它必须知道你在调用 setOperand 修改了值

572
00:28:56,136 --> 00:28:58,036
So, you have to make setOperand be mutating func,
因此,你必须使setOperand变异函数,
所以你必须为 setOperand 增加 mutating 关键字

573
00:28:58,105 --> 00:29:02,807
So that's the difference between class and a struct,
这是类和结构体之间的区别,
这是类和结构体的区别

574
00:29:02,876 --> 00:29:05,644
With that, what's this error down here? A different error,
,下面这个错误是什么?
下面还有一个不同的错误

575
00:29:05,713 --> 00:29:11,550
Anyone know what this error is? Louder? Okay,
谁知道这个错误是什么?
谁知道这是什么错误？

576
00:29:11,619 --> 00:29:15,754
the problem here is we're trying to return a double,
这里的问题是我们要返回一个双,
在这里，我们尝试返回浮点类型

577
00:29:15,822 --> 00:29:20,893
an accumulator is an optional, Okay, so it's saying here,
一个累加器是一个可选的,所以说,
但 accumulator 是可选浮点类型，所以这里提示

578
00:29:20,961 --> 00:29:25,797
hey unwrap this, Now, I do not wanna do this here, Okay,
嘿,打开这个,现在,我不想做这个,好吧,
没有解包，但我不想这么解包

579
00:29:25,866 --> 00:29:28,800
because it's perfectly valid for the accumulator to be not
因为它是蓄电池不完全有效
因为这样的话，accumulator 就不能缺省可选值

580
00:29:28,869 --> 00:29:31,603
set, In fact, this starts out not set, And in fact,
集,事实上,这个开始不是,事实上,
但实际上，accumulator 一开始就是缺省值的

581
00:29:31,672 --> 00:29:34,406
I can think already of another case where the accumulator is
我可以认为已经累加器的另一个例子是
我能想到另一个例子，accumulator

582
00:29:34,475 --> 00:29:38,743
gonna be not set, What if I say, five times three equals,
会不会,如果我说,五乘以三等于
会是缺省值。例如我要计算：“5 x 3 = ”

583
00:29:38,812 --> 00:29:42,180
in my calculator? After I say five times,
在我的计算器?
当我输入“5 x”

584
00:29:42,249 --> 00:29:44,883
my accumulator is not set right now,
我现在蓄电池没有设置,
的时候，accumulator 是缺省值的

585
00:29:44,952 --> 00:29:49,187
Cuz I need the three equals until I can get the result, So
因为我需要三个=,直到我能得到结果,所以
因为我输入“3 =”时才会计算结果

586
00:29:49,256 --> 00:29:52,657
my accumulator's often gonna be going back to not set,
我的蓄电池经常会回到没有设置,
所以 accumulator 经常变成缺省值的可选类型

587
00:29:52,726 --> 00:29:56,228
When we're in that weird five times three equals five times,
当我们在那个奇怪的五乘以三等于五次,
在“5 x 3 =”中，输入“5 x”时

588
00:29:56,296 --> 00:29:58,897
the accumulator's not set right now, Three, okay,
蓄电池不是现在,三,好吧,
accumulator 是缺省值的

589
00:29:58,966 --> 00:30:00,599
the accumulator's set again, equals, okay,
蓄电池组,=,好吧,
输入“3”时，accumulator 有值了，输入“=”号

590
00:30:00,668 --> 00:30:02,233
here's the result, Okay,
这里是结果,好吧,
就计算出结果了

591
00:30:02,302 --> 00:30:04,536
so I can't have this be exclamation point,
所以我不能有一个感叹号,
所以这里不能有感叹号

592
00:30:04,604 --> 00:30:06,804
Or this thing is gonna crash every time someone asks for
或者这个东西会崩溃每次有人问
这样的话，每次输入“5 x”的时候获取结果

593
00:30:06,873 --> 00:30:10,542
the result after they say five times, So we can't have that,
结果他们说五次后,我们不可能,
程序就会崩溃，肯定不能这样

594
00:30:10,611 --> 00:30:15,614
So instead, I'm going to turn result into an optional, And
所以,我要把结果变成一个可选的,和
所以取而代之的，把返回结果改为可选类型

595
00:30:15,682 --> 00:30:16,514
that makes sense too,
这是有道理的,
这是有道理的

596
00:30:16,583 --> 00:30:20,419
Because if someone using this object in the middle of five
因为如果有人使用这个对象在5
因为如果输入“5 x”时

597
00:30:20,487 --> 00:30:24,156
times says, what's the results? It'll tell you it's
次说,结果是什么?
获取到的结果是什么？这里会返回缺省值

598
00:30:24,224 --> 00:30:26,925
not set, because I'm in the middle of five times, right?
没有,因为我在五次,对吧?
因为还没执行计算

599
00:30:26,994 --> 00:30:30,128
And in your homework, you're even gonna make it clearer to
在你的家庭作业,你甚至会使其更清晰
做作业的时候，你们尽量搞清楚

600
00:30:30,197 --> 00:30:33,298
users of this why this might not be set, okay? So
为什么这个用户可能不是集合,好吗?
为什么这里会是缺省值

601
00:30:33,367 --> 00:30:35,968
you'll see that, All right, so
好吧,那么,你会发现
你会明白的

602
00:30:36,036 --> 00:30:40,005
that's a good start to the implementation of this thing,
这是一个很好的开始实施这个东西,
这是一个好的开始

603
00:30:40,074 --> 00:30:42,841
But before we go into deeper in this implementation,
但是在我们进入更深层次的在这个实现中,
但在我们继续深入之前

604
00:30:42,909 --> 00:30:45,944
let's go back to our controller and use this public
让我们回到我们的控制器,并使用这个公共
我们回到 controller，并使用

605
00:30:46,012 --> 00:30:48,813
API that I just designed, Okay, I wanna use this,
API,我只是设计,好吧,我想用这个,
我们刚刚设计的公开应用程序接口。OK，用这里

606
00:30:48,882 --> 00:30:50,615
So I'm gonna go back to my controller, Now,
所以我要回到我的控制器,现在,
回到 controller

607
00:30:50,684 --> 00:30:53,819
I wanna have my controller and my model on screen on the same
我想有我的控制器和模型在屏幕上的相同
我希望 controller 和 model 并列在屏幕上

608
00:30:53,888 --> 00:30:56,654
time, Just so I can see them side by side, And
时间,这样我可以看到他们肩并肩,和
我可以同时看到它们

609
00:30:56,723 --> 00:30:59,291
the best way to do that is to bring out this assistant
最好的办法,是把这个助理
最好的方式是点一下这个 assistant editor

610
00:30:59,359 --> 00:31:03,094
editor thing again, right? And you can go up to the top,
编辑器的事情,对吧?
然后选择最上方这里

611
00:31:03,163 --> 00:31:06,264
And you can actually manually pick, Or
,或者您可以手动选择
然后手动选择

612
00:31:06,333 --> 00:31:08,866
I'm gonna teach you one little Alt thing,
我要教你一个小Alt的事情,
或者我教你使用 Alt 快捷键

613
00:31:08,935 --> 00:31:14,005
If you hold down Alt and click on some other file over here,
如果你按住Alt和其他一些文件,点击
如果你按住 Alt 键，并点击其它文件

614
00:31:14,074 --> 00:31:15,840
you'll get that to appear on the right,
你会出现在右边,
Assistant Editor 会在右边打开它

615
00:31:15,909 --> 00:31:18,110
So Alt-clicking means bring it up on the right,
所以Alt-clicking意味着把它的权利,
Alt + 点击操作意味着在右边打开它

616
00:31:19,546 --> 00:31:23,348
Okay, so here I have my model on the left,
好吧,我这里有我的模型在左边,
现在左边打开了 model

617
00:31:23,417 --> 00:31:25,651
And here I have my controller on the right,
在这里我有我的控制器在右边,
右边打开了 controller

618
00:31:25,719 --> 00:31:29,821
So what I need to do now is fix this broken code that is
所以我现在需要做的就是解决这个破碎的代码
现在要做的就是修复代码

619
00:31:29,890 --> 00:31:34,726
doing model stuff inside the controller by using the public
做模型通过使用公共控制器内的东西
把一些 controller 的逻辑替换成

620
00:31:34,795 --> 00:31:37,963
API of my model, Now, notice that
我的模型的API,现在,请注意
调用 model 的应用程序接口。这里需要注意

621
00:31:38,032 --> 00:31:41,967
touchDigit does nothing when it comes to calculating,
touchDigit没有计算时,
touchDigit 方法和计算过程无关

622
00:31:42,036 --> 00:31:44,002
All it does is get the digits from the keyboard and
它所做的是把从键盘和数字
它只是把键盘输入的值

623
00:31:44,071 --> 00:31:46,304
put them in the display, It's not doing any calculating, so
把它们放在显示器,它不做任何计算
显示到 display 上，它没有参与任何计算

624
00:31:46,373 --> 00:31:47,639
we don't have to touch that,
我们不需要联系,
所以我们不用管它

625
00:31:47,708 --> 00:31:50,575
Same thing here with this display value computed var,
同样的事情在这个显示值计算var,
这个 displayValue 变量也一样

626
00:31:50,644 --> 00:31:51,843
All it's doing is converting
所有的转换
它只是负责转换类型

627
00:31:51,912 --> 00:31:53,745
the display from a double to a string and
从双弦和显示
把 display 的值类型在浮点类型和字符串类型相互转换

628
00:31:53,814 --> 00:31:54,346
back, That's all it does,
回来,,
它就只做这些

629
00:31:54,414 --> 00:31:56,515
It has nothing to do with being a calculator,
它与一个计算器,
也没有参与到计算过程

630
00:31:56,584 --> 00:31:59,585
That's just the UI for this particular calculator, So
这只是这个计算器的界面,所以
这些都是计算器的用户界面

631
00:31:59,653 --> 00:32:02,154
the only thing we actually have to change is this method,
我们必须改变的唯一的事就是这个方法,
实际上我们只需要改动这个方法

632
00:32:02,223 --> 00:32:07,025
performOperation, Now, we know that this part in here
performOperation中,现在,我们知道,这部分在这里
performOperation。现在，我们知道这部分代码

633
00:32:07,093 --> 00:32:10,229
does not belong in here, And in fact, I'll throw it over
不属于这里,事实上,我将把它结束了吗
其实并不属于这里，我会把它丢到 model 里去

634
00:32:10,297 --> 00:32:12,630
here in my model, Even though it's not gonna work there,
在我的模型,虽然它不会在那里工作,
尽管丢过去之后不能编译

635
00:32:12,699 --> 00:32:15,333
But we'll throw it over there for now just to get it out of
但我们现在把它扔在那里的
但为了规范，还是先把它丢过去再说

636
00:32:15,402 --> 00:32:20,405
the way, okay? So now we need to somehow use this
顺便说一下,好吗?
然后在这方法内部

637
00:32:20,474 --> 00:32:23,241
API over here in this implementation, So,
API在这里在这个实现中,所以,
使用 model 的应用程序接口

638
00:32:23,310 --> 00:32:25,743
let's look at all three parts of what has to do,
让我们看看这三个部分的,
我们需要修改 performOperation 方法

639
00:32:25,812 --> 00:32:28,513
what we have to do in perform operation, First of all,
我们要做的在执行操作中,首先,
的三个地方。第一个

640
00:32:28,582 --> 00:32:30,515
if we're in the middle of typing a number,
如果我们在输入一个数字,
如果输入某个数字的过程中开始计算

641
00:32:30,584 --> 00:32:33,819
we need to set that number as an operand, okay?
我们需要设置这个数字作为操作数,好吗?
必须要把数字存成操作数

642
00:32:33,887 --> 00:32:36,120
Because obviously, the user typing in a number and
因为很明显,用户数量和类型
因为很明显，用户输入一个数字

643
00:32:36,189 --> 00:32:38,857
they perform an operation that number they were typing
他们执行一个操作数类型
然后执行计算，那么输入的数字

644
00:32:38,926 --> 00:32:41,192
needs to be an operand, So, right off the bat here,
需要一个操作数,所以,马上在这里,
肯定是操作数，所以在这里

645
00:32:41,261 --> 00:32:44,996
I'm gonna say, if the user is in the middle of typing,
我想说,如果用户在打字,
我会判断，如果用户在输入过程中计算

646
00:32:45,065 --> 00:32:48,733
then I'm going to set the operand, Now, how do I
然后我要设置操作数,现在,我如何
那么我会把输入的值设置为操作数

647
00:32:48,802 --> 00:32:51,837
communicate to my brain here? Where is my brain? [LAUGH] I
我的大脑在这里交流吗?
那我怎么和 CalculatorBrain 沟通呢？

648
00:32:51,905 --> 00:32:54,806
don't have a var for my brain, So let's create a var, and
没有我的大脑的var,所以让我们创建一个var,
我需要，但又没有 CalculatorBrain 的实例，那就创建一个

649
00:32:54,875 --> 00:32:58,743
it will be private, Because the model is almost always
这将是私人的,因为模型几乎总是
创建一个私有变量。因为在 controller 中，model 几乎

650
00:32:58,812 --> 00:33:01,947
private to the controller, Cuz you don't want someone else
私人的控制器,因为你不想让别人
都是私有的，因为其它地方不会，你也不希望它们用到

651
00:33:02,015 --> 00:33:05,216
reaching in and messing with this controller's model, So
达到在本控制器的模型和干扰,所以
controler 里面的 model 实例

652
00:33:05,285 --> 00:33:06,851
I'm gonna make it a private var,
我将使它成为一个私有变量,
所以定义私有变量

653
00:33:06,920 --> 00:33:11,890
I'm gonna call it brain, Its type is CalculatorBrain, okay?
我要叫它的大脑,它的类型是计算器大脑好吗?
变量名为 brain，类型为 CalculatorBrain

654
00:33:11,958 --> 00:33:14,793
That's good, Now, as soon as I put this line of code in,
这很好,现在,当我把这行代码放进去,
很好，我刚写完这行代码

655
00:33:14,862 --> 00:33:18,297
look what I get, The old, you don't have any initializers,
看看我,旧的,你没有任何初始化,
就提示有错误了：你需要构造器

656
00:33:18,366 --> 00:33:20,732
That's because this is not initialized,
这是因为这不是初始化,
因为这里没有初始化

657
00:33:20,801 --> 00:33:23,802
So I'm gonna initialize it by creating a CalculatorBrain,
所以我要初始化它通过创建一个计算器大脑
这里我通过构造一个 CalculatorBrain 来初始化

658
00:33:23,871 --> 00:33:26,104
And you create a CalculatorBrain in exactly
你创建一个计算器并用
和创建类实例一样

659
00:33:26,173 --> 00:33:29,608
the same way that you create as a class,
同样的方式,您创建一个类,
结构体也需要这么创建

660
00:33:29,677 --> 00:33:32,477
With the name of the type and then the parentheses,
同类型的名称,然后括号,
名字，类型，然后是括号

661
00:33:32,546 --> 00:33:36,080
Now we have no arguments in here, Because we have no
现在我们没有理由在这里,因为我们没有
这里没有参数，因为我们

662
00:33:36,149 --> 00:33:39,384
uninitialized var, Since we made this be an optional,
未初始化的变量,因为我们这是一个可选的,
没有未初始化的变量，因为这里定义为可选的

663
00:33:39,453 --> 00:33:41,987
it's initialized to nil automatically for us for free,
这是免费为我们自动初始化为零,
它默认会自动初始化为 nil

664
00:33:42,056 --> 00:33:44,389
remember? So we have no uninitialized vars, so
还记得吗?
所以我们没有未初始化的变量

665
00:33:44,458 --> 00:33:46,858
we just do open parentheses, closed parentheses, And
我们只做开括号,括号,关闭,
我们只需要左括号，右括号

666
00:33:46,927 --> 00:33:49,895
of course, we don't need this type, right?
当然,我们不需要这种类型,对吗?
当然，这个类型也可以去掉

667
00:33:49,963 --> 00:33:54,099
Because it gets inferred, So if we ask what type is this?
因为它被推断,所以如果我们问这是什么类型?
因为代码会自动推断类型。如果问这是什么类型？

668
00:33:54,167 --> 00:33:56,735
It says, that's a calculator brain, Has to be cuz that's
它说,这是一个计算器,因为这是
代码会自动推断出是 CalculatorBrain 类型

669
00:33:56,804 --> 00:34:00,272
what you set it to, All right, so now that we have a model,
你设置它,好吧,现在我们有一个模型,
现在在 controller 中已经实例化了 model

670
00:34:00,341 --> 00:34:03,408
our controller, This is the green arrow, talking from our
我们的控制器,这是绿色箭头,从我们的谈话
这是绿色通道，连通

671
00:34:03,476 --> 00:34:07,212
controller to the model, We can say, brain set your
控制器模型,我们可以说,大脑设置
controller 和 model。我们可以这样来使用

672
00:34:07,281 --> 00:34:11,616
operand to be whatever the display value is, And
操作数是无论显示值,
brain.setOperand(displayValue)

673
00:34:11,685 --> 00:34:14,452
of course now we are not in the middle of typing, so I'll
当然现在我们不是在打字,所以我
当然，用户已经没有在输入某个数字了

674
00:34:14,521 --> 00:34:17,989
put that in here, So that's all we need to do to set
把它放在这里,这是我们需要做的
把这一行移上来。这就是设置

675
00:34:18,058 --> 00:34:20,492
the brain's operand, We only need to do if these are in
大脑的操作数,我们只需要做这些
brain 操作数的步骤。只需要判断用户

676
00:34:20,560 --> 00:34:21,860
the middle of typing something new,
输入新的东西,
是不是正在输入一个新值

677
00:34:21,929 --> 00:34:23,095
and they hit an operation button,
他们打了一个操作按钮,
然后点击的运算符按钮

678
00:34:23,164 --> 00:34:26,031
We need to give them that operand, okay?
我们需要给他们操作,好吗?
是我们就设置操作数为输入的值

679
00:34:26,099 --> 00:34:28,433
Now, what about the stuff that was in here, okay?
现在,这里的东西是什么,好吗?
这一块怎么处理呢？

680
00:34:28,502 --> 00:34:30,935
We get this mathematical symbol of the operation to do,
我们得到了这个数学符号的操作,
我们获取到了计算运算符号

681
00:34:31,004 --> 00:34:32,471
Now I'm just gonna let the brain do it,
现在我要让大脑,
我需要通知 brain

682
00:34:32,540 --> 00:34:35,107
So I'm just gonna say brain perform operation,
所以我想说大脑执行运算,
我只需要输入

683
00:34:35,175 --> 00:34:37,942
the mathematical symbol, That's it,
数学符号,就是这样,
brain.performOperation(mathematicalSymbol)

684
00:34:38,011 --> 00:34:40,745
I'm just handing that off to the model, Because that's,
我只是把这交给模型,因为这是,
我把这些都交给 model

685
00:34:40,814 --> 00:34:44,115
this is not my job as a controller to do calculation,
这不是我的工作作为一个控制器进行计算,
因为计算不是 controller 的工作

686
00:34:44,184 --> 00:34:45,718
Okay I'm a UI guy,
好吧我一个UI的家伙,
controller 属于用户界面

687
00:34:47,054 --> 00:34:49,954
Now of course after the operation is done I need to
手术后当然是我需要完成的
在操作过后，我需要设置

688
00:34:50,023 --> 00:34:55,427
set my display value equal to the brain's result,
设置我的显示值等于大脑的结果,
displayValue 等于 brain.result

689
00:34:55,495 --> 00:34:58,730
But of course I can't do this because displayValue
当然,我不能这么做,因为displayValue
但我不能这么写，因为 displayValue

690
00:34:58,799 --> 00:35:02,801
is a double, And the result, might be
是一个双,结果,可能吗
类型是浮点，但 brain.result

691
00:35:02,870 --> 00:35:05,837
not set cuz it's an optional, So I'm gonna say here,
不是因为它是一个可选的,所以我要在这里说,
是可选类型，可能缺省值。所以这里需要写

692
00:35:05,906 --> 00:35:08,173
if I can let the result equal the brain to results,
如果我可以让结果等于大脑的结果,
如果我可以让 result 等于 brain.result

693
00:35:08,242 --> 00:35:12,443
In other words, if the brain's result is determined, Then I
换句话说,如果大脑的结果确定,然后我
换句话说，如果 brain.result 是有值的

694
00:35:12,512 --> 00:35:17,983
will let the displayValue equal the result, That's it,
会让displayValue平等的结果,就是这样,
那么 displayValue 就等于这个值

695
00:35:18,052 --> 00:35:21,787
Okay, so that little piece of code to input has completely
好了,这小段代码输入完全
OK，这一小段代码就可以把

696
00:35:21,855 --> 00:35:24,823
taken all calculation out of the controller,
控制器的所有计算,
把计算模块分出去

697
00:35:24,891 --> 00:35:26,725
And put you into this other camp the model,
把你变成另一阵营模型,
全权交给 model 处理

698
00:35:26,794 --> 00:35:29,294
And now we can spend the rest of this lecture making this
现在我们可以度过余生的这节课做这个
剩下的时间我们都会构建这个

699
00:35:29,362 --> 00:35:30,695
really powerful model,
真正强大的模型,
强大的 model

700
00:35:30,764 --> 00:35:32,397
And nothing is gonna change over here,
什么也不会改变,
这边不会再有任何修改

701
00:35:32,466 --> 00:35:37,035
I'm literally never gonna edit this code ever again, In fact,
我真的不会再编辑这个代码,事实上,
我基本上不会再修改这里的代码

702
00:35:37,104 --> 00:35:38,470
I'm just gonna get it off the screen, And
我要让它从屏幕上消失,和
事实上我会隐藏它

703
00:35:38,538 --> 00:35:42,674
we're gonna spend all of our time over here in the model,
我们会花费我们所有的时间在模型中,
我们把时间都花在 model 上

704
00:35:42,743 --> 00:35:45,510
So, let's start by making kind of a really dirt simple
所以,让我们开始通过一种真正肮脏的简单
我们先简单处理下

705
00:35:45,579 --> 00:35:48,213
implementation of performOperation here, Which
实现performOperation中,
实现 performOperation

706
00:35:48,282 --> 00:35:51,483
is try to get this code that was already there to work,
把这段代码,已经工作,
让这些代码通过编译就行

707
00:35:51,551 --> 00:35:53,785
And mostly, that's just a matter of changing the names,
主要是,这只是一种改变名称,
首先，需要修改名字

708
00:35:53,854 --> 00:35:55,520
Because this argument is symbol,
因为这个论点是符号,
因为参数名是 symbol

709
00:35:55,589 --> 00:35:58,056
not mathematical symbol, So, we'll do that,
没有数学符号,因此,我们将这样做,
不是 mathematicalSymbol

710
00:35:58,125 --> 00:36:00,658
And instead of setting a display value cuz we're not in
而不是设置显示值因为我们不是
然后替换 displayValue

711
00:36:00,727 --> 00:36:01,560
a UI any more,
UI,
因为已经不再处理用户界面了

712
00:36:01,628 --> 00:36:04,462
Now we're just setting the accumulator to that double pi,
现在我们只是设置蓄电池双π,
现在要设置 accumulator 等于 pi

713
00:36:04,531 --> 00:36:07,365
Right, and the same thing here we're setting the accumulator
对的,同样的事我们设置蓄电池
同样，这里也需要设置 accumulator

714
00:36:07,434 --> 00:36:11,270
to be the square root of the accumulator, Okay,
蓄电池的平方根,好吧,
等于根号 accumulator

715
00:36:11,338 --> 00:36:12,604
now this is a problem right here,
现在这是一个问题,
又报错了

716
00:36:12,672 --> 00:36:16,441
This line, why? Accumulator is an optional,
这条线,为什么?
这里是为什么出错呢？accumulator 是可选类型

717
00:36:16,510 --> 00:36:20,479
You can't take the square root of an optional, So I could say
你不能把一个可选的平方根,所以我可以说
你不能对一个可选类型开根号

718
00:36:20,547 --> 00:36:24,082
for example, if let operand equal the accumulator,
例如,如果我们操作数等于蓄电池,
我会写，如果让 operand 等于 accumulator

719
00:36:24,151 --> 00:36:29,054
So if my accumulator is set, then I can tap the accumulator
如果我蓄电池组,那么我可以利用蓄电池
也就是如果 accumulator 有值，我再让 accumulator

720
00:36:29,123 --> 00:36:33,024
be the square root of the operand, okay? Now,
操作数的平方根,好吗?
等于操作数的平方根

721
00:36:33,093 --> 00:36:35,427
we have another warning right here on both of these lines,
我们这里有另一个警告这两种线,
这两行还有另外的错误

722
00:36:35,496 --> 00:36:40,398
Why do you think, does anyone know why this is? We seen it
你为什么认为,有人知道这是为什么吗?
谁知道为什么吗？

723
00:36:40,467 --> 00:36:46,004
before, five minutes ago, This
五分钟前,这个
我们5分钟前遇到过的

724
00:36:46,073 --> 00:36:49,708
modifies this CalculatorBrain, So this method,
修改这个计算器并用,所以这种方法,
这里修改了 CalculatorBrain 的私有变量

725
00:36:49,777 --> 00:36:53,478
perfomOperation, also needs mutating in front of it,
perfomOperation,也需要变异在它面前,
所以 perfomOperation 方法需要增加 mutating 关键字

726
00:36:53,547 --> 00:36:55,881
okay? So I'll fix that, add mutating,
好吧?
加上就好了，不报错了

727
00:36:58,184 --> 00:37:00,018
Adding this mutating takes a little bit getting used to,
添加这个变异需要有点适应,
你有时候可能会忘记添加 mutating 关键字

728
00:37:00,086 --> 00:37:03,054
But it's great because its compiler notices it, And it's
但它是伟大的,因为它的编译器通知它,和它
但没关系，因为编译器会提醒你

729
00:37:03,123 --> 00:37:08,126
gonna always be reminding you to do that, So believe it or
要总是提醒你,所以相信它或
它一定会提醒你添加

730
00:37:08,195 --> 00:37:11,964
not we now have an MVC version of this calculator and if we
我们现在没有这个计算器,如果我们的MVC版本
OK，不管你信不信，MVC 版的计算器已经写完了

731
00:37:12,032 --> 00:37:21,707
run it should just work, All right,
运行它应该工作,好吧,
如果你运行它，它肯定会工作的

732
00:37:21,775 --> 00:37:24,109
here we go, Let's see, 7, 8, that's still working,
好了,让我们看看,7,8,这仍然是工作,
我们来试试，7，8

733
00:37:24,177 --> 00:37:26,712
Okay, that was in the controller, Pi, woah,
好吧,那是在控制器,π,哇,
controller 部分正常。试试 pi

734
00:37:26,780 --> 00:37:29,347
that's working, It's going off to the model,
这就是工作,去模型,
正常工作着，值传递给 model 了

735
00:37:29,416 --> 00:37:32,517
And this is actually executing, And it's causing
这实际上是执行,导致
实际执行的是这一行

736
00:37:32,586 --> 00:37:36,521
the accumulator to get set to that double pi, And
双π的蓄电池组,和
把 accumulator 设置成 pi 的值

737
00:37:36,590 --> 00:37:40,125
then flicking at the result and putting it in display, How
然后移动在显示结果,并把它,如何做
然后把结果显示到 display 上

738
00:37:40,193 --> 00:37:44,896
about 81 square root, square root? All right, excellent,
约81根,根?
那么81开根，再开根呢？好的，没错

739
00:37:44,965 --> 00:37:47,532
okay, So now we're starting in a place where exactly where we
好,现在我们开始在哪里我们的地方
我们代码恢复到了之前的可用状态

740
00:37:47,601 --> 00:37:50,969
were before, But we split off all of our calculating code
之前,但我们分裂我们所有的计算代码
并且我们把负责计算的代码分离出到

741
00:37:51,037 --> 00:37:54,640
into this little class right here, So this is
到这个小类,这是
这里的一小块

742
00:37:54,708 --> 00:37:57,408
a great opportunity now to enhance this to the max,
现在一个很好的机会来提高最大,
这是我们优化这部分代码的好机会

743
00:37:57,477 --> 00:38:00,512
So we are gonna use all kinds of cool, Swift stuff that you
所以我们会用各种各样的酷,迅速的东西
我们将会使用一些你从没见过的

744
00:38:00,581 --> 00:38:02,814
probably did not see in other languages,
可能没有看到在其他语言中,
Swift 语言仅有的特性

745
00:38:02,883 --> 00:38:06,385
To make this a much more extensible calculator,
使它更可扩展计算器,
让这个计算器更容易扩展

746
00:38:06,453 --> 00:38:09,454
Cuz right now, man, if I wanna add more operations,
因为现在的人,如果我想添加更多的业务,
因为现在，如果我们要增加运算符

747
00:38:09,523 --> 00:38:12,223
I just get this huge switch statement case, this case,
我刚刚得到这个巨大的switch语句的情况下,这种情况下,
我需要增加 switch 代码块，添加 case 声明

748
00:38:12,292 --> 00:38:15,160
that case, I'm gonna have to do if let operand equals
这种情况下,我要做的,如果我们操作数=
而且每次我都必须要添加判断

749
00:38:15,229 --> 00:38:16,761
accumulator every single time,
蓄电池每一次,
如果常量 operand 等于 accumulator 之类的

750
00:38:16,830 --> 00:38:20,866
For the things that are unary operations like square root,
的东西一元操作,比如平方根,
而且这些只是想平方根之类的一元计算

751
00:38:20,934 --> 00:38:23,569
Imagine when I have the binary case like five times three
想象当我有二进制情况下三个五倍
想象下，如果我有二元操作，像“5 x 3 =”

752
00:38:23,637 --> 00:38:26,371
equals, I'm gonna have to do the figuring out how to deal
=,我要如何交易
我需要考虑怎么处理

753
00:38:26,440 --> 00:38:28,973
with the times and the equals for every single case,
随着时代和等于每一个情况下,
单个计算中出现的乘称号和等于号

754
00:38:29,042 --> 00:38:32,110
Forget it, I can't do that, I need to build an engine here,
忘记,我做不到,我需要构建一个引擎,
算了，想都别想。我需要的是构造一个计算引擎

755
00:38:32,179 --> 00:38:33,545
That can deal with constants,
能够处理常量,
既可以处理常量

756
00:38:33,614 --> 00:38:35,880
That can deal with these unary operations like square root,
能够处理这些一元操作,比如平方根,
又可以处理像开根号之类的一元计算

757
00:38:35,949 --> 00:38:39,150
That can deal with binary operations like multiply and
能够处理二进制乘法和这样的操作
还可以处理像加减之类的

758
00:38:39,219 --> 00:38:42,053
plus and things like that, Okay? So that's exactly what
+之类的东西,好吗?
二元计算。这是

759
00:38:42,122 --> 00:38:44,389
we're going to do, We're going to enhance this model, Now,
我们要做的,我们要提高这个模型中,现在,
接下来要做的。我们继续优化我们的 model

760
00:38:44,458 --> 00:38:47,592
as we do all this enhancement, we're not going to change it
当我们完成这些增强,我们不会改变它
所有的优化，都不会影响外部

761
00:38:47,661 --> 00:38:50,061
externally at all, And so the controller will not change,
外部,因此控制器不会改变,
调用，controller 不需要任何修改

762
00:38:50,130 --> 00:38:51,930
That's what's really cool about this, We can do our
这是很酷的,我们可以做我们的
这是非常酷的

763
00:38:51,999 --> 00:38:53,898
model development independent of our UI,
模型开发独立于我们的UI,
在把用户界面的功能基本完成之后

764
00:38:53,967 --> 00:38:57,603
Once we have the UI, that kind of does the basics, all right,
一旦我们有了UI,这种最基本的,好吧,
就可以脱离 UI 只修改 model 的内部实现了

765
00:38:57,671 --> 00:39:00,638
So what are we going to do here? Let's focus first,
所以我们要做什么呢?
接下来我们要做什么呢？我们看这里

766
00:39:00,707 --> 00:39:02,774
Let's get rid of this code, cuz we know that's a mess,
让我们摆脱这段代码,因为我们知道这是一团糟,
我们先去掉这些代码，因为这写得不好

767
00:39:02,843 --> 00:39:06,144
We're not going to do that, Let's focus on constants,
我们不会这样做,让我们关注常数,
我们换种方式。先看看常数

768
00:39:06,213 --> 00:39:10,315
Wouldn't it be kind of cool if I could like, build a table,
岂不是很酷的如果我可以喜欢,建立一个表,
有没有其它更好的方式来实现呢？比如用某种参照表？

769
00:39:10,384 --> 00:39:12,951
Okay, I'll do square brackets to hold my table, And
好吧,我做的方括号握住我的表,和
OK，我用中括号定义表格

770
00:39:13,020 --> 00:39:18,623
in this table, I had, like pi and double dot pi, And then,
在这个表中,我,像π和二阶导数π,然后,
在表格里，我定义 "pi" : Double.pi

771
00:39:18,692 --> 00:39:22,060
maybe I had e's does everyone know what the constant e is,
也许我已经e的大家都知道常数e是什么,
然后，应该还有常数 e，

772
00:39:22,129 --> 00:39:24,262
Mathematic 2,71 one something,
数学71一个东西,
一个无理数，约等于 2.71

773
00:39:24,331 --> 00:39:25,397
We have a nice symbol for
我们有一个很好的象征
Swift 有专门的符号来表示它

774
00:39:25,465 --> 00:39:28,233
that and not quite as nice as Double,pi, But it's called
和不太好双,π,但是它叫
但不像 Double.pi 那么优雅

775
00:39:28,301 --> 00:39:33,005
M under bar E, So, and I put all my constants in a table,
M E在酒吧,所以,我把我所有的常量放在一个表,
它叫 M_E。好了，假设我把需要的常量都放在表格里了

776
00:39:33,073 --> 00:39:35,040
And then here in performOperation,
然后在performOperation中,
然后在 performOperation 方法里

777
00:39:35,109 --> 00:39:37,576
I'll just look up the symbol in that table and
我会查找表和象征
我只需要在表格中查找符号

778
00:39:37,644 --> 00:39:40,245
get the value, Wouldn't that be a lot more extensible for
得到的值,不会,更可扩展
找到对应的值。这是不是更具有可扩展性？

779
00:39:40,313 --> 00:39:42,514
constants? Right, I could add all the constants I want,
常量?
我可以加入任何我想要的常量

780
00:39:42,582 --> 00:39:45,350
I just, one line of code each, That would be a lot better
每一行代码,我就会好很多
一行一个，这肯定会比

781
00:39:45,419 --> 00:39:48,253
than putting extra case this blah blah blah, Okay, so
比把额外的情况下等等,所以
很多很多个 switch 的 case 要好

782
00:39:48,322 --> 00:39:50,822
how can we do that? We need to create a table,
我们该怎么做?
OK，那我们怎样实现呢？首先要创建一个表格

783
00:39:50,891 --> 00:39:52,891
So how do we create a table in Swift?
那么,我们如何在迅速创建一个表吗?
那 Swift 怎么创建一个表格呢？

784
00:39:52,959 --> 00:39:56,995
We use the struct called dictionary, okay? So
我们使用结构体被称为字典,好吗?
Swift 有个结构体，叫 Dictionary（字典）

785
00:39:57,064 --> 00:39:59,865
dictionary is how you create a hash table of things, And so
字典是如何创建一个哈希表的事情,所以
字典是你创建哈希表的方法

786
00:39:59,934 --> 00:40:03,401
I'm gonna create a private var,
我要创建一个私有变量,
我定义一个私有变量

787
00:40:03,470 --> 00:40:05,870
I'm gonna call it, I could call it Constants, but
我要叫它,我可以称它为常数,但是
名字可以叫 Constants

788
00:40:05,939 --> 00:40:08,506
I'm gonna call it operations cuz I'm basically, eventually
我要叫它操作因为我基本上,最终
但我叫它 operations

789
00:40:08,575 --> 00:40:12,143
going to enhance it to work for all of our operations,
要提高我们所有的业务工作,
因为它最终会适用于我们所有的运算

790
00:40:12,212 --> 00:40:16,147
And it's gonna be of type Dictionary, Now Dictionary,
要类型的字典,字典,
类型是 Dictionary

791
00:40:16,216 --> 00:40:18,716
you're gonna see a new feature in Swift right here, It, this,
你会看到斯威夫特中的一个新特性,它,,
你所见到的又一个 Swift 语言的特性

792
00:40:18,785 --> 00:40:22,554
you have this feature in Java, as well, It is a generic type,
你有这个特性在Java中,这是一个泛型类型,
你可能在 Java 中也见过，泛型

793
00:40:22,623 --> 00:40:25,157
So a dictionary, it can be a dictionary that goes from
所以一本字典,它可以从一个字典
字典，可以由几乎任何

794
00:40:25,226 --> 00:40:28,460
almost any kind of key to almost any kind of value,
几乎任何一种几乎任何一种价值的关键,
键值对组成

795
00:40:28,528 --> 00:40:30,995
Okay, the key has to implement a certain protocol,
好的,关键要实现一个特定的协议,
但键必须遵循某个协议

796
00:40:31,064 --> 00:40:32,797
It basically has to be hashable, Okay,
它基本上是hashable,好吧,
它基本上必须是 Hashable，具有哈希性

797
00:40:32,866 --> 00:40:35,534
so as long as it's hashable, then it can be a key and
只要hashable,然后它可以是一个关键
所以只要是具有哈希性，就可以成为键

798
00:40:35,603 --> 00:40:38,336
then the value can be any type, So you specify that,
值可以是任何类型,所以你指定,
值可以是任何类型。所以你需要指定类型

799
00:40:38,405 --> 00:40:40,339
same as in Java, the key type,
在Java中,密钥类型相同,
和 Java 一样，指定键的类型

800
00:40:40,407 --> 00:40:42,975
So I'm gonna have my key be a string like pi or e,
所以我要有我的钥匙是一个字符串像π或e,

801
00:40:43,043 --> 00:40:46,477
And then the value is going to be a double,
然后是一个双重的价值,

802
00:40:46,546 --> 00:40:50,982
like Double,pi here, or _E, okay? And believe it or
像双,π或_E,好吗?

803
00:40:51,051 --> 00:40:54,019
not, I can actually say equals this syntax and
不是,我可以等于这个语法和说

804
00:40:54,088 --> 00:40:57,822
it will create one for me with that step in there, okay? So
它将创建一个与这一步对我来说,好吗?

805
00:40:57,891 --> 00:41:00,693
open square bracket, key colon value comma key colon value,
开放的方括号,键值逗号键结肠值,

806
00:41:02,029 --> 00:41:04,696
that's how you can put a dictionary,
你可以把字典,

807
00:41:04,765 --> 00:41:06,798
Now of course, you can add things to a dictionary and
当然,您可以添加字典和

808
00:41:06,867 --> 00:41:08,367
remove things, and get things out of dictionary,
删除的东西,把事情的字典,

809
00:41:08,435 --> 00:41:09,934
I'll show you that in a second, But
我将向您展示,但是

810
00:41:10,003 --> 00:41:13,304
this is a nice way to do this, So
这是一个不错的方法,所以

811
00:41:13,373 --> 00:41:17,843
let's do that, Okay, so we have this nice dictionary,
做一下,好吧,我们有这个很好的字典,

812
00:41:17,912 --> 00:41:20,011
So now we could use this dictionary of operations and
现在我们可以使用这个字典的操作

813
00:41:20,080 --> 00:41:21,714
performOperation, I'm gonna say,
performOperation中,我会说,

814
00:41:23,316 --> 00:41:30,054
if I can let the constant that I want equal the operation
如果我可以让常数相等操作

815
00:41:30,123 --> 00:41:35,293
that matches that symbol then, now why am I doing if let here
相匹配的象征,现在如果让我做这里的原因

816
00:41:35,362 --> 00:41:40,265
for operations sub-symbol? This operation sub-symbol,
操作次符号?

817
00:41:40,334 --> 00:41:44,002
that's how you look up a symbol in a dictionary, right?
这就是你在字典中查找一个符号,对吧?

818
00:41:44,071 --> 00:41:46,437
Operation to the dictionary, click on it, right?
操作字典,点击它,对吧?

819
00:41:46,506 --> 00:41:49,574
To dictionary, strings and doubles, So you look it up,
字典,字符串和双打,所以你查一下,

820
00:41:49,643 --> 00:41:52,444
When you look it up, it returns an optional of
当你看到它的时候,它返回一个可选的

821
00:41:52,512 --> 00:41:55,980
the value, Why, anyone think why it would do that?
价值,为什么,有人认为它为什么会这么做?

822
00:41:56,049 --> 00:41:56,948
>> It might not be there,
> >这可能不是,

823
00:41:57,017 --> 00:41:58,149
>> Exactly, it might not be in
> >,也许不是

824
00:41:58,218 --> 00:42:01,353
the table, Okay, what if I say operations sub X,
桌上,好吧,如果我说什么操作,

825
00:42:01,422 --> 00:42:04,522
that's gonna return not set, because there's no
会返回没有设置,因为没有

826
00:42:04,591 --> 00:42:08,126
X in this table, Only pi and e are in there, okay? So that's
X在这个表中,只有π和e在那里,好吗?

827
00:42:08,195 --> 00:42:11,163
why I have to do if let there, and if the constant is there,
为什么我要做如果让,如果不变,

828
00:42:11,232 --> 00:42:13,865
now I can set my accumulator equal to that constant,
现在我可以设置蓄电池等于常数,

829
00:42:13,934 --> 00:42:17,135
okay? Because this constant is gonna be a Double, because
好吧?

830
00:42:17,204 --> 00:42:21,239
this is a Dictionary that has Doubles as its values, okay?
这是一本字典,双打作为它的值,对吧?

831
00:42:21,308 --> 00:42:22,140
That's cool, Let's go ahead,
那很酷,让我们继续,

832
00:42:22,209 --> 00:42:23,909
Let's run it, That's all we need to do, So
让我们运行它,这就是我们需要做的,所以

833
00:42:23,978 --> 00:42:27,579
now we've built, for constants only, a much more extensible
现在我们已经建成,为常数,更可扩展的

834
00:42:27,648 --> 00:42:30,983
internal architecture here, to our calculator brain,
内部架构,我们的计算器大脑,

835
00:42:31,051 --> 00:42:33,384
So of course, square root's not gonna work, okay,
当然,平方根不会工作,好吧,

836
00:42:33,453 --> 00:42:38,123
but pi works, and if I add an e button, it would do e, Okay,
但π,如果我添加一个按钮,它会做e,好吧,

837
00:42:38,192 --> 00:42:40,658
everybody cool with what I did there? But
每个人都明白我所做的吗?

838
00:42:40,727 --> 00:42:44,363
of course, that's kind of useless just for constants,
当然,这是一种无用的常数,

839
00:42:44,431 --> 00:42:48,066
We wanna be something like this, watch this, Quote,
我们想要这样的,看这个报价,

840
00:42:48,135 --> 00:42:51,770
do my Emoji & Symbols here,
做我Emoji &符号,

841
00:42:51,839 --> 00:42:55,106
There's our square root, square root colon,
这就是我们的根,根结肠,

842
00:42:55,175 --> 00:43:00,913
what do we wanna put over here? How about square root?
我们想把这里的什么?

843
00:43:00,981 --> 00:43:05,217
Okay, and maybe a cosine, Put cosine there,
好吧,也许一个余弦,余弦,

844
00:43:05,286 --> 00:43:09,121
And wouldn't that be cool if we could do that, okay?
不会,很酷如果我们能这样做,好吗?

845
00:43:09,189 --> 00:43:10,922
Because now we'd really have an extensible table,
因为现在我们真的有一个可扩展的表,

846
00:43:10,991 --> 00:43:14,492
it can do constant and also can do these unary functions,
它可以不变,也可以做这些一元函数,

847
00:43:14,561 --> 00:43:17,696
But we got a problem here, because square root is most
但我们有一个问题,因为最平方根

848
00:43:17,765 --> 00:43:21,900
definitely not a Double, right? Square root
肯定不是一个双,对吗?

849
00:43:21,969 --> 00:43:25,337
is like a function, so that's no good, So we're gonna,
就像一个函数,这是不好,所以我们要,

850
00:43:25,406 --> 00:43:28,674
if we wanna have a dictionary that has mixed things in it,
如果我们想要有一个字典,复杂的东西,

851
00:43:28,742 --> 00:43:31,577
we need to create a type here that represents those
我们需要创建一个代表这些类型

852
00:43:31,645 --> 00:43:34,112
mixed things, So that's what we're gonna do, we're gonna
混合的东西,这就是我们要做的,我们会

853
00:43:34,181 --> 00:43:37,315
create a new type, okay? This is gonna have a data type that
创建一个新类型,好吗?

854
00:43:37,384 --> 00:43:39,784
you're gonna be somewhat used to, to other languages, but
你要多少,其他语言,但是

855
00:43:39,853 --> 00:43:42,287
you're gonna see it much more powerful in Swift,
你会看到它在迅速更强大,

856
00:43:42,356 --> 00:43:46,058
I'm gonna make it a private type that's embedded inside my
我将使它成为一个私人嵌入我的类型

857
00:43:46,126 --> 00:43:49,127
CalculatorBrain, so you can have types within types and
的计算器大脑,所以你可以在类型和类型

858
00:43:49,196 --> 00:43:51,563
it's just a scoping issue, that's just a naming issue,
这只是一个范围的问题,这只是一个命名问题,

859
00:43:51,632 --> 00:43:54,165
okay? The name of this is gonna be CalculatorBrain,
好吧?

860
00:43:54,234 --> 00:43:57,368
the dot, what I call it here, And it's not gonna be a struct
点,我叫它,它不会是一个结构体

861
00:43:57,437 --> 00:44:01,940
or a class, it's gonna be an enum, Does everyone
或一个类,它会是一个枚举,每一个人

862
00:44:02,009 --> 00:44:04,943
know what an enum is in other classes? It's basically a data
知道什么是enum在其他类?

863
00:44:05,012 --> 00:44:07,646
structure that has discrete values, Right,
结构的离散值,

864
00:44:07,714 --> 00:44:10,015
it can only be one, like case this, case that, whatever,
情况下一样,它只能是一个,无论如何,

865
00:44:10,084 --> 00:44:11,950
It can only be one of a discrete value and
它只能被一个离散值和之一

866
00:44:12,019 --> 00:44:15,653
the same thing here in Swift, I'm gonna call it Operation,
同样的事情在斯威夫特,我会叫它操作,

867
00:44:15,722 --> 00:44:18,456
and it's gonna have case constant and
会有常数,

868
00:44:18,525 --> 00:44:22,994
case unaryOperation, So those are the two kinds of things,
unaryOperation,这是两种东西,

869
00:44:23,063 --> 00:44:26,798
And then I'm gonna make this Dictionary return an Operation
然后我把这本字典返回一个操作

870
00:44:26,867 --> 00:44:31,370
instead of a Double, Okay, so that means I have change all
而不是双,好了,这意味着我已经改变

871
00:44:31,438 --> 00:44:34,772
of these, to say Operation,constant, because
可以说,这些操作,常数,因为

872
00:44:34,841 --> 00:44:39,044
this is a constant, We'll just comment that out for a second,
这是一个常数,我们就评论说第二个,

873
00:44:39,112 --> 00:44:42,147
And then this is also an Operation,constant,
这也是一个操作,常数,

874
00:44:42,215 --> 00:44:46,384
This one will be an Operation,unaryOperation,
这将是一个操作,unaryOperation,

875
00:44:46,453 --> 00:44:49,854
I can just call that Operation,unary,
我可以称之为操作,一元,

876
00:44:49,923 --> 00:44:51,289
We'll say unary operation,
我们会说一元运算,

877
00:44:51,358 --> 00:44:55,160
Operation,unaryOperation, okay?
操作,unaryOperation,好吗?

878
00:44:55,228 --> 00:44:58,763
Cool! Okay, we can't do this anymore, of course, cuz now
太酷了!

879
00:44:58,832 --> 00:45:01,299
it's not a constant that we're pulling out of there,
这不是一个常数,我们退出,

880
00:45:01,368 --> 00:45:05,237
It's actually an operation, okay? And obviously,
它实际上是一个操作,好吗?

881
00:45:05,305 --> 00:45:08,439
we can't do that because this constant here,
我们不能这样做,因为这个常数,

882
00:45:08,508 --> 00:45:12,277
is now an operation not a double, So we can't say that
现在手术不是一个双,所以我们不能说

883
00:45:12,346 --> 00:45:16,582
equals that, okay? So this is good, This is getting better,
=,好吗?

884
00:45:16,650 --> 00:45:19,084
We've got our table to be able to have both things, But
我们有我们的桌子能够都东西,但是

885
00:45:19,153 --> 00:45:22,954
in doing this, I've lost the fundamental meaning
在做这个,我已经失去了最根本的意义

886
00:45:23,023 --> 00:45:25,757
of all of these things, I commented it out, So
所有的这些事情,我说出来,所以

887
00:45:25,826 --> 00:45:29,227
now this table is kind of useless, right?
这表是一种无用的,对吧?

888
00:45:29,296 --> 00:45:30,929
It knows that pi is a constant,
它知道π是一个常数,

889
00:45:30,998 --> 00:45:33,631
It knows that square root is a unary operation,
它知道平方根是一元运算,

890
00:45:33,700 --> 00:45:36,668
But it's so what? Because we can't do any of them, And
但那又怎样?

891
00:45:36,737 --> 00:45:40,773
this is where, something you've heard of before,
在这里,你以前听说过的东西,

892
00:45:40,841 --> 00:45:44,242
associated values comes in, Remember optional has
关联值,记得可选

893
00:45:44,311 --> 00:45:46,845
this thing where when it's in the set stage it has this
这个东西当它在设置阶段

894
00:45:46,914 --> 00:45:49,681
associated value that's associated with the set state,
相关值相关的设置状态,

895
00:45:49,750 --> 00:45:54,953
but is not associated with the not set state? Okay, optional
但不是没有设置相关的国家吗?

896
00:45:55,022 --> 00:45:59,925
is an enum, It's an enum with two cases, The not set case,
enum,enum和两个情况下,没有设置的情况下,

897
00:45:59,994 --> 00:46:03,094
which is called none and the set case, which is called sum,
叫做没有设置情况,叫做,

898
00:46:03,163 --> 00:46:06,398
And in the sum case, it has a little associated value with
在的情况下,它有一个小值有关

899
00:46:06,467 --> 00:46:10,034
it, And we can do the exact same thing, okay? In our enum,
它,我们可以做相同的事情,好吗?

900
00:46:10,103 --> 00:46:13,739
when the case is a constant, we can have an associated
情况下是一个常数,我们可以有一个相关的

901
00:46:13,807 --> 00:46:16,441
Double, And that's, we just put it right there and
双,,我们只是把它放在那里

902
00:46:16,510 --> 00:46:19,344
we can actually could have multiple associated values,
我们可以可以有多个相关的值,

903
00:46:19,413 --> 00:46:21,880
We only need one for constants, But we can have
我们只需要一个常数,但我们可以有

904
00:46:21,949 --> 00:46:25,550
this associated value, Okay, so associated values
这个值有关,所以相关的值

905
00:46:25,619 --> 00:46:28,587
are something not specific to optionals, It's for
可选的是不特定的,是吗

906
00:46:28,656 --> 00:46:33,525
all enums in Swift, So this is super powerful because now
所有枚举迅速,这是超级强大的因为现在

907
00:46:33,593 --> 00:46:37,295
when I add a constant into this table, for example,
当我向表添加一个常数,例如,

908
00:46:37,364 --> 00:46:41,699
I can just associate Double,pi with it,
我可以将翻倍,π,

909
00:46:41,768 --> 00:46:47,205
Same thing with this constant, I'll just associate the value
这个常数也是一样,我就把价值

910
00:46:47,274 --> 00:46:50,575
of e with it, Okay, now we'll get to these ones in a second,
e的,好的,现在我们会得到这些的,

911
00:46:50,644 --> 00:46:53,111
A little more complicated there, All right, so
有点复杂,所以

912
00:46:53,180 --> 00:46:56,314
now I've got a table with got constants in there and
现在我有一个表有常数和

913
00:46:56,383 --> 00:46:57,649
I actually know the values,
其实我知道的值,

914
00:46:57,718 --> 00:47:00,685
So down here, when I get the operation out of here, right,
所以在这里,当我得到操作离开这里,对了,

915
00:47:00,754 --> 00:47:02,187
this is a type Operation,
这是一个类型的操作,

916
00:47:02,255 --> 00:47:06,057
it's one of these enums, How do I look at each of these,
这是其中的一个枚举,我怎么看这些,

917
00:47:06,126 --> 00:47:09,428
and like get this associated value? Well, how would you
就像这个关联值吗?

918
00:47:09,496 --> 00:47:11,796
look at the values of an enum in another language?
看一个枚举的值在另一种语言?

919
00:47:11,865 --> 00:47:14,265
You would probably switch on them, So
你可能会打开他们

920
00:47:14,334 --> 00:47:16,268
I'm gonna switch on this operation and
我要打开这个操作

921
00:47:16,336 --> 00:47:20,939
I'm gonna do a case for when it's a constant, And
我要做的,当它是一个常数,和

922
00:47:21,008 --> 00:47:25,444
I'm gonna do a case, we'll do colon and break,
我要做一个情况下,我们会做结肠和休息,

923
00:47:25,512 --> 00:47:27,445
And I'm gonna do a case for when it's a unaryOperation,
,我要做一个案例的时候unaryOperation,

924
00:47:27,514 --> 00:47:31,650
and break on that case, okay? And I don't even have to
,在这种情况下,好吗?

925
00:47:31,718 --> 00:47:34,286
say default here, because these are the only two values
说违约,因为这是唯一的两个值

926
00:47:34,354 --> 00:47:36,087
that an operation can be, cuz it's an enum,
可以将一个操作,因为这是一个枚举,

927
00:47:36,156 --> 00:47:39,591
it only has one of these two values, Now here, you can see,
现在只有这两个值之一,在这里,你可以看到,

928
00:47:39,660 --> 00:47:42,327
it already put this in parentheses right here,
它已经把这里的括号内,

929
00:47:42,395 --> 00:47:46,264
Okay, it wants to help you get that associated value out,
好的,希望帮助你得到相关的价值,

930
00:47:46,333 --> 00:47:47,866
Okay, awesome, how do we do that?
好的,太棒了,我们怎么做呢?

931
00:47:47,935 --> 00:47:51,536
We say let associatedConstantValue or
我们说让associatedConstantValue或

932
00:47:51,605 --> 00:47:55,940
whatever we wanna call this variable, And
不管我们想叫这个变量

933
00:47:56,009 --> 00:47:59,044
that means inside here, associatedConstantValue
这意味着在这里面,associatedConstantValue

934
00:47:59,113 --> 00:48:01,813
is gonna be that associated value, Now we would never call
会关联值,现在我们不会叫

935
00:48:01,881 --> 00:48:04,783
it associatedConstantValue, We'll rename it in a second,
associatedConstantValue,我们将重命名,

936
00:48:04,851 --> 00:48:06,585
But now what are we gonna do with it? Well,
但是现在我们要用它做什么?

937
00:48:06,653 --> 00:48:09,454
in the constant case we're just gonna set our accumulator
在恒定的情况下我们要组蓄电池

938
00:48:09,522 --> 00:48:12,924
to that associated value, Now, why we wouldn't call this
关联值,为什么我们不叫它

939
00:48:12,993 --> 00:48:15,494
associatedConstantValue? Well, first of all, anyone reading
associatedConstantValue吗?

940
00:48:15,562 --> 00:48:18,129
this code knows that this is the associated value,
这段代码知道这是相关的值,

941
00:48:18,198 --> 00:48:21,466
so you don't need to say associated, And we know i's
所以你不需要说相关联,我们知道我的

942
00:48:21,535 --> 00:48:24,002
a constant because we're in the constant case, so
一个常数,因为我们在恒定的情况下,

943
00:48:24,071 --> 00:48:25,737
i's really a waste to say that,
我真的是一个浪费,

944
00:48:25,805 --> 00:48:29,074
So, we would just say value here, Cuz that's what it is,
所以,我们只会说值,因为这是它是什么,

945
00:48:29,143 --> 00:48:33,712
i's the constant value that's associated with it, okay?
我的与之相关的常量值,好吗?

946
00:48:33,781 --> 00:48:37,415
We don't need break, Everybody got that?
我们不需要休息,大家都明白了吗?

947
00:48:37,484 --> 00:48:39,917
By the way, switches are slightly different in Swift in
顺便说一下,开关迅速的略有不同

948
00:48:39,986 --> 00:48:42,921
that they don't fall into each other, When you have constant,
他们不属于彼此,当你有常数,

949
00:48:42,990 --> 00:48:45,957
it does this, and it's done, It doesn't go down, fall down
它,它,它不下去,倒了

950
00:48:46,026 --> 00:48:49,161
to the next case, okay? So you don't need break at the end
接下来的情况,好吗?

951
00:48:49,230 --> 00:48:51,697
of every single one, which is really nice, All right?
每一个人,这是非常好的,对吧?

952
00:48:51,765 --> 00:48:54,032
So this is great, So should this work? I think so,
这是伟大的,所以这应该工作吗?

953
00:48:54,101 --> 00:49:03,208
Let's try it, All right,
让我们试试,好吧,

954
00:49:03,276 --> 00:49:05,711
So, Pi, okay, square root we haven't done anything with,
π,好的,根我们什么都没做,

955
00:49:05,779 --> 00:49:08,514
but pi should work, Let's try, Bingo, okay,
但π应该工作,让我们试试,宾果,好吧,

956
00:49:08,582 --> 00:49:10,748
So you see how pi is working here?
所以你看看π是在这里工作吗?

957
00:49:10,817 --> 00:49:14,852
We're saying to look up pi in this table, It finds that
我们说在这个表查找π,它发现

958
00:49:14,921 --> 00:49:17,756
it's a constant operation with this as the associated value,
它是一个常数操作与这相关的值,

959
00:49:17,825 --> 00:49:21,893
We switch on that operation, Find out that it's a constant,
我们开关操作,发现它是一个常数,

960
00:49:21,962 --> 00:49:25,364
We let value equal the associated value,
我们让价值平等相关的价值,

961
00:49:25,432 --> 00:49:27,099
and then we just set that to the accumulator,
然后我们组蓄电池,

962
00:49:28,568 --> 00:49:31,470
And now that's our result, the next time they ask for result
现在这是我们的结果,下次他们要求的结果

963
00:49:31,538 --> 00:49:33,572
that's what we got, Okay, now let's do unary operation,
这就是我们,好吧,现在让我们做一元运算,

964
00:49:33,641 --> 00:49:35,740
Okay, this one's a little tougher, okay?
好吧,这个有点困难,好吗?

965
00:49:35,809 --> 00:49:41,846
Cuz really what I wanna do is this, Right?
因为我真正想做的是这个,对吗?

966
00:49:41,915 --> 00:49:45,851
The associated value wants to be those functions,
想要这些功能相关的价值,

967
00:49:47,220 --> 00:49:50,021
Can I do that in Swift? Of course!
我可以用快速吗?

968
00:49:50,090 --> 00:49:52,924
We wouldn't be here if we couldn't do that,
我们不会在这里,如果我们做不到,

969
00:49:52,993 --> 00:49:55,861
How do we make an associated value be a function?
如何让一个关联的值是一个函数?

970
00:49:55,929 --> 00:49:58,997
Well the cool thing about Swift is that functions
斯威夫特是最酷的功能

971
00:49:59,066 --> 00:50:03,802
are normal types, Just like a double, any struct,
是正常的类型,就像一个翻倍,任何结构,

972
00:50:03,871 --> 00:50:06,905
a class, no difference between that and a double,
一个类,没有区别,双,

973
00:50:06,974 --> 00:50:09,608
So how do I go back up to my enum, and it have
所以我怎么回到我的枚举,并且它

974
00:50:09,676 --> 00:50:12,677
an associated type here be a double? How do I say,
一个关联的类型是双吗?

975
00:50:12,746 --> 00:50:15,514
the type which is a function that takes a double and
类型是一个函数,接受一个和的两倍

976
00:50:15,582 --> 00:50:17,415
returns a double? Cuz that's what I want in here,
返回一个双人床?

977
00:50:17,484 --> 00:50:18,750
This is a unary operation, so
这是一个一元运算,所以

978
00:50:18,819 --> 00:50:21,419
I need this to be a function that takes a double and
我需要这是一个函数,接受一个和的两倍

979
00:50:21,488 --> 00:50:24,489
returns a double, We just type it, function that takes
返回一个双,我们只是类型,函数

980
00:50:24,557 --> 00:50:27,226
a double, returns a double, Just type it right in there,
双,返回一个双类型它就在那里,

981
00:50:28,596 --> 00:50:32,364
This is a type, Just a type, just like string,
这是一个类型,类型,就像字符串,

982
00:50:32,433 --> 00:50:35,133
but it happens to be a function, Now I'm
但它是一个函数,我现在

983
00:50:35,202 --> 00:50:37,669
going to take a time-out right here just to show you a little
将暂停在这里给你一点

984
00:50:37,738 --> 00:50:39,237
bit more about this function types,
更多关于这个函数类型,

985
00:50:39,306 --> 00:50:41,906
to make sure you're getting this, And what I'm gonna do is
确保你得到这个,我要做的是什么

986
00:50:41,975 --> 00:50:44,476
I'm gonna create a new thing called a playground,
我要创建一个名为一个操场的新事物,

987
00:50:44,544 --> 00:50:46,978
So a playground is just a place we can play around with
操场就是我们可以玩耍的地方

988
00:50:47,047 --> 00:50:49,948
iOS code, Okay? So you just say new playground,
iOS代码,好吗?

989
00:50:50,017 --> 00:50:52,884
this is gonna be an iOS playground, I'm gonna call it
这将是一个iOS操场,我会叫它

990
00:50:52,953 --> 00:50:55,420
my CalculatorPlayground, I can call it anything I want,
CalculatorPlayground,我可以称之为任何我想要的,

991
00:50:55,489 --> 00:50:57,355
Just gonna save it on disk so that what I
要将其保存在磁盘上,以便我

992
00:50:57,424 --> 00:50:59,791
type in here when I'm playing gets saved for the next time,
类型在这里当我玩会保存在接下来的时间,

993
00:50:59,860 --> 00:51:01,593
You can put it anywhere you want,
你可以放任何你想要的,

994
00:51:01,662 --> 00:51:04,863
I recommend the same place, home directory, Developer,
我建议同一个地方,主目录,开发人员,

995
00:51:04,932 --> 00:51:07,598
Okay, don't put it inside another project or whatever,
好了,不要把它在另一个项目,

996
00:51:07,667 --> 00:51:10,535
And you can see the playground looks like this, On the left,
你可以看到操场上是这样,在左边,

997
00:51:10,604 --> 00:51:14,039
you can type any iOS code you want, And on the right,
你可以输入任何你想要的iOS的代码,在右边,

998
00:51:14,108 --> 00:51:17,442
it's going to evaluate what's on the left and show you not
左边的评估是什么,让你没有

999
00:51:17,511 --> 00:51:19,845
only, well, it's basically gonna show you the result or
,它基本上是要给你或结果

1000
00:51:19,913 --> 00:51:22,013
the value of any var that it finds,
它发现的任何var的价值,

1001
00:51:22,082 --> 00:51:24,916
So here it found this var string, str, and it's
这发现这var字符串,str,

1002
00:51:24,985 --> 00:51:28,587
showing you the value of str over here, Okay? So I can say,
显示你的价值str在这里,好吗?

1003
00:51:28,656 --> 00:51:33,125
for example, let i = 27 and it's gonna say that 27 is what
例如,让我= 27岁,会说,27是什么

1004
00:51:33,194 --> 00:51:38,763
it sees there, But I'm gonna create a new var,
它看到,但我要创建一个新的变量,

1005
00:51:38,832 --> 00:51:42,601
I'm gonna call it f, Its type is gonna be a function that
我要叫它f,其类型是一个函数

1006
00:51:42,670 --> 00:51:46,671
takes a double and returns a double, Okay, that's its type,
双并返回一个双,好吧,这是它的类型,

1007
00:51:46,740 --> 00:51:49,808
I could have said f, var f string, but
我可能说f,f var字符串,但是

1008
00:51:49,877 --> 00:51:52,043
I said it's a function that takes a double and
我说这是一个函数,它接受一个和的两倍

1009
00:51:52,112 --> 00:51:54,346
returns a double, And I'm gonna set the value of f,
返回一个双,我设置的值,

1010
00:51:54,414 --> 00:51:58,316
I'm gonna set it equal to square root, Okay,
我要把它等于平方根,好吧,

1011
00:51:58,385 --> 00:51:59,684
I mean it's a function that takes a double and
我的意思是这是一个函数,它接受一个和的两倍

1012
00:51:59,753 --> 00:52:02,688
returns a double, So I can say f = square root, Now how do I
返回一个双,所以我可以说f =平方根,现在我如何

1013
00:52:02,756 --> 00:52:07,493
actually call this function? Well I'm gonna let x equal f
调用这个函数呢?

1014
00:52:07,561 --> 00:52:12,598
of 81, for example, Okay, so I call this variable,
81年,例如,好的,所以我把这个变量,

1015
00:52:12,666 --> 00:52:14,466
right here, which is a double that takes a double,
在这里,这是一个增加一倍,两倍

1016
00:52:14,534 --> 00:52:17,269
just like it was a function, And if I were to go back and
就像它是一个函数,如果我回去

1017
00:52:17,338 --> 00:52:22,674
change this to cosine, look what happens, Okay,
改变这个余弦,看看发生了什么,好了,

1018
00:52:22,742 --> 00:52:25,510
so now f is cosine so now I'm getting the cosine of 81,
所以现在f是余弦现在我得到81年的余弦,

1019
00:52:25,579 --> 00:52:27,078
I can even write my own function,
我甚至可以编写自己的函数,

1020
00:52:27,147 --> 00:52:29,748
how bout func changeSign,
怎么样func changeSign,

1021
00:52:29,817 --> 00:52:33,752
let's say it takes a double and
假设需要一和

1022
00:52:33,821 --> 00:52:37,222
returns a double, okay, So it's a regular function,
返回一个双,好吧,这是一个常规的函数,

1023
00:52:37,291 --> 00:52:40,125
returns the changeSigned operand, right,
返回changeSigned操作数,

1024
00:52:40,194 --> 00:52:43,261
operand changed sign, So now I could go down here and
操作数改变符号,所以现在我可以在这里

1025
00:52:43,330 --> 00:52:47,666
change this to be changeSign, function I wrote, And
改变这种changeSign,我写的函数,

1026
00:52:47,734 --> 00:52:50,536
now I'm getting minus 81, Okay? So everyone's seeing how
现在我得到- 81,好吗?

1027
00:52:50,604 --> 00:52:53,538
this type functions as a type? They're just normal type,
这种类型的功能作为一个类型?

1028
00:52:53,607 --> 00:52:56,341
Absolutely, you can use a function as a type anywhere
当然,你可以在任何地方使用函数作为类型

1029
00:52:56,409 --> 00:52:59,344
you can use any other type, Argument to a method,
您可以使用任何其他类型,论证方法,

1030
00:52:59,413 --> 00:53:03,215
associated value in an enum, local variable, anything,
关联值的枚举,局部变量,任何东西,

1031
00:53:03,284 --> 00:53:06,451
No restriction on it, okay? I'm even gonna take the,
不限制它,好吗?

1032
00:53:06,520 --> 00:53:09,287
note also, by the way, the change sign has an external
还请注意,顺便说一下,改变了外部迹象

1033
00:53:09,356 --> 00:53:11,823
name, operand, When you tall, call change sign,
名称、操作数高时,调用改变符号,

1034
00:53:11,891 --> 00:53:15,493
looks like this, See? We've got this operand, It's okay,
就像这样,看到了吗?

1035
00:53:15,562 --> 00:53:18,296
when I call it down here, I don't have to say f(operand),
当我叫它下面,我不必说f(操作数),

1036
00:53:18,365 --> 00:53:21,166
In fact, I can't say that, And that's because f
事实上,我不能说,因为f

1037
00:53:21,235 --> 00:53:23,835
is just a function that takes a double, returns a double,
只是一个函数,它接受一个翻倍,返回一个双,

1038
00:53:23,904 --> 00:53:25,403
It can be any function that takes a double and
它可以是任何需要双和函数

1039
00:53:25,472 --> 00:53:27,940
returns a double, so you can't have those external names in
返回一个双,所以你不能有外部的名字

1040
00:53:28,008 --> 00:53:29,741
there, cuz it can be any function,
因为它可以是任何函数,

1041
00:53:29,809 --> 00:53:33,678
As you change it you can't be changing this, so, anyway,
当你改变你不能改变,所以,无论如何,

1042
00:53:33,747 --> 00:53:37,315
just a minor note there, So I'm gonna take changeSign,
只是一个小的注意,所以我要把changeSign,

1043
00:53:37,384 --> 00:53:40,952
actually, and copy and paste it back into my code up here,
事实上,复制粘贴回我的代码,

1044
00:53:41,021 --> 00:53:44,056
so I just made a new function, it's even a nice global
所以我就做了一个新功能,甚至全球

1045
00:53:44,124 --> 00:53:46,458
to this file, function called changeSign, And
这个文件,函数称为changeSign,

1046
00:53:46,527 --> 00:53:49,894
I can go back here and say, changeSign, let's do something
我可以回到这里,changeSign,让我们做点什么

1047
00:53:49,963 --> 00:53:54,232
for changeSign, I think I can remember how to do this,
changeSign,我想我能记得如何做到这一点,

1048
00:53:54,301 --> 00:53:57,435
there, Ctrl + C, Cmd + Ctrl + Space, something like that,
那里,Ctrl + C Cmd + Ctrl + Space,,

1049
00:53:57,504 --> 00:54:01,606
let's go here, Edit, Okay, we need something for
我们去这里,编辑好了,我们需要一些

1050
00:54:01,675 --> 00:54:03,942
changeSign, I think I have one here, this one, okay?
changeSign,我认为我有一个在这里,这个,好吗?

1051
00:54:04,011 --> 00:54:06,445
It's not really change sign [LAUGH] but,
这不是(笑),但真正改变标志,

1052
00:54:06,513 --> 00:54:09,747
it's all right we'll use it for that, And, so
没关系,我们将使用它,因此

1053
00:54:09,816 --> 00:54:17,256
this is an operation, an Operation,unaryOperation(chan-
这是一个操作,一个操作,unaryOperation(chan -

1054
00:54:17,324 --> 00:54:21,460
geSign), Okay? Perfectly legal, Okay, everybody got
geSign),好吗?

1055
00:54:21,528 --> 00:54:26,531
that? So now, down here in our switch, in the same
了吗?

1056
00:54:26,600 --> 00:54:29,501
way that we grabbed the constant value with let value,
我们抓住了让值的恒定值,

1057
00:54:29,570 --> 00:54:33,371
let's grab that associated function with let function,
让我们抓住相关函数与函数,

1058
00:54:33,440 --> 00:54:35,207
And again we can call, this doesn't have to be a function,
我们可以打电话,这不必是一个函数,

1059
00:54:35,275 --> 00:54:38,777
This could be f, It could be func, Can't be func, because
这可能是f,可以是函数,不能函数,因为

1060
00:54:38,846 --> 00:54:42,480
that's a keyword, but function it could be, Okay? So we got
这是一个关键字,但可以是函数,对吧?

1061
00:54:42,549 --> 00:54:45,650
this unary operation, What are we gonna do? Well we just want
这个一元运算,我们要做什么?

1062
00:54:45,719 --> 00:54:49,954
to call this thing with the accumulator, Okay?
与蓄电池叫这个东西,好吗?

1063
00:54:50,023 --> 00:54:52,657
But of course we'd better, I'm sorry, we want our accumulator
当然我们最好,对不起,我们希望我们的蓄电池

1064
00:54:52,726 --> 00:54:55,093
to equal, calling that function with the accumulator,
与蓄电池相同的情况下,调用这个函数,

1065
00:54:55,162 --> 00:54:57,963
We'd better check though to make sure this is not nil, So
我们最好检查一下,确保这不是零,所以

1066
00:54:58,032 --> 00:54:59,531
I'm actually gonna do something a little different,
我要做点不同,

1067
00:54:59,599 --> 00:55:02,267
Instead of if let, I'm gonna say if the accumulator does
相反,如果让我会说如果蓄电池

1068
00:55:02,335 --> 00:55:07,272
not equal nil, Then we'll do this, This is another
不等于零,那么我们会这样做,这是另一个

1069
00:55:07,341 --> 00:55:12,677
way to protect against this crashing your app, Okay,
方法来防止这个应用程序崩溃,好吧,

1070
00:55:12,746 --> 00:55:16,648
somewhat similar to if let operand equal accumulator,
有点类似于如果让操作数等于蓄电池,

1071
00:55:16,717 --> 00:55:20,285
but I'm just actually checking to see if accumulator is in
但实际上我只是检查蓄电池

1072
00:55:20,354 --> 00:55:21,220
the not set state,
没有设置状态,

1073
00:55:21,288 --> 00:55:23,888
accumulator isn't optional, so it can be equal to nil or
蓄电池不是可选的,所以它可以等于零

1074
00:55:23,957 --> 00:55:26,325
it's equal to something else, and it has an associated value
它等于别的东西,它都有一个关联的值

1075
00:55:26,393 --> 00:55:30,929
like these things, All right? That's all we need to do,
像这样的事情,对吧?

1076
00:55:30,998 --> 00:55:33,231
Let's take a look, Whoops, we, we have errors there?
让我们看一看,哎呀,我们我们有错误吗?

1077
00:55:33,300 --> 00:55:39,771
No, we don't, Okay, All right,
不,我们没有,好吧,好吧,

1078
00:55:39,840 --> 00:55:45,076
So, pi, still good, 81, square root,
π,还好,81年,平方根,

1079
00:55:45,145 --> 00:55:49,180
Working like a charm, Okay, and again if we add cosine and
工作就像一个魅力,好的,如果我们添加cos和

1080
00:55:49,249 --> 00:55:51,016
those which we are going to add those in a second, but for
那些我们要添加的,但是

1081
00:55:51,085 --> 00:55:53,618
time I'm not adding them in, But we'll add cosine and
时间我不加入他们,但我们将添加余弦和

1082
00:55:53,687 --> 00:55:55,653
all, actually I'm, forget it, let's do it,
实际上我,算了吧,让我们做它,

1083
00:55:55,722 --> 00:55:59,357
Let's go back to our UI right here and let's add those other
让我们回到我们的UI在这里添加其他

1084
00:55:59,426 --> 00:56:04,495
buttons, Let's put cosine in here, Cosine,
按钮,在这里我们把cos,余弦,

1085
00:56:04,564 --> 00:56:09,301
and let's even put our little change sign that we did there,
甚至让我们把我们的小变化表明我们做,

1086
00:56:09,370 --> 00:56:14,472
Ctrl+Cmd+Space, there we go, Change sign,
Ctrl + Cmd +空间,好了,改变符号,

1087
00:56:14,541 --> 00:56:17,475
Put the change sign in there, So we'll put those in there
把改变符号,所以我们把这些

1088
00:56:17,544 --> 00:56:19,144
and that's all we need to do in my UI,
这是我们要做的在我的用户界面,

1089
00:56:19,213 --> 00:56:21,046
It can just run again, because my brain,
它可以再次运行,因为我的大脑,

1090
00:56:21,114 --> 00:56:23,348
my model already knows how to do those operations,
我的模型已经知道如何做这些操作,

1091
00:56:23,416 --> 00:56:26,018
So I can put any operation my brain knows how to do
所以我可以把我的大脑知道如何做任何操作

1092
00:56:26,086 --> 00:56:28,386
into my calculator's UI and it'll just work,
进我的计算器的UI,它会工作,

1093
00:56:28,455 --> 00:56:32,524
So here we got, you know, how about pi cosine, -1,0,
我们,你知道,如何πcos,1,0,

1094
00:56:32,593 --> 00:56:38,029
all right? Change sign, positive 1,0, All right, so
好吧?

1095
00:56:38,098 --> 00:56:42,300
this is really looking nice, because our calculator brain,
这真的是看起来不错,因为我们的计算器大脑,

1096
00:56:42,369 --> 00:56:44,903
still hardly any code in here, and yet
仍然在这里几乎没有任何代码,然而

1097
00:56:44,972 --> 00:56:48,373
now it's fully extensible for both constants and
现在是完全可扩展的常量和

1098
00:56:48,442 --> 00:56:52,711
unary operations, What's next? Binary operations,
一元操作,接下来是什么?

1099
00:56:52,780 --> 00:56:57,382
5 times 3 equals, okay, much more difficult, right?
5乘以3 =,更加困难,对吧?

1100
00:56:57,451 --> 00:57:01,286
Because there's actually two operations there when we do 5
因为有两个操作当我们做5

1101
00:57:01,355 --> 00:57:05,323
times 3 equals, There's the times, which puts you in this
* 3 =,《纽约时报》,让你在这

1102
00:57:05,392 --> 00:57:09,160
weird pending state, and then there's the equals which
奇怪的挂起状态,还有的=

1103
00:57:09,229 --> 00:57:13,364
actually finishes the 5 times 3 equals, right? So I'm
实际完成5乘以3 = ?

1104
00:57:13,433 --> 00:57:17,535
gonna need some data structure to remember the 5 times
需要一些数据结构记住5次

1105
00:57:17,604 --> 00:57:20,805
until the equals comes along, Okay, so let's do that,
直到等于出现,好吧,让我们来做,

1106
00:57:20,874 --> 00:57:23,608
let's add a data structure for that, Actually, before we even
让我们添加一个数据结构,实际上,之前

1107
00:57:23,677 --> 00:57:26,945
do that, let's back up here and talk about all this mess,
这样做,让我们回到这里,谈论这一切混乱,

1108
00:57:27,014 --> 00:57:29,848
What's this gonna be like for binary operations? So we need
这是什么会喜欢为二进制操作吗?

1109
00:57:29,917 --> 00:57:34,753
a binary operation here, And what's its type gonna be?
一个二元运算,其类型会是什么?

1110
00:57:34,821 --> 00:57:39,491
What's its associated value gonna be? What do you think?
它的关联值会是什么?

1111
00:57:41,295 --> 00:57:44,195
How about a function that takes two double and
一个函数,它接受两个双和怎么样

1112
00:57:44,264 --> 00:57:47,432
returns a double? All right, and we're also gonna need
返回一个双人床?

1113
00:57:47,500 --> 00:57:50,602
an equals operation as well, And so
一个等于操作,所以

1114
00:57:50,671 --> 00:57:53,438
we can just go down here and do, for example, times,
我们可以去做,例如,时间,

1115
00:57:53,507 --> 00:57:57,542
let's do times, Oops, space, there we go,
让我们做次,哦,空间,好了,

1116
00:57:57,611 --> 00:58:01,747
I've got a nice mathematical times symbol here, Okay,
我有一个很好的数学时代象征,好吧,

1117
00:58:01,815 --> 00:58:05,851
we have to enter in Operation,binaryOperation, And
我们必须输入操作,binaryOperation,

1118
00:58:05,919 --> 00:58:09,821
we need multiply basically here, So I'm gonna make my own
我们需要乘基本上在这里,所以我要做我自己

1119
00:58:09,890 --> 00:58:13,058
multiply function, We'll just put multiply there,
乘法函数,我们将把用在那里,

1120
00:58:13,126 --> 00:58:18,563
Also of course, I need equals which is Operation,equals,
当然,我需要等于操作,等于,

1121
00:58:18,632 --> 00:58:21,600
Okay, put those on my table, So this multiply,
好吧,把这些放在我的桌子,这成倍增加,

1122
00:58:21,668 --> 00:58:24,903
where's that? There's no function called multiply,
它在哪里?

1123
00:58:24,972 --> 00:58:26,605
Well, just like I did changeSign up here,
嗯,就像我做changeSign,

1124
00:58:26,674 --> 00:58:28,406
I'm gonna create my own little func,
我要创造我自己的小函数,

1125
00:58:28,475 --> 00:58:32,144
multiply, It's gonna take op1, which is a Double,
用,它会采取op1,双,

1126
00:58:32,213 --> 00:58:34,012
and op2, which is a Double, And
和《凤凰社》第2章,这是双重的,

1127
00:58:34,081 --> 00:58:39,451
it's gonna return a Double, of course, Oops, and
当然,它会返回一个双哦,

1128
00:58:39,520 --> 00:58:41,954
it's just gonna return op1 times op2, okay?
只是要返回op1倍op2,好吗?

1129
00:58:42,022 --> 00:58:45,190
So I got this nice function up here, Fits in here nice,
所以我有一个漂亮的函数,适合在这里好,

1130
00:58:45,259 --> 00:58:48,727
no error, everything's fine there, got that, So
没有错误,一切都很好,明白了,所以

1131
00:58:48,795 --> 00:58:52,898
now we have the hard part of what do we do with the case
现在我们有努力的一部分,我们该怎么做

1132
00:58:52,966 --> 00:58:56,701
here that is binary operation? We still have a function,
这里是二元运算?

1133
00:58:56,770 --> 00:58:59,337
but now it's a function that takes two doubles and returns
但是现在它是一个函数,它接受两个双打和回报

1134
00:58:59,406 --> 00:59:04,042
a double, All right, so what are we gonna do here? Get,
双,好吧,那么我们要做什么呢?

1135
00:59:04,111 --> 00:59:08,046
like I said, we're gonna need some kind of data structure
就像我说的,我们需要某种类型的数据结构

1136
00:59:08,115 --> 00:59:09,848
to remember five times and
记住,5倍

1137
00:59:09,917 --> 00:59:13,518
wait till we get another case which is equals, okay?
等到我们得到另一个例子就是等于,好吗?

1138
00:59:13,587 --> 00:59:16,187
And we're gonna have to do something in here, So
我们要做一些在这里,

1139
00:59:16,256 --> 00:59:19,758
let's take a time out here and create another data structure
让我们来一次这里创建另一个数据结构

1140
00:59:19,827 --> 00:59:22,994
to remember five times while we're waiting for
记得当我们等待5倍

1141
00:59:23,063 --> 00:59:26,097
three equals to happen, So I'm gonna make it a struct,
3 =发生,所以我要使它成为一个结构体,

1142
00:59:26,166 --> 00:59:29,434
It's also gonna be an embedded private struct, just like this
也会嵌入式私人结构,就像这样

1143
00:59:29,503 --> 00:59:33,805
was embedded private enum, So the name of this enum,
嵌入式私人枚举,所以这个枚举的名字,

1144
00:59:33,874 --> 00:59:36,975
its full name is CalculatorBrain,Operation, but
它的全名是计算器大脑操作,但是

1145
00:59:37,044 --> 00:59:39,410
as long as I'm using it inside this struct,
只要我使用它在这个结构体,

1146
00:59:39,479 --> 00:59:42,447
we can just call it operation, like we did right here,
我们可以叫它操作,像我们一样,

1147
00:59:42,516 --> 00:59:44,315
Okay, so same thing here,
这里也一样,

1148
00:59:44,384 --> 00:59:48,186
I'm gonna call this one PendingBinaryOperation,
我要叫这个PendingBinaryOperation,

1149
00:59:48,255 --> 00:59:50,255
Okay, it's gonna be a PendingBinaryOperation,
好吧,它会成为一个PendingBinaryOperation,

1150
00:59:50,324 --> 00:59:54,326
And it's gonna have two vars, One is the function which is
会有两个var,一个是函数

1151
00:59:54,395 --> 00:59:59,231
gonna be, it takes two Doubles, returns a Double, And
会,需要两个双打,返回一个双,

1152
00:59:59,299 --> 01:00:03,368
it's going to have the first operand, which is a Double,
它将第一个操作数,这是一个翻倍,

1153
01:00:03,437 --> 01:00:06,904
So it's just gonna be a struct that holds those two things,
所以它只是将一个结构体,拥有这两件事,

1154
01:00:06,973 --> 01:00:10,842
Now never forget that structs in Swift can have methods and
现在永远不会忘记,在迅速可以有方法和结构

1155
01:00:10,911 --> 01:00:11,877
things like that, In fact,
事实上,类似这样的事情

1156
01:00:11,945 --> 01:00:13,745
I'm gonna put a method on here just to remind us of that,
我将一个方法在这里只是提醒我们,

1157
01:00:13,814 --> 01:00:16,749
I'm gonna have a func called perform which will
我要有一个函数调用执行

1158
01:00:16,817 --> 01:00:19,684
perform this binary operation, Now what does
执行这个二元运算,现在什么

1159
01:00:19,753 --> 01:00:23,689
it need to perform it? It needs a second operand,
它需要执行吗?

1160
01:00:26,126 --> 01:00:29,260
Okay? And it's gonna return a double, Okay,
好吧?

1161
01:00:29,329 --> 01:00:32,497
now, notice the naming here, Why did I use this naming,
现在,请注意这里的命名,为什么我使用这个命名,

1162
01:00:32,566 --> 01:00:36,735
with as my external and here secondOperand as my internal?
与我这里secondOperand作为内部和外部?

1163
01:00:36,804 --> 01:00:38,336
Well, secondOperand is the internal,
嗯,secondOperand内部,

1164
01:00:38,405 --> 01:00:40,071
because that's what this argument is,
因为这是这个论点是什么,

1165
01:00:40,140 --> 01:00:42,574
And in my code here, I want the firstOperand and
在我的代码,我想firstOperand和

1166
01:00:42,643 --> 01:00:44,643
secondOperand to have the right names, But
secondOperand正确的名字,但是

1167
01:00:44,711 --> 01:00:47,713
I'm using with because when someone calls this, they're
我使用,因为当有人叫这个,他们

1168
01:00:47,781 --> 01:00:50,482
gonna say perform(with: 5,0), And of course,
会说执行(0):5日,当然,

1169
01:00:50,551 --> 01:00:53,284
if they're performing a pending binary operation, so
如果他们执行一个悬而未决的二元运算,所以

1170
01:00:53,353 --> 01:00:56,221
this makes perfect sense, If you say binary operation,
这非常有意义,如果你说二元运算,

1171
01:00:56,290 --> 01:01:00,859
perform(with: 5,0), It makes sense, right? And these
执行(0):5日,它是有意义的,对吧?

1172
01:01:00,928 --> 01:01:03,228
internal names, even though they're only used internally,
内部的名字,即使他们只在内部使用,

1173
01:01:03,296 --> 01:01:05,797
you can think of them as part of the documentation,
你可以把它们作为文档的一部分,

1174
01:01:05,866 --> 01:01:08,833
Cuz anyone who sees the documentation of this method,
因为人看到这种方法的文档,

1175
01:01:08,902 --> 01:01:12,070
he's gonna see both with and secondOperand, see? So they're
他会看到secondOperand,看到了吗?

1176
01:01:12,139 --> 01:01:14,773
kind of getting a little bit of documentation that that
的有点的文档

1177
01:01:14,841 --> 01:01:18,577
with is with the secondOperand to this binary operation,
与是secondOperand二元运算,

1178
01:01:18,645 --> 01:01:23,882
Okay, and how would we perform this? Well, we would just
好吧,这和我们如何执行?

1179
01:01:23,951 --> 01:01:30,255
return the firstOperand times the secondOperand, okay? But
返回firstOperand乘以secondOperand,好吗?

1180
01:01:30,324 --> 01:01:33,525
we're not doing times here, we're doing this function,
我们这里不做次,我们做这个函数,

1181
01:01:33,593 --> 01:01:37,696
So I'm gonna call it that function with the firstOperand
所以我要叫它与firstOperand这个函数

1182
01:01:37,765 --> 01:01:40,799
and the secondOperand, Okay, this is a really simple little
secondOperand,好吧,这是一个很简单的小

1183
01:01:40,868 --> 01:01:42,667
method, but I just wanted to make it clear,
方法,但我只是想弄清楚,

1184
01:01:42,736 --> 01:01:46,604
Notice this method doesn't have mutating on it, Because
注意这种方法没有变异,因为

1185
01:01:46,673 --> 01:01:49,374
it doesn't actually change the PendingBinaryOperation,
它实际上并不改变PendingBinaryOperation,

1186
01:01:49,443 --> 01:01:52,044
right? It just returns to the evaluation of the function,
对吧?

1187
01:01:52,112 --> 01:01:56,882
but it doesn't change any internal values, Also notice,
但它也不会改变任何内部值,注意,

1188
01:01:56,951 --> 01:02:01,253
these are lets, That's because I'm gonna create this
这些是允许,那是因为我要创建这个

1189
01:02:01,321 --> 01:02:04,256
PendingBinaryOperation in a moment with these two things
与这两个东西PendingBinaryOperation一会儿

1190
01:02:04,325 --> 01:02:06,225
set and I'm never gonna change them,
设置和我永远不会改变,

1191
01:02:06,293 --> 01:02:10,596
So they are constants in this struct, Now, also notice,
所以他们是常数在这个结构体,现在,也注意到,

1192
01:02:10,664 --> 01:02:13,398
no error that says you don't have an initializer and you
没有错误,你不有一个初始化程序和你说

1193
01:02:13,467 --> 01:02:17,569
have these two uninitialized vars, Again, this is a struct,
有这两个未初始化的var,再一次,这是一个结构体,

1194
01:02:17,637 --> 01:02:20,105
Structs automatically get a free initializer
结构自动获得一个免费的初始值设定项

1195
01:02:20,174 --> 01:02:23,041
which will initialize all of these things, And
将初始化所有的这些东西,

1196
01:02:23,109 --> 01:02:25,110
in fact, let's use that right now,
事实上,我们使用,现在,

1197
01:02:25,178 --> 01:02:29,814
I'm gonna create a private var, which I'm gonna call pbo,
我要创建一个私有变量,我会叫pbo,

1198
01:02:29,883 --> 01:02:33,551
PendingBinaryOperation, but only temporarily, because
PendingBinaryOperation,但这只是暂时的,因为

1199
01:02:33,620 --> 01:02:36,354
this is a bad name, I'm mostly doing it so things won't
这是一个坏名声,我主要做所以事情不会

1200
01:02:36,423 --> 01:02:38,890
wrap, cuz I'm using a big font so you can see here, I'm gonna
包装,因为我用大字体,所以你可以看到,我要

1201
01:02:38,959 --> 01:02:41,726
go actually change this back to a better name in a second,
实际上改变这一切回到一个更好的名字,

1202
01:02:41,795 --> 01:02:46,431
But this pbo is a PendingBinaryOperation,
但这pbo PendingBinaryOperation,

1203
01:02:46,500 --> 01:02:48,366
and optional,
和可选的,

1204
01:02:48,435 --> 01:02:50,936
Why is this an optional PendingBinaryOperation?
为什么这是一个可选的PendingBinaryOperation吗?

1205
01:02:51,004 --> 01:02:53,538
Cuz we're not always in the middle of a binaryOperation,
因为我们不是binaryOperation总是在中间,

1206
01:02:53,607 --> 01:02:56,174
Only when the person taps five times, Okay,
只有当人利用五次,好吧,

1207
01:02:56,243 --> 01:02:57,575
if we'd said five square root,
如果我们说5根,

1208
01:02:57,644 --> 01:03:00,078
we're not in the middle of a PendingBinaryOperation, so
我们不是在中间PendingBinaryOperation,如此

1209
01:03:00,147 --> 01:03:02,914
this has to be not set, Are you starting to get a feel for
这是没有设置,你开始了解

1210
01:03:02,983 --> 01:03:05,250
how we use optionals all over the place,
我们如何使用可选的地方,

1211
01:03:05,318 --> 01:03:09,354
to be semantically exactly what we mean? And here,
语义上正是我们的意思吗?

1212
01:03:09,423 --> 01:03:11,056
if we're not in the middle of PendingBinaryOperation,
如果我们不是PendingBinaryOperation中间,

1213
01:03:11,124 --> 01:03:14,893
this is not set, So it's an optional, All right, so
这不是,这是一个可选的,所以

1214
01:03:14,962 --> 01:03:17,128
when you've pressed the times,
当你按下时间,

1215
01:03:17,197 --> 01:03:21,065
5 times, all I'm gonna do here is remember, or create,
5倍,所有我要做的就是记住,或创建,

1216
01:03:21,134 --> 01:03:23,068
a PendingBinaryOperation,
PendingBinaryOperation,

1217
01:03:23,137 --> 01:03:26,371
So I'm gonna say pbo = PendingBinaryOperation,
所以我想说pbo = PendingBinaryOperation,

1218
01:03:26,440 --> 01:03:30,942
Now when I tab here, and I do the open parentheses, Look,
现在当我标签,我开括号,看,

1219
01:03:31,011 --> 01:03:34,446
it's showing me that there's already an initializer,
告诉我,已经有一个初始化,

1220
01:03:34,515 --> 01:03:37,682
one that, tab, takes function and firstOperand,
选项卡,需要功能和firstOperand,

1221
01:03:37,751 --> 01:03:41,453
Woo-hoo! So this is that free initializer I get,
啊!

1222
01:03:41,521 --> 01:03:45,224
because I'm a struct down here, not a class, So what is
因为我是一个结构体,不是一个类,那么

1223
01:03:45,292 --> 01:03:47,792
the function? Well, that's just this function right here,
这个函数呢?

1224
01:03:47,861 --> 01:03:49,394
that we got as our associated value,
我们作为我们的相关值,

1225
01:03:49,463 --> 01:03:51,396
That's the function in the binaryOperation,
binaryOperation的函数,

1226
01:03:51,465 --> 01:03:52,864
And what's the firstOperand?
和firstOperand是什么?

1227
01:03:52,933 --> 01:03:55,567
Well, it's our current accumulator, right,
这是我们当前的蓄电池,

1228
01:03:55,636 --> 01:04:00,639
five times are equal if it's a five, okay? Now,
五次都是平等的,如果这是一个五,好吗?

1229
01:04:00,708 --> 01:04:04,843
here I'm unwrapping it, so I better do if accumulator
我打开它,所以我最好如果蓄电池

1230
01:04:04,912 --> 01:04:08,213
does not equal nil, Cuz I don't want to crash here and
不等于零,因为我不想和崩溃吗

1231
01:04:08,282 --> 01:04:10,983
I'm, so that means I'm gonna ignore times, If you've
我,这意味着我要忽略,如果你

1232
01:04:11,051 --> 01:04:12,984
pressed times and you haven't given me an operand,
按次,你没有给我一个操作数,

1233
01:04:13,053 --> 01:04:15,520
we're just gonna ignore that, It's like if you start up your
我们会忽略,就像如果你启动

1234
01:04:15,588 --> 01:04:18,290
calculator and say, times 3 equals, I'm gonna ignore it,
计算器,乘以3等于,我要忽略它,

1235
01:04:18,358 --> 01:04:21,426
because I don't have any operands who times it by,
因为我没有通过任何操作数倍,

1236
01:04:21,495 --> 01:04:25,530
Okay, so that's good, that's what I want, Also, when I
好吧,这很好,这就是我想要的,而且,当我

1237
01:04:25,599 --> 01:04:29,768
have this times, I'm gonna set my accumulator here to nil,
有一次,我要我的累加器设置为零,

1238
01:04:29,837 --> 01:04:33,671
Because I'm in this weird half state five times,
因为我在这个奇怪的一半国家的5倍,

1239
01:04:33,740 --> 01:04:35,874
my accumulator is waiting for
我的蓄电池是等待

1240
01:04:35,943 --> 01:04:38,410
the three equals to be set to anything,
三个等于被设置为任何东西,

1241
01:04:38,479 --> 01:04:42,814
So I'm setting it to nil not set for the moment, All right,
所以我将它设置为零没有设置目前,好吧,

1242
01:04:42,882 --> 01:04:45,750
so that's it, that's all I need to do when times is hit,
就是这样,这就是我需要做的时候,

1243
01:04:45,819 --> 01:04:49,454
But now when equals is hit, I have the the three, and
但是现在等于击中时,我有三个

1244
01:04:49,523 --> 01:04:51,223
I need to calculate five times three,
我需要计算3、5倍

1245
01:04:51,292 --> 01:04:54,325
So I need to actually call this perform down here, So
所以我需要真正称之为执行下面,所以

1246
01:04:54,394 --> 01:04:56,862
I'm gonna put this in its own little method, I'm gonna call
我要把它放到自己的小方法,我要打电话

1247
01:04:56,930 --> 01:05:01,133
it performBinaryOperation, actually, we'll even say
实际上,我们甚至会说,这performBinaryOperation

1248
01:05:01,201 --> 01:05:05,604
performPendingBinary, oops, BinaryOperation, okay,
BinaryOperation performPendingBinary,哎呀,好吧,

1249
01:05:05,672 --> 01:05:06,638
I'm putting it in another method,
我把它在另一个方法,

1250
01:05:06,707 --> 01:05:09,775
you'll see why in a moment, Okay, so I'm gonna do private
你就会明白为什么,所以我要做私人的

1251
01:05:09,843 --> 01:05:14,513
func which is that, now what am I gonna do in here? Well,
函数就是,现在我要在这里做什么呢?

1252
01:05:14,581 --> 01:05:18,516
here I'm going to perform that pendingBinaryOperation, So
这里我要执行pendingBinaryOperation,所以

1253
01:05:18,585 --> 01:05:22,988
I'm gonna do pbo,perform, and what am I gonna perform with?
我要做pbo、执行和我要做什么?

1254
01:05:23,057 --> 01:05:26,591
I'm gonna perform with the current accumulator, okay?
我要执行与当前蓄电池,好吗?

1255
01:05:26,660 --> 01:05:30,662
Now notice this put a question mark right there, okay?
现在注意到这把一个问号,好吗?

1256
01:05:30,731 --> 01:05:32,231
The reason I need a question mark there, really,
我需要一个问号,真的,

1257
01:05:32,299 --> 01:05:35,767
what I wanted was exclamation point, Because pbo, here,
我想要的是感叹号,因为pbo,这里,

1258
01:05:35,836 --> 01:05:38,103
is an optional, and I need to unwrap it,
是一个可选的,我需要打开它,

1259
01:05:38,172 --> 01:05:40,773
But what's really cool is if instead of exclamation point,
但是真正酷的是如果不是感叹号,

1260
01:05:40,841 --> 01:05:44,410
you put question mark, then it will unwrap it, but
你把问号,那么它将打开它,但是

1261
01:05:44,478 --> 01:05:47,479
it's not set, it will just ignore this line,
它不是,它只会忽略这条线,

1262
01:05:47,548 --> 01:05:51,216
Ignore the rest of the line, okay? So
忽略其余的线?

1263
01:05:51,284 --> 01:05:53,185
that's kind of a cool feature, But I'm not gonna do that,
这是一个很酷的功能,但我不会这样做,

1264
01:05:53,254 --> 01:05:55,353
cuz I didn't really talked enough about it, so
因为我没有足够的谈论它,所以

1265
01:05:55,422 --> 01:05:58,523
I'm gonna unwrap it, So here I need to make sure pbo is not
我要打开它,所以在这里我需要确保pbo不是

1266
01:05:58,591 --> 01:06:02,327
nil, And I need to make sure that the accumulator is also
零,我需要确保蓄电池也

1267
01:06:02,395 --> 01:06:05,463
not nil, okay? So if those two things aren't true,
不是零,好吗?

1268
01:06:05,532 --> 01:06:06,899
I don't really want to be
我不真的想要

1269
01:06:06,967 --> 01:06:08,967
doing this line of code right here,
做这行代码,

1270
01:06:09,035 --> 01:06:11,737
right? So I'm performing it, I get the results and
对吧?

1271
01:06:11,806 --> 01:06:16,141
I'm going to put that in my accumulator, okay?
我要把我的蓄电池,好吗?

1272
01:06:16,210 --> 01:06:21,146
So my accumulator is no longer nil, why is this happening?
所以我的蓄电池不再是零,为什么会这样?

1273
01:06:21,215 --> 01:06:24,716
It's the third time, mutating, all right, excellent,
这是第三次,变异,好,很好,

1274
01:06:24,785 --> 01:06:28,153
I love it when people catch on real quick, So, yeah, that
我爱它当人们明白真正的快,所以,是的,这

1275
01:06:28,222 --> 01:06:30,288
needs to be mutating, cuz this is changing the accumulator,
需要变异,因为这是改变蓄电池,

1276
01:06:30,357 --> 01:06:33,325
So it's modifying the internal state of the calculator brain,
这是修改计算器大脑的内部状态,

1277
01:06:33,394 --> 01:06:36,828
Now, the other thing is no longer am I in the middle
现在,不再另一件事是我在中间

1278
01:06:36,897 --> 01:06:39,231
of a pendingBinaryOperation, so I have to set that to nil,
pendingBinaryOperation,所以我必须设置为零,

1279
01:06:40,468 --> 01:06:42,900
Okay, cuz I wanna be consistent in all my
好吧,因为我想在我保持一致

1280
01:06:42,969 --> 01:06:45,604
code that when that's nil, I'm not in the middle of a pending
零的代码时,我不是在中间的等待

1281
01:06:45,673 --> 01:06:49,608
operation, I just had the three equals, okay,
操作,我只有三个=,好吧,

1282
01:06:49,677 --> 01:06:53,945
everybody set? Now, I told you I didn't like pbo as a name,
每个人都准备好了吗?

1283
01:06:54,014 --> 01:06:56,648
It's a bad name, okay? Someone looking at it would have to go
这是一个糟糕的名字,好吗?

1284
01:06:56,717 --> 01:06:58,316
look at the declaration to figure out it,
看《宣言》指出,

1285
01:06:58,385 --> 01:07:01,386
A better name here would be pendingBinaryOperation, so
一个更好的名字就是pendingBinaryOperation,所以

1286
01:07:01,455 --> 01:07:04,522
I'm gonna change it to that, And here's how you can change
我要改变它,这是如何变化的

1287
01:07:04,591 --> 01:07:07,058
the name of something all throughout the context
所有的东西在整个上下文的名称

1288
01:07:07,127 --> 01:07:08,760
that it's in, You just mouse over it,
的,你只是鼠标,

1289
01:07:08,829 --> 01:07:10,395
I haven't clicked on it, I moused over it,
我没有点击它,我滑过去,

1290
01:07:10,464 --> 01:07:13,598
You see that little arrow that appears? If you click on that
你看到那个小箭头出现?

1291
01:07:13,667 --> 01:07:17,001
you get a menu and you can say, Edit All in Scope, And
你得到一个菜单,你可以说,编辑都在范围和

1292
01:07:17,070 --> 01:07:22,674
now when you change this, it's changing it everywhere, Okay,
现在当你改变,改变它,好吧,

1293
01:07:22,742 --> 01:07:25,077
so I changed it from pbo to PendingBinaryOperation,
所以我改变了它从pbo PendingBinaryOperation,

1294
01:07:25,145 --> 01:07:27,946
You can see why I did that, because I didn't want
你可以看到我为什么这么做,因为我不想

1295
01:07:28,015 --> 01:07:31,416
the wrapping to happen when we were first doing it, okay?
包装发生当我们第一次做,好吗?

1296
01:07:31,485 --> 01:07:34,085
So that's it, that's all we need to do for
就是这样,这就是我们要做的

1297
01:07:34,154 --> 01:07:36,721
our little Pending BinaryOperation, so
我们的小等待BinaryOperation,所以

1298
01:07:36,790 --> 01:07:40,626
let's go ahead and add some pending, some binary, so let'a
让我们添加一些等待,一些二进制,萨那

1299
01:07:40,694 --> 01:07:43,928
add some binary operations to our UI, In fact, I'm going
添加一些二进制操作我们的UI,事实上,我走了

1300
01:07:43,997 --> 01:07:46,264
to add a few that we don't even have in our table yet,
添加一些我们没有在我们的表,

1301
01:07:46,333 --> 01:07:51,003
So let's do times, come up in the space,
让我们来做次,出现在空间,

1302
01:07:51,071 --> 01:07:54,839
Yeah, so here's times, but I'm also going to do the other
是的,这是次,但我也要做

1303
01:07:54,908 --> 01:07:58,476
ones here divide and plus and it's just so we don't have to
分而加上的,只是我们没有

1304
01:07:58,545 --> 01:08:03,148
come back here again to do that, So there's divide, and
再次回到这里,所以有分歧

1305
01:08:03,216 --> 01:08:08,120
that there, I'll do another one, do plus and
有,我会做另一个,加和

1306
01:08:08,189 --> 01:08:13,491
minus here, So I'm doing command control space,
-在这里,所以我在做命令控制空间,

1307
01:08:13,560 --> 01:08:17,729
I guess, to get this little emojis and
我想,这个小emojis和

1308
01:08:17,798 --> 01:08:23,769
symbols thing and a plus, okay?
符号的事情和a +,好吗?

1309
01:08:23,837 --> 01:08:28,607
And we need one other thing, equals, gotta have an equals
我们需要另一件事,等于,要有一个平等的

1310
01:08:28,676 --> 01:08:32,844
button, So we'll put that down there, okay? So now we only
按钮,我们会把它放下,好吗?

1311
01:08:32,913 --> 01:08:35,580
have times, so times is the only one that should work but
有次,所以时间是唯一一个但应该工作吗

1312
01:08:35,649 --> 01:08:38,450
let's see, Actually I'm gonna bring back that code so
看一下,其实我要带回代码

1313
01:08:38,518 --> 01:08:42,520
you can see it at the same time, It's hard to see it all
你可以看到它在同一时间,很难看到这一切

1314
01:08:42,589 --> 01:08:46,658
at once, but, All right here we go, okay?
一次,但是,好了好了,好吗?

1315
01:08:46,726 --> 01:08:50,161
4 square root, that's still working, pi, still working,
4的平方根,这仍然是工作,π,仍然工作,

1316
01:08:50,230 --> 01:08:56,201
How about 8 times 6 equals, wahoo, square root?
8 * 6 =怎么样,火树平方根吗?

1317
01:08:56,269 --> 01:09:00,939
Nice, okay, so times is working there beautifully,
好,好,乘以正在那里漂亮,

1318
01:09:01,008 --> 01:09:03,575
Now the only thing is, we have to do divide and
现在唯一的问题是,我们必须分而做

1319
01:09:03,644 --> 01:09:06,478
all that, so I guess what I have to do is,
这一切,所以我想我要做的是什么,

1320
01:09:06,547 --> 01:09:09,747
I go create this four times, And I'm gonna have to go
我去创建这个四次,我得走了

1321
01:09:09,816 --> 01:09:14,720
here again and Ctrl+Space again, we'll do divide, And
这里又再次Ctrl + Space,我们会分裂

1322
01:09:14,788 --> 01:09:19,324
we'll go here and Ctrl+Space and we'll do plus, And
我们就去这里,Ctrl + Space,我们会加上,和

1323
01:09:19,392 --> 01:09:23,361
then we're gonna go here and we'll do command, space, and
然后我们会去这里,我们会做指挥,空间,

1324
01:09:23,430 --> 01:09:26,898
we'll do minus, okay? Now, am I gonna have to write,
我们会做-,好吗?

1325
01:09:26,967 --> 01:09:29,467
write a method divide and go up here and
写一个方法分而在这里

1326
01:09:29,536 --> 01:09:32,871
copy and paste this and do one with divide? You know,
复制和粘贴这有分歧吗?

1327
01:09:32,939 --> 01:09:35,674
if I have to do that, all of a sudden, I'm feeling like,
如果我必须这样做,突然间,我感觉,

1328
01:09:35,743 --> 01:09:38,210
this whole table business really didn't buy me that
整个表业务真的不给我买

1329
01:09:38,278 --> 01:09:41,313
much, right? Cuz I'm still having to create a method for
多,对吧?

1330
01:09:41,381 --> 01:09:44,082
every single binary operation I want to do? I mean, for
每一个二进制操作我想做什么?

1331
01:09:44,151 --> 01:09:47,085
unary operations it was nice because I had all these built
一元操作很不错,因为我有这些了

1332
01:09:47,153 --> 01:09:50,388
in ones, I did have to make this one method, Yeah, I can
的,我有这个方法,是的,我能

1333
01:09:50,457 --> 01:09:52,958
even see with unary operations I wanna create a bunch more
即使看到一元操作我想创建一个群

1334
01:09:53,027 --> 01:09:54,826
and I'm having to create these other functions,
我需要创建这些其他功能,

1335
01:09:54,895 --> 01:09:56,795
It's not really working out for me,
这对我来说并不是真正的工作,

1336
01:09:56,864 --> 01:10:00,932
Okay, so how are we gonna fix this? Well, we're gonna use
好的,那么我们要如何解决这个问题?

1337
01:10:01,001 --> 01:10:04,736
a feature in Swift, which is really powerful,
迅速的特征,这是强大的,

1338
01:10:04,805 --> 01:10:06,204
And you're gonna have to get used to it,
你必须要去适应它,

1339
01:10:06,273 --> 01:10:07,706
cuz it's not in a lot of other languages,
因为这不是在很多其他语言,

1340
01:10:07,775 --> 01:10:08,574
It is in some other languages,
这是在其他语言中,

1341
01:10:08,642 --> 01:10:09,975
I don't wanna make it sound like it's not around,
我不想让它听起来像它不是,

1342
01:10:10,043 --> 01:10:13,078
it's definitely around, But may not be something you've
这是肯定,但可能不是你的东西

1343
01:10:13,147 --> 01:10:16,882
used in any languages you've used and it's called closures,
用在任何语言你使用,它叫做闭包,

1344
01:10:16,951 --> 01:10:18,783
Okay, how many people know what a closure is,
好的,有多少人知道什么是一个闭包,

1345
01:10:18,852 --> 01:10:19,651
have heard that before?
以前听说过吗?

1346
01:10:19,719 --> 01:10:24,556
See, almost none of you, so a closure is a function
你看,几乎没有,所以一个闭包是一个函数

1347
01:10:24,624 --> 01:10:29,394
embedded right in line of your code, okay? And so,
嵌入在代码行,好吗?

1348
01:10:29,463 --> 01:10:33,665
we can actually take multiply right here, select its code,
我们可以把用在这里,选择它的代码,

1349
01:10:33,734 --> 01:10:38,737
I'm gonna cut it, go down here to where I used it and
我会把它,去这里,我用它

1350
01:10:38,805 --> 01:10:41,973
paste it in there, Now if didn't quite work,
粘贴在这里,如果没有工作,

1351
01:10:42,042 --> 01:10:45,744
there's two things we need to do, One, this open curly brace
我们需要做两件事,一,这花括号

1352
01:10:45,813 --> 01:10:50,348
needs to be at the beginning, So, we're going to
需要在一开始,所以,我们要

1353
01:10:50,417 --> 01:10:54,453
replace this open curly brace with the keyword in, and
这花括号替换关键字,和

1354
01:10:54,522 --> 01:10:56,855
put the curly brace at the beginning, So
初把花括号

1355
01:10:56,923 --> 01:10:59,691
that's how you take a function and put it right in line,
这就是你把一个函数是正确的,

1356
01:10:59,760 --> 01:11:02,427
Just literally copy and paste to write in there,
只是随便复制粘贴来写,

1357
01:11:02,496 --> 01:11:05,997
Change the curly brace to in and move it to the beginning,
改变花括号,并将它移动到开始,

1358
01:11:06,066 --> 01:11:09,635
okay, got that? So now we don't even need multiply,
好吧,明白了吗?

1359
01:11:09,703 --> 01:11:13,839
all gone, Now this doesn't look much better,
都走了,现在看起来不更好,

1360
01:11:15,242 --> 01:11:17,742
It's still a lot of typing stuff in, but
它仍然是很多类型的东西,但是

1361
01:11:17,811 --> 01:11:24,015
let's use Swift's inference of type to make this a lot nicer,
让我们用斯威夫特的推理类型的让这个好很多,

1362
01:11:24,084 --> 01:11:29,288
Swift knows that this, right here is this,
迅速知道这,就是这个,

1363
01:11:29,356 --> 01:11:33,358
the associated value of that type, So it knows that this
相关的值的类型,所以它知道这个

1364
01:11:33,426 --> 01:11:36,261
down here is a function that takes two doubles and
下面是一个函数,它接受两个双打和

1365
01:11:36,330 --> 01:11:40,298
returns a double, So we don't need these types right here,
返回一个的两倍,所以我们不需要这些,

1366
01:11:40,367 --> 01:11:43,134
get rid of those, Okay,
摆脱那些,好吧,

1367
01:11:43,203 --> 01:11:45,037
now it's starting to look better, In fact,
现在开始更好看,事实上,

1368
01:11:45,105 --> 01:11:49,908
maybe if I go here and put some things on the same line,
如果我去这里,把一些事情在同一行,

1369
01:11:53,480 --> 01:11:56,615
Yeah, now I'm liking it, okay, But we can do even better than
是的,现在我喜欢它,但我们可以做得更好

1370
01:11:56,684 --> 01:12:00,953
this, Swift also knows that this returns something,
斯威夫特也知道这回报,这

1371
01:12:01,021 --> 01:12:05,424
So we don't overturn, okay, Swift also will let you have
所以我们不推翻,斯威夫特也将给你

1372
01:12:05,492 --> 01:12:09,594
any number of arguments you want, Called $0, $1, $2 $3,
你想要的任意数量的参数,名为$ 0 $ 1,$ 2 $ 3,

1373
01:12:09,663 --> 01:12:12,864
for however how many, So I don't need that or that,
然而有多少,所以我不需要,或者,

1374
01:12:12,932 --> 01:12:17,770
I can say $0 times $1,
我可以说0 * 1美元,

1375
01:12:19,807 --> 01:12:24,409
Okay, now I'm winning, Now,
好的,现在我赢了,现在,

1376
01:12:24,477 --> 01:12:27,513
the essentials of what is going on here is right there,
这是怎么回事的要点是,

1377
01:12:27,581 --> 01:12:29,481
And there's no extraneous types and
没有多余的类型和

1378
01:12:29,550 --> 01:12:31,983
all that business, And of course, that means for
所有的业务,当然,这意味着

1379
01:12:32,052 --> 01:12:36,087
these other cases like divide, I can say divide,
这些其他情况下像分裂,我可以说,

1380
01:12:36,156 --> 01:12:40,992
And for add, here I can see plus, and for subtract,
添加,在这里我可以看到加,减,

1381
01:12:41,061 --> 01:12:45,163
I can do minus, even for our friend change sign right here,
我可以做-,甚至对我们的朋友改变符号,

1382
01:12:45,232 --> 01:12:49,101
Okay, we can take this copy it paste,
好了,我们可以把这个复制粘贴,

1383
01:12:49,169 --> 01:12:54,506
get rid of all this junk because this is just -$0,
摆脱所有这些垃圾,因为这是- 0美元

1384
01:12:54,574 --> 01:13:01,479
okay? So, this closures allow you to do this thing where
好吧?

1385
01:13:01,548 --> 01:13:04,749
you get the essentials of what you're doing, right in there
你得到的必需品,你在做什么,对吧

1386
01:13:04,818 --> 01:13:07,419
in line, So, you're not having to go look at some other
,所以,你不必去看一些其他的

1387
01:13:07,488 --> 01:13:09,788
method somewhere like changeSign up here,
方法在某个地方像changeSign,

1388
01:13:09,857 --> 01:13:13,558
The other thing closures allow you to do, is to pass off to
另一个闭包允许你做的是,通过去

1389
01:13:13,627 --> 01:13:18,296
methods some piece of code to execute if something fails,
方法的代码执行如果失败,

1390
01:13:18,365 --> 01:13:21,966
or when something completes, Or do this and
当事情完成后,或者这样做

1391
01:13:22,035 --> 01:13:24,636
animate it, while you're doing it, for example, You're gonna
动画,当你这样做,例如,你会

1392
01:13:24,705 --> 01:13:27,439
see API like that, So, being able to pass these methods
看到这样的API,所以,能够通过这些方法

1393
01:13:27,507 --> 01:13:31,276
around, you're gonna see, Really makes for great, great
你会看到,真的是伟大的,伟大的

1394
01:13:31,344 --> 01:13:34,145
API, So, you're just seeing the simplest possible use of
API,所以,你只是看到最简单的使用

1395
01:13:34,214 --> 01:13:37,448
it here, We just using as the associated value, but imagine
在这里,我们只使用相关的值,但想象

1396
01:13:37,517 --> 01:13:40,084
it as function, parameters and things like that, It's,
这是函数,参数之类的东西,,

1397
01:13:40,153 --> 01:13:43,922
it's pretty incredible, Okay, so let's go see if that works,
很不可思议的,好吧,让我们去看看效果如何,

1398
01:13:52,166 --> 01:13:57,001
All right, 4 x 5 = 20, square root, cosine,
好吧,4 x 5 = 20,平方根,余弦,

1399
01:13:57,070 --> 01:14:03,074
change sign, pi, cosine, this all working beautifully,
改变符号,π,cos,这都工作得很出色,

1400
01:14:03,143 --> 01:14:06,278
And now, we can add as many new operations as we want,
现在,我们可以添加尽可能多的新操作,

1401
01:14:06,347 --> 01:14:10,715
with one line each, okay, So, you see how I built a struct
每一行,好的,所以,你看看我建了一个结构体

1402
01:14:10,784 --> 01:14:13,385
here that's extensible without having to do sub-classing, and
这是可扩展的,而不必做生成子类,和

1403
01:14:13,453 --> 01:14:16,054
all that stuff, I can just add thing, and I could even go
所有的东西,我可以添加的东西,我甚至可以去

1404
01:14:16,122 --> 01:14:19,791
further and make this public, If I make this operations
进一步公开这个,如果我把这个操作

1405
01:14:19,860 --> 01:14:23,561
table public, I also have to make operation public,
表,我也不得不公开操作,

1406
01:14:23,630 --> 01:14:27,666
then other people can get my calculator brain int and
然后别人就可以让我的大脑int和计算器

1407
01:14:27,735 --> 01:14:31,603
add operations to it, okay? So very,
添加操作,好吗?

1408
01:14:31,671 --> 01:14:36,140
very sensible, not requiring any subclassing whatsoever,
非常明智的,不需要任何子类化,

1409
01:14:36,209 --> 01:14:38,577
So, structs can often be just as good,
因此,结构常常可以一样好,

1410
01:14:38,645 --> 01:14:41,547
if not a little bit better design point for
如果没有一点更好的设计点

1411
01:14:41,615 --> 01:14:45,851
classes, All right, the last thing that I wanna do here,
类,好吧,我想做的最后一件事,

1412
01:14:45,919 --> 01:14:50,955
Let's go back to our simulator, Is talk about
让我们回到我们的模拟器,谈论

1413
01:14:51,024 --> 01:14:54,726
the layout of the UI, You see I have this layout right here,
界面的布局,你可以看到我有这里的布局,

1414
01:14:54,795 --> 01:14:57,662
Let's look what happens if I rotate this into landscape
让我们看看发生了什么如果我旋转这个格局

1415
01:14:57,731 --> 01:15:01,166
mode, So, I'm gonna go up here in the simulator, and
模式,所以,我要在模拟器上,和

1416
01:15:01,234 --> 01:15:04,870
go to Hardware, Rotate Left, Okay, my calculator is
去硬件、左旋转,好吧,我的计算器

1417
01:15:04,938 --> 01:15:08,507
now completely unusable, Okay, cuz there's no equals, so
现在完全无法使用,因为没有=,

1418
01:15:08,575 --> 01:15:10,909
I can't even do five times three equals, right? So
我甚至不能做五乘以三等于,对吧?

1419
01:15:10,977 --> 01:15:13,411
it's completely useless, I guess I can still do pi,
它是完全无用的,我想我仍然可以做π,

1420
01:15:13,480 --> 01:15:16,247
mm, but it's clear that's not what you want, right?
毫米,但很明显,不是你想要的,对吧?

1421
01:15:16,316 --> 01:15:20,652
When you rotate, you wanna use that space in that way, okay?
当你旋转时,你想用这个空间,好吗?

1422
01:15:20,721 --> 01:15:23,555
And I promised you we were gonna build a UI that would
我答应你我们会建立一个UI

1423
01:15:23,624 --> 01:15:24,789
work in all those things, and, in fact,
在所有这些东西,事实上,

1424
01:15:24,858 --> 01:15:28,127
we're gonna do that right now, Let's go back to our UI,
我们要做的,现在,让我们回到我们的UI,

1425
01:15:28,195 --> 01:15:31,063
and doing this is not gonna require any change to
而这样做是不需要任何改变

1426
01:15:31,131 --> 01:15:33,098
our controller or our model, Okay,
我们的控制器或我们的模型,

1427
01:15:33,166 --> 01:15:35,734
this is purely something we're gonna do in the view, and
这纯粹是我们要做的在视图中,和

1428
01:15:35,802 --> 01:15:38,837
we're gonna do it with this business up down here, Okay,
我们要做这个业务了,好吧,

1429
01:15:38,906 --> 01:15:41,840
this multiple phones that we'll be able to click here,
这多个手机,我们就可以点击这里,

1430
01:15:41,909 --> 01:15:43,575
and see how things look in all these different
看看看看所有这些不同的东西

1431
01:15:43,644 --> 01:15:46,811
orientations right here, And out basic strategy
方向,基本策略

1432
01:15:46,880 --> 01:15:51,049
is we're gonna stack all these buttons into rows, and then
所有这些按钮是我们将堆栈到行,然后呢

1433
01:15:51,118 --> 01:15:54,953
we're gonna stack all those rows on top of each other,
我们要彼此堆栈之上的那些行,

1434
01:15:55,021 --> 01:15:58,257
And then we're gonna stack that with the display, to make
然后我们会显示堆栈,

1435
01:15:58,325 --> 01:16:02,294
this kind of block that has our UI, Then we're gonna tie
这种块,我们的UI,那么我们将领带

1436
01:16:02,362 --> 01:16:06,698
the edges of that block, to the edges of the device, So,
块的边缘,边缘的设备,因此,

1437
01:16:06,767 --> 01:16:10,636
that as the device changes, that block of stuff, gets
随着设备的变化,块的东西,

1438
01:16:10,704 --> 01:16:13,939
stretched out, or whatever, And the stuff inside,
伸出,之类的,里面的东西,

1439
01:16:14,007 --> 01:16:17,142
is gonna automatically now how to resize the buttons and
现在会自动按钮和如何调整

1440
01:16:17,210 --> 01:16:20,112
stuff to lay out, Okay, so that's all that we need to do
的东西,好了,这就是我们需要做的一切

1441
01:16:20,180 --> 01:16:23,214
to make that happen, To have nice rows and columns here,
做到这一点,这里有漂亮的行和列,

1442
01:16:23,283 --> 01:16:25,984
I'm gonna add one more button which you need for
我要你需要的加多一颗钮扣

1443
01:16:26,052 --> 01:16:29,487
your homework anyway, Which is a dot button, One of your
你的家庭作业,这是一个点按钮,你的一个

1444
01:16:29,556 --> 01:16:33,324
homework assignment items, is to make floating point input
作业项目,是使浮点输入

1445
01:16:33,393 --> 01:16:35,727
possible, This is already a floating point calculator,
可能,这已经是一个浮点计算器,

1446
01:16:35,796 --> 01:16:39,431
I can say 4, 45, Well, I can't type here, sorry,
我可以说4,45,我这里打不了,对不起,

1447
01:16:39,500 --> 01:16:41,699
But I can type 45 and hit square root, And
但我可以类型45和平方根,和

1448
01:16:41,768 --> 01:16:43,902
it would give me a floating point number, right?
它会给我一个浮点数,对吧?

1449
01:16:43,971 --> 01:16:45,837
But you can't enter any floating point numbers,
但是你不能输入任何浮点数,

1450
01:16:45,906 --> 01:16:47,639
'cuz there's no dot, right? So,
因为没有点,对吗?

1451
01:16:47,708 --> 01:16:48,506
that's part of your assignment,
这是你的任务的一部分,

1452
01:16:48,575 --> 01:16:51,710
So, I'll put that in there for you, Okay, so now,
所以,我帮你把它放在那里,好了,现在,

1453
01:16:51,779 --> 01:16:55,614
I'm gonna take this row, And I'm gonna put it into a stack,
我要把这一行,我要把它放到一个堆栈,

1454
01:16:55,682 --> 01:16:58,116
It's gonna be a horizontal stack on its side, And you do
它会是一个水平叠加,和你

1455
01:16:58,185 --> 01:17:03,922
that up here with editor, Embed in Stack View, okay?
上面的编辑器中,嵌入在堆栈视图中,好吗?

1456
01:17:03,990 --> 01:17:07,559
So, when I do that, see, it stacks them up horizontally,
所以,当我这样做,看,它栈水平,

1457
01:17:07,627 --> 01:17:10,762
And I can inspect that stack, it's selected right here,
我可以检查堆栈,选择在这里,

1458
01:17:10,830 --> 01:17:14,065
And you can see Stack View right there, it's horizontal,
你可以看到堆栈视图,它是水平的,

1459
01:17:14,134 --> 01:17:17,902
I'm gonna put some spacing in there, 10 points of spacing,
我要把一些间隔,间隔10分,

1460
01:17:17,971 --> 01:17:20,872
I'm also gonna make sure, that they're equally spaced,
我也要确保,他们是等距的,

1461
01:17:20,941 --> 01:17:24,142
So, I want each of the squares in there to be the same width,
所以,我希望每个广场上有相同的宽度,

1462
01:17:24,211 --> 01:17:26,979
All right, so same thing here, Let's go this one,
一样好,所以在这里,我们去这一个,

1463
01:17:27,047 --> 01:17:29,047
Now, there's actually another way besides going up here,
现在,这里是另一种方式除了上升,

1464
01:17:29,115 --> 01:17:31,883
editor, embed in, There's a button right here for it, So
编辑器中,嵌入,这里有个按钮,

1465
01:17:31,952 --> 01:17:34,119
common, there's a button right there, Embed in Stack,
常见的,有一个按钮,嵌入在堆栈,

1466
01:17:34,187 --> 01:17:38,090
so boom, I'll do that, Again, I'll put a space in here,
因此繁荣,我会这样做,再一次,我把一个空间在这里,

1467
01:17:38,158 --> 01:17:41,326
Notice that the cosine button is wider than the 1, 2, 3,
注意,cos按钮是更广泛的比1,2,3,

1468
01:17:41,394 --> 01:17:43,728
So, I'm gonna say fill equally and
所以,我同样会说填补

1469
01:17:43,797 --> 01:17:46,265
make them all the same width again,
让他们都是一样的宽度,

1470
01:17:49,269 --> 01:17:53,772
Oops, sorry, again, so we'll do 10 and
哦,不好意思,再一次,所以我们要做10

1471
01:17:53,841 --> 01:17:58,343
fill equally, Same thing here,
同样,这里也一样,

1472
01:17:58,411 --> 01:18:02,314
stack, Fill equally, 10 and we'll stack this one,
堆栈,填补同样,10和我们将堆栈,

1473
01:18:07,887 --> 01:18:12,624
Oops, dammit, Okay, now I'm gonna take these horizontal
哦,该死的,好吧,现在我要把这些水平

1474
01:18:12,693 --> 01:18:16,194
stacks, These five horizontal and stack them vertically, So,
堆栈,这五个水平和垂直堆栈他们,所以,

1475
01:18:16,263 --> 01:18:19,731
I'm gonna embed, Notice that it's pretty smart,
我要嵌入,注意,它很聪明,

1476
01:18:19,800 --> 01:18:20,965
It noticed they were above each other so
注意到他们彼此所以上空

1477
01:18:21,034 --> 01:18:23,301
it would automatically put it in a vertical stack, But,
它就会自动把它在一个垂直堆栈,但是,

1478
01:18:23,370 --> 01:18:25,837
it pushed them all over to the left in the stack, and I
都把他们留在堆栈,和我

1479
01:18:25,906 --> 01:18:29,107
want them to spread out across the stack, So, I'm gonna have
想让他们分散在整个堆栈,所以,我要

1480
01:18:29,176 --> 01:18:34,179
the alignment here, instead of leading, be fill, and
这里的对齐,而不是领导,被填满,

1481
01:18:34,247 --> 01:18:36,882
that's gonna fill the whole width, And of course I want
会填满整个宽度,当然,我想要的

1482
01:18:36,950 --> 01:18:39,718
spacing here as well, so we'll do that, So look at this,
间距在这里,所以我们要做的,所以看这个,

1483
01:18:39,787 --> 01:18:42,553
I got this beautiful keyboard, keypad right here for
我得到这个美丽的键盘,键盘在这里

1484
01:18:42,622 --> 01:18:47,292
my calculator, Now, I'm gonna hook that up to this display,
计算器,现在,我要钩,这显示,

1485
01:18:47,361 --> 01:18:48,760
I'm just gonna select them both, and
我要选择它们,

1486
01:18:48,829 --> 01:18:52,865
say stack them, Okay, puts them into a stack, The left
堆栈他们说,好吧,将它们放置到一个堆栈,左边

1487
01:18:52,933 --> 01:18:55,267
line aligned it again, leading aligned it there so
行排列一遍,主要有所以保持一致

1488
01:18:55,336 --> 01:18:59,437
I'm gonna say fill, I don't want fill equally here though,
我会说,我不希望填补同样如此,

1489
01:18:59,506 --> 01:19:02,507
Cuz if I do fill equally here, it's gonna make this display
因为如果我做填补同样在这里,它会显示

1490
01:19:02,576 --> 01:19:04,776
the same height as the whole keypad, so
整个键盘,一样的高度

1491
01:19:04,845 --> 01:19:06,344
I don't want that, So I just want fill,
我不希望这样,所以我只是想要填补,

1492
01:19:06,413 --> 01:19:08,980
I want to fill this space, but I do want the spacing here so
我想填补这一空间,但我想这里的间距

1493
01:19:09,049 --> 01:19:12,985
we'll do 10 points again, So, now that my whole UI in a nice
我们会再次10分,所以,现在我的整个界面漂亮

1494
01:19:13,053 --> 01:19:16,855
whole rectangle here, And I'm just gonna tie the edges,
整个矩形,我要领带的边缘,

1495
01:19:18,759 --> 01:19:23,996
of this UI to the edges of the device basically, okay,
这个UI的边缘设备的基本上,好吧,

1496
01:19:24,064 --> 01:19:26,898
Now, I'm gonna start here, whoops, I'm gonna start, yeah
现在,我要开始在这里,哦,我要开始,是的

1497
01:19:26,967 --> 01:19:29,601
be careful a little about that too, If you click on something
小心一点,如果你点击

1498
01:19:29,670 --> 01:19:32,470
and drag it, see you might try to drag the inner one away,
并拖动它,看到你可能会试图把内心的一个,

1499
01:19:32,539 --> 01:19:34,539
A trick for not doing that, there's two tricks,
技巧不这样做,有两个技巧,

1500
01:19:34,608 --> 01:19:39,611
One, is you can do command shift I believe it is, yeah,
一个,你可以命令转变我相信,是的,

1501
01:19:39,679 --> 01:19:41,980
Command shift will let you pick which one you want,
命令将会让你选择哪一个你想要的,

1502
01:19:42,048 --> 01:19:44,415
under the mouse, Actually it's control shift,
下鼠标,实际上是控制转变,

1503
01:19:44,484 --> 01:19:47,052
Control shift under the mouse let's you pick it, But,
控制转变下鼠标你选吧,但是,

1504
01:19:47,121 --> 01:19:49,888
another easy way is to use drag select,
另一个简单的方法是使用拖动选择,

1505
01:19:49,957 --> 01:19:52,056
to select the one you want, and then pick it up,
选择一个你想要的,然后把它捡起来,

1506
01:19:52,125 --> 01:19:56,395
Okay, so I'm gonna use the blue lines, actually, to put
好的,所以我要用蓝线,实际上,把

1507
01:19:56,463 --> 01:19:59,164
this at the proper space on the left edge and top,
在适当的左边缘和顶部空间,

1508
01:19:59,232 --> 01:20:03,435
And now I'm gonna do the magic to hook it to an edge, And
现在我要做魔法钩边,和

1509
01:20:03,504 --> 01:20:06,437
I do that with the Ctrl key, just like we did dragging into
我使用Ctrl键,就像我们做拖

1510
01:20:06,506 --> 01:20:10,308
the code, But here, I'm gonna drag from this selected thing,
代码,但在这里,我要把这个选择的事情,

1511
01:20:10,377 --> 01:20:12,344
Make sure the whole thing is selected, And
确保选中整个事情

1512
01:20:12,413 --> 01:20:16,615
Ctrl+Drag up to the top, So we can tie it to the top,
Ctrl +拖到顶部,所以我们可以把它绑在上面,

1513
01:20:16,684 --> 01:20:18,850
And when you let go, it's gonna say,
当你放手时,它会说,

1514
01:20:18,919 --> 01:20:22,053
what relationship do you want between this big box and
你想要什么关系之间这个大盒子

1515
01:20:22,122 --> 01:20:26,791
the top? And, and really it's talking about the outer edge,
顶部?

1516
01:20:26,860 --> 01:20:28,626
And you can try and make them the same width, or
你可以试着让他们相同的宽度,或

1517
01:20:28,695 --> 01:20:30,628
the same height, which really doesn't make sense here,
相同的高度,真的没有意义,

1518
01:20:30,697 --> 01:20:33,565
Or you can pin this vertical spacing to the top
或者你可以销垂直间距

1519
01:20:33,634 --> 01:20:34,532
layout guide,
布局指导,

1520
01:20:34,601 --> 01:20:37,770
So I basically pinned it to the top, And same thing here,
所以我基本上固定上山顶,这里也一样,

1521
01:20:37,838 --> 01:20:41,840
I can go to the left and pin the leading space, And
我可以去左边和销的主要空间,和

1522
01:20:41,909 --> 01:20:45,543
I can go to the right and pin, pin the trailing space, And
我可以去正确的销,销后空间,

1523
01:20:45,612 --> 01:20:50,616
I can go to the bottom and sorry, yes, the bottom, and
我可以去底部,对不起,是的,底部,

1524
01:20:50,684 --> 01:20:53,585
pin the bottom space, the vertical space in the bottom,
销空间底部,底部的垂直空间,

1525
01:20:53,654 --> 01:20:56,822
Now we're just seeing pinning it to edges, but you can use
现在我们只是看到把它的边缘,但您可以使用

1526
01:20:56,890 --> 01:21:00,058
this mechanism to Ctrl+Drag between any two elements and
这种机制Ctrl +拖动任意两个元素之间

1527
01:21:00,127 --> 01:21:03,428
say, make these two the same width, line up the left edges,
说,让这两个相同的宽度,排队左边缘,

1528
01:21:03,497 --> 01:21:04,429
line up the tops,
排队,

1529
01:21:04,498 --> 01:21:05,897
You see what I'm saying? And
你看到我在说什么吗?

1530
01:21:05,966 --> 01:21:10,102
once you have that ability to have all your items have rules
一旦你有你所有的物品有规则的能力

1531
01:21:10,170 --> 01:21:12,671
of their relation to each other, now you can imagine how
他们的相互关系,现在你可以想象

1532
01:21:12,739 --> 01:21:16,174
you can rotate the whole thing and have it all look good,
你可以旋转整个事情看起来都很好,

1533
01:21:16,243 --> 01:21:19,010
because it's following rules about what to do,
因为它是规则后要做什么,

1534
01:21:19,079 --> 01:21:22,647
Now one thing about these two pins, okay, those I pinned to
现在关于这两个别针,好吧,这些我固定

1535
01:21:22,716 --> 01:21:25,650
where I wanted them, But these two pins are not what I want,
我希望他们,但这两个别针不是我想要的,

1536
01:21:25,719 --> 01:21:28,320
It's pinning it this far from the edge, So
把它远离边缘,所以

1537
01:21:28,388 --> 01:21:30,822
how do I fix that? You can actually double-click on that,
我怎么解决这个问题?

1538
01:21:30,891 --> 01:21:32,890
If you double-click on this I-beam,
如果你双击这个工字梁,

1539
01:21:32,959 --> 01:21:36,962
it says, yes, I'm pinning this 113 points from the edge, And
它说,是的,我把这个113分的优势,和

1540
01:21:37,030 --> 01:21:40,032
you can go up here and try to pick Standard Value,
你可以在这里,选择标准的价值,

1541
01:21:40,100 --> 01:21:42,601
But that's grayed out, so we're gonna use 0,
但这是灰色的,所以我们要使用0,

1542
01:21:42,669 --> 01:21:46,104
So you almost want either Standard Value, if available,
所以你几乎要标准的价值,如果可用,

1543
01:21:46,172 --> 01:21:47,939
or 0, So in this case,
或0,所以在这种情况下,

1544
01:21:48,008 --> 01:21:52,844
0 means 0 points from this layout guide edge, okay? And
0意味着0分此布局指导,好吗?

1545
01:21:52,913 --> 01:21:55,280
same thing with this one down here, I'm gonna double-click,
一样的是下面这个,我要双击,

1546
01:21:55,349 --> 01:21:57,950
By the way, we can also see these things, okay?
顺便说一下,我们还可以看到这些东西,好吗?

1547
01:21:58,018 --> 01:22:01,386
If we select this, we can go over to the size inspector,
如果我们选择这个,我们可以去检查大小,

1548
01:22:01,455 --> 01:22:04,189
You can see all these things down at the bottom here,
你可以看到所有这些东西在底部,

1549
01:22:04,258 --> 01:22:07,492
okay, all these connections to the edges, right?
好的,所有这些连接边缘,对吧?

1550
01:22:07,561 --> 01:22:10,929
See this one's 301, So I'm gonna double-click on this
看到这一个301年的,所以我要双击

1551
01:22:10,998 --> 01:22:14,299
I-beam, and here, standard value is available, So I'm
工字梁,在这里,标准价值可用,所以我

1552
01:22:14,368 --> 01:22:17,669
gonna pick the standard value, okay? And it puts it there,
会选择标准的价值?

1553
01:22:17,737 --> 01:22:20,806
Now so they tied it to the bottom and stretched this out,
现在他们与底部延伸出来,

1554
01:22:20,874 --> 01:22:23,609
Now it didn't quite stretch out the way we wanted here,
现在没有伸出我们希望这里的方式,

1555
01:22:23,677 --> 01:22:27,545
right? So some of these, rows in the inside,
对吧?

1556
01:22:27,614 --> 01:22:30,048
we didn't get the right attributes on,
我们没有得到正确的属性,

1557
01:22:30,116 --> 01:22:32,951
So let's go back and check them all, We got fill equally,
让我们回去检查,我们得到了填充同样,

1558
01:22:33,019 --> 01:22:36,187
horizontally, and all of them, yeah? We do, right?
水平,他们所有人,是吗?

1559
01:22:36,256 --> 01:22:40,258
And how about this? Here I'm gonna use the Ctrl+Click,
和这个怎么样?

1560
01:22:40,327 --> 01:22:44,029
We'll pick this stack view, See this one, okay,
我们选择这个堆栈视图,看到这个,好吧,

1561
01:22:44,097 --> 01:22:47,499
this is this inner one, wants to also be filled equally,
这是内心,想也是同样,

1562
01:22:47,568 --> 01:22:50,769
right? We want all these rows, not including this top guy,
对吧?

1563
01:22:50,838 --> 01:22:53,338
but all these inner interior rows to be the same,
但所有这些内在内部行是一样的,

1564
01:22:53,407 --> 01:22:58,109
So I'm gonna go fill equally here to fix that,
这里我要填补同样为了解决这个问题,

1565
01:22:58,178 --> 01:23:01,447
okay? So now I have this thing that can stretch out,
好吧?

1566
01:23:01,515 --> 01:23:04,115
because it's got these stacks that have rules about
因为它有这些规则的堆栈

1567
01:23:04,184 --> 01:23:07,952
how to fill, And then I've hooked them to the edges, so
如何填补,然后我上他们的边缘,所以呢

1568
01:23:08,021 --> 01:23:11,389
that now when I switch orientations, it adjusts,
现在当我切换方向调整,

1569
01:23:11,458 --> 01:23:17,762
even if I go to a smaller device, okay? Or
即使我去一个小装置,好吗?

1570
01:23:17,831 --> 01:23:22,534
a large device, Now one thing that's
大型设备,现在一件事

1571
01:23:22,602 --> 01:23:26,004
interesting about the very smallest device, an iPhone 4,
有趣的最小设备,iPhone 4,

1572
01:23:26,072 --> 01:23:29,641
is that in this orientation, it can't fit everything, You
是在这个方向,它不能适应一切,你呢

1573
01:23:29,710 --> 01:23:34,279
see that? The display is just, it can't fit it, So this is
看到了吗?

1574
01:23:34,348 --> 01:23:36,515
why it's great to be able to see this in Interface Builder,
为什么它是伟大的在Interface Builder中能够看到这个,

1575
01:23:36,584 --> 01:23:39,517
cuz we can go back here and pick a smaller font, for
因为我们可以回到这里,选择一个较小的字体,

1576
01:23:39,586 --> 01:23:42,153
example, We can even, you know, have our font be
例子中,我们甚至可以,你知道,我们的字体

1577
01:23:42,222 --> 01:23:45,224
variable, but there's no way to have the font automatically
变量,但没有办法自动的字体

1578
01:23:45,292 --> 01:23:48,426
squinched down, unfortunately, There's no autoshrink for
皱眉——下来,不幸的是,没有autoshrink

1579
01:23:48,495 --> 01:23:51,596
buttons like there is for labels, So sorry about that,
按钮像有标签,所以很抱歉,

1580
01:23:51,665 --> 01:23:54,266
But we would pick a smaller font that would work upon all
但是我们将选择一个较小的字体,所有工作

1581
01:23:54,335 --> 01:23:57,936
of our platforms maybe, okay? All right, so we have this,
也许,我们的平台?

1582
01:23:58,005 --> 01:24:01,472
And, of course, now if we run it in the simulator, we can
当然,如果我们在模拟器上运行它,我们可以

1583
01:24:01,541 --> 01:24:05,210
rotate it in the simulator as well and see it working there,
在模拟器上旋转它,看到它在那里工作,

1584
01:24:05,278 --> 01:24:07,645
And if we had a device, we could run it on our device and
如果我们有一个设备,我们可以对我们的设备和运行它

1585
01:24:07,714 --> 01:24:09,380
do it there, So here we go, Here's our iPhone 7,
这样做,所以让我们开始,这是我们的iPhone 7,

1586
01:24:09,449 --> 01:24:12,451
7 times 9 equals, It's still working,
7 * 9 =,它仍然是工作,

1587
01:24:12,520 --> 01:24:14,586
Square root, that's good, And when we rotate,
平方根,这很好,当我们旋转,

1588
01:24:14,655 --> 01:24:16,554
by the way, I'm gonna rotate using Command key,
顺便说一下,我将使用命令键,旋转

1589
01:24:16,623 --> 01:24:19,557
Okay, Command left and right arrows, you'll see it down in
好的,命令左右箭头,你就会看到它

1590
01:24:19,626 --> 01:24:22,060
the lower left corner here, but Command Rotate,
左下角,但是命令旋转,

1591
01:24:22,129 --> 01:24:27,399
See that? Okay, so you can see we had to do very little
看到了吗?

1592
01:24:27,468 --> 01:24:30,702
to make this thing adapt, And this is a fairly simple UI,
使适应,和这是一个相当简单的UI,

1593
01:24:30,771 --> 01:24:32,938
a lot of rectangles, More complicated UI,
大量的矩形,更复杂的用户界面,

1594
01:24:33,007 --> 01:24:36,041
we'd do a little bit more, And in about week five, four or
我们做一点,在星期5,四、

1595
01:24:36,109 --> 01:24:39,611
five, I'll go into detail about how we build these, even
5、我去详细说明如何构建这些,甚至

1596
01:24:39,679 --> 01:24:42,447
for complicated UIs how we build these rotatable things,
对于复杂的ui如何构建这些可循环的东西,

1597
01:24:42,516 --> 01:24:45,951
etc, Okay, so that's it, Your homework
等好了,就是这样,你的作业

1598
01:24:46,019 --> 01:24:48,353
is basically to reproduce what I did in these first two
基本上是复制这些前两个我在什么

1599
01:24:48,422 --> 01:24:50,255
lectures and then add a couple of things,
讲座,然后添加一些东西,

1600
01:24:50,324 --> 01:24:53,391
Add a little label up there, add some buttons, change some
添加一个小标签,添加一些按钮,改变一些

1601
01:24:53,460 --> 01:24:56,662
colors, that kind of business, pretty straightforward,
颜色,这样的生意,很简单的,

1602
01:24:56,730 --> 01:24:59,497
Make it work with floating point inputs and
使它与浮点输入和合作

1603
01:24:59,566 --> 01:25:02,901
that's due next Wednesday, I'm here if you have questions,
这是因为下个星期三,我在这里,如果你有问题,

1604
01:25:02,969 --> 01:25:05,804
and I'll see you then, >> For more,
到时候见,更多> >,

1605
01:25:05,873 --> 01:25:14,379
please visit us at stanford,edu,
请访问我们在斯坦福,edu,
