1
00:00:00,401 --> 00:00:04,535
[MUSIC]
(音乐)

2
00:00:04,604 --> 00:00:07,838
Stanford University,
斯坦福大学,

3
00:00:07,907 --> 00:00:11,109
>> All right, well, welcome to Stanford CS193P,
> >好吧,好吧,欢迎来到斯坦福CS193P,

4
00:00:11,177 --> 00:00:16,980
This is Developing iOS Application, Winter of 2017,
这是开发iOS应用程序,2017年冬天,

5
00:00:17,049 --> 00:00:19,983
And the only topic for today is a big one, Core Data,
唯一的今天是一个大主题,核心数据,

6
00:00:20,052 --> 00:00:23,019
which is an object oriented database,
这是一个面向对象的数据库,

7
00:00:23,088 --> 00:00:24,821
But before I dive into this,
但在我深入之前,

8
00:00:24,889 --> 00:00:28,324
I'm actually going to revisit that demo we did last time
我要重新审视我们上次演示

9
00:00:28,393 --> 00:00:31,260
just briefly, because we ran out of time and so
只是短暂的,因为我们跑的时间

10
00:00:31,329 --> 00:00:34,262
I wasn't able to show you the refresh control,
我无法给你刷新控制,

11
00:00:34,331 --> 00:00:35,797
Now I posted the code for it, so
现在我发布的代码,所以

12
00:00:35,866 --> 00:00:38,066
I'm not gonna type all the code in here,
我不会输入所有的代码在这里,

13
00:00:38,134 --> 00:00:40,701
But I'm just gonna briefly show you
但是我要简要地告诉你

14
00:00:40,770 --> 00:00:43,270
how that refresh control worked, okay?
刷新控制是怎样工作的,好吗?

15
00:00:43,339 --> 00:00:45,171
Okay, so we missed that,
好的,我们错过了,

16
00:00:45,240 --> 00:00:47,907
So here is the app we had from last time,
这是应用程序从上次我们有,

17
00:00:47,976 --> 00:00:50,977
By the way, I have modified our app
顺便说一下,我修改了我们的应用程序

18
00:00:51,046 --> 00:00:53,045
here to change our request a little bit,
这一点,改变我们的要求

19
00:00:53,113 --> 00:00:55,347
If you remember this line of code from last time,
如果你还记得这行代码从最后一次,

20
00:00:55,416 --> 00:00:56,815
it used to just have the query,
以前只有查询,

21
00:00:56,884 --> 00:01:00,718
But I've changed it to also filter out retweets and
但是我已经改变了它也过滤掉转发

22
00:01:00,787 --> 00:01:04,188
I've also put on the safe filter, which hopefully will
我也戴上安全过滤器,这有望

23
00:01:04,257 --> 00:01:06,624
make it so that when I do these look ups,
让它这样,当我做这些,

24
00:01:06,692 --> 00:01:10,227
these sort of up looks, we don't get stuff on the screen,
这些看起来,我们没有得到的东西在屏幕上,

25
00:01:10,296 --> 00:01:12,129
you know this is a family show,
你知道这是一个家庭,

26
00:01:12,197 --> 00:01:15,331
so we don't want to see some of that stuff,
所以我们不想看到一些东西,

27
00:01:15,400 --> 00:01:17,666
Anyway, hopefully, that'll work,
无论如何,希望,可以工作,

28
00:01:17,735 --> 00:01:19,735
So let's go back here and
那么让我们回到这里

29
00:01:19,804 --> 00:01:22,571
take a look at what this looks like,
看看这是什么样子,

30
00:01:22,640 --> 00:01:24,272
There's my simulator right here,
这里有我的模拟器,

31
00:01:24,341 --> 00:01:25,273
So let's go ahead and search,
让我们继续搜索,

32
00:01:25,341 --> 00:01:29,710
Let's try Trump again and cross our fingers, all right,
让我们再次尝试Trump和交叉手指,好吧,

33
00:01:29,779 --> 00:01:34,949
So that's not, I don't see anything too terrible there,
所以这不是,我没有看到任何太可怕了,

34
00:01:35,017 --> 00:01:38,752
Okay so what we added was this UI where we can pull down,
所以我们添加这个UI可以拉下来,

35
00:01:38,821 --> 00:01:40,153
Okay and it adds more tweets,
好的,它增加了更多的推文谈及这次慈善拍卖,

36
00:01:40,221 --> 00:01:41,888
you see how it added a tweet there?
你看看它添加了一个推特吗?

37
00:01:41,957 --> 00:01:43,589
We have the second pull right there,
我们有第二个拉,

38
00:01:43,658 --> 00:01:44,724
this was with the first pull,
这是第一次拉,

39
00:01:44,792 --> 00:01:49,895
And we pull down again, no tweets this time, okay?
我们拉下来,不推这一次,好吗?

40
00:01:49,964 --> 00:01:52,431
So each time we pull down it's doing another twitter
所以每次我们拆掉做另一个twitter

41
00:01:52,499 --> 00:01:53,497
fetch, and
取回,

42
00:01:53,566 --> 00:01:57,268
may get more tweets depending if people are tweeting or not,
可能获得更多的tweet是否人发微博,

43
00:01:57,337 --> 00:01:59,503
So let's take a look at the code to do this, again,
让我们看一看代码要做到这一点,再一次,

44
00:01:59,572 --> 00:02:01,004
I posted this code, but
我发布了这段代码,但

45
00:02:01,073 --> 00:02:02,539
we'll just look at it, I'm not gonna type it all in,
我们将看看它,我不会在类型,

46
00:02:02,608 --> 00:02:04,207
we're just gonna look at it real quick,
我们要看它很快,

47
00:02:04,275 --> 00:02:07,042
First of all, let's talk about how do I get this UI where
首先,让我们谈谈我怎么得到这个UI

48
00:02:07,111 --> 00:02:11,280
we pull down and it calls a method, or whatever?
我们拉下,它调用一个方法,或任何?

49
00:02:11,349 --> 00:02:14,150
So let's go to look in our storyboard,
让我们去看看我们的故事板,

50
00:02:16,854 --> 00:02:19,787
All right, so here's our storyboard, and
好吧,这是我们的故事板

51
00:02:19,856 --> 00:02:23,691
what I did was I just selected my table view controller and
我所做的是我只是选择我的表视图控制器和

52
00:02:23,760 --> 00:02:26,193
I went down here to this refreshing,
我去下面这个让人耳目一新,

53
00:02:26,262 --> 00:02:27,360
You see that refreshing choice?
你会看到令人耳目一新的选择?

54
00:02:27,429 --> 00:02:30,864
And I changed it from disabled to enabled, and when I set it
我改变它从禁用启用,当我把它

55
00:02:30,933 --> 00:02:33,466
to enabled nothing changed here in the UI,
启用任何UI,这里发生了巨大的变化

56
00:02:33,535 --> 00:02:36,436
You can't see any spinning thing, but
你不能看到任何旋转的事情,但是

57
00:02:36,504 --> 00:02:40,072
over here in the document outline it created this
在创建这个文档大纲

58
00:02:40,141 --> 00:02:42,340
refresh control right here,
刷新控制这里,

59
00:02:42,409 --> 00:02:45,977
And so I can control drag from the document outline just as I
所以我可以控制文档大纲正如我的阻力

60
00:02:46,046 --> 00:02:47,145
can through here,
可以在这里通过,

61
00:02:47,214 --> 00:02:49,680
So all I did to make this work is I just brought up
所以我所做的这个工作是我长大的

62
00:02:49,749 --> 00:02:52,082
my controller right here,
我的控制器,

63
00:02:52,151 --> 00:02:53,784
And here's the method I did it with right here,
这是我用的方法,

64
00:02:53,853 --> 00:02:58,188
I just Ctrl dragged from the Refresh Control to this method
我刚从刷新控制Ctrl拖这个方法

65
00:02:58,256 --> 00:03:00,590
called refresh, okay?
称为刷新?

66
00:03:00,659 --> 00:03:04,360
That's all I did to, to make that happen,
这就是我所做的,让这发生,

67
00:03:04,429 --> 00:03:05,627
And inside refresh,
在刷新,

68
00:03:05,696 --> 00:03:08,363
I just called that same method I had before, searchForTweets,
我叫同样的方法之前,searchForTweets,

69
00:03:08,432 --> 00:03:10,698
This one right here, the one that search for tweets,
这一个在这里,一个搜索微博,

70
00:03:10,767 --> 00:03:12,533
And that used to look like this,
这是这个样子,

71
00:03:12,602 --> 00:03:14,368
I only changed one thing in here,
在这里我只改变一件事,

72
00:03:14,437 --> 00:03:17,805
It used to just get the twitterRequest by
过去把twitterRequest

73
00:03:17,873 --> 00:03:19,873
looking at our search term up here,
看着我们的搜索词,

74
00:03:19,942 --> 00:03:21,475
Remember this function?
还记得这个函数吗?

75
00:03:21,543 --> 00:03:25,144
And all I did was added this, which says, if
和我所做的只是增加了这个,说,如果

76
00:03:25,213 --> 00:03:29,849
the lastTwitterRequest has a newer version, then use that,
lastTwitterRequest有新版本,然后使用,

77
00:03:29,918 --> 00:03:33,319
But if it doesn't, then default back to doing to query
但如果没有,那么默认的回做查询

78
00:03:33,388 --> 00:03:35,053
request the way we used to,
要求我们使用的方式,

79
00:03:35,122 --> 00:03:37,355
The only other things that I had to do was turn the refresh
唯一的其他事情,我要做的就是把刷新

80
00:03:37,424 --> 00:03:39,524
control off, you do that with the end refreshing,
控制了,你刷新,

81
00:03:39,593 --> 00:03:42,159
So I just did that when I went back to the main queue here,
所以我就做了,当我回到这里的主要队列,

82
00:03:42,228 --> 00:03:44,328
to get my results, so I turned it off,
我的结果,所以我关闭它,

83
00:03:44,397 --> 00:03:45,562
I also turned it off if for
如果对我也关掉它

84
00:03:45,631 --> 00:03:48,265
some reason I couldn't get any request or whatsoever,
某些原因,我不能得到任何请求或,

85
00:03:48,333 --> 00:03:50,634
Okay, there's nothing in the search term field and
好的,没有什么在搜索领域

86
00:03:50,702 --> 00:03:53,002
I couldn't get a newer version of my last request,
我不能得到一个新版本的我最后的请求,

87
00:03:53,071 --> 00:03:55,771
So I just said, I'm gonna make sure that thing is not
所以我就说,不是我要确保那件事

88
00:03:55,840 --> 00:03:57,940
spinning and spinning forever,
永远旋转和旋转,

89
00:03:58,009 --> 00:03:59,374
They wanna get out of here with that,
他们想离开这里,

90
00:03:59,443 --> 00:04:02,110
And the only other thing I had to do was up here,
唯一的另一件事我要做的就是,

91
00:04:02,178 --> 00:04:05,813
when the search text changes, someone types#Stanford or
当搜索文本变化时,有人#斯坦福或类型

92
00:04:05,882 --> 00:04:09,250
something like that, I need to invalidate that last Twitter
这样,我需要最后一个Twitter失效

93
00:04:09,318 --> 00:04:12,152
request so that it's not trying to get new versions
请求,不是为了得到新版本

94
00:04:12,221 --> 00:04:13,920
of the previous one that I had,
以前的我,

95
00:04:13,989 --> 00:04:16,589
I want it to do the new one,
我想要做新的,

96
00:04:16,658 --> 00:04:20,226
And the way that I made it so that we had these little
和我做了这样的方式我们有这些小

97
00:04:20,295 --> 00:04:24,296
titles right here, see these titles two, three, four, five?
标题在这里,看到这些标题两个,三个,四个,五个?

98
00:04:24,365 --> 00:04:27,132
I implemented another UI table view data source method,
我另一个数据源中方法实现的,

99
00:04:27,201 --> 00:04:28,900
this one down here,
是下面这个,

100
00:04:28,969 --> 00:04:31,203
Called titleForHeaderInSection,
叫titleForHeaderInSection,

101
00:04:31,271 --> 00:04:33,437
I just put titles on the sections,
我把标题部分,

102
00:04:33,506 --> 00:04:36,974
Remember, each section is another pull from Twitter,
记住,每个部分是另一个来自Twitter的拉,

103
00:04:37,043 --> 00:04:38,642
And so I just have each title,
所以我只有每个标题,

104
00:04:38,711 --> 00:04:41,377
It's actually gonna be the count of things I had minus
其实要计数的事情我已经减去

105
00:04:41,446 --> 00:04:42,312
the section number,
节数,

106
00:04:42,381 --> 00:04:44,146
So the top one is section zero,
上面部分是零,

107
00:04:44,215 --> 00:04:45,814
So section zero is gonna show
所以部分会显示为零

108
00:04:45,883 --> 00:04:47,115
the number of pulls that I've made,
拉我的数量,

109
00:04:47,184 --> 00:04:48,516
tweets,count is how many pulls I made,
微博,数量是多少,

110
00:04:48,585 --> 00:04:50,151
And it's obviously gonna
这显然会

111
00:04:50,219 --> 00:04:51,853
decrement as the sections go down,
部分向下递减,

112
00:04:54,123 --> 00:04:57,391
Okay, so that's what gave us this,
好了,这就是给我们,

113
00:04:57,460 --> 00:04:58,892
And you can see that the longer we wait,
你可以看到,我们等待的时间越长,

114
00:04:58,961 --> 00:05:01,661
obviously it pulls more information,
很显然,把更多的信息。

115
00:05:01,730 --> 00:05:02,829
as tweets pile up,
随着微博的堆积,

116
00:05:04,331 --> 00:05:08,334
Okay, let's go back to our slides,
好的,让我们回到我们的幻灯片,

117
00:05:08,402 --> 00:05:10,202
All right, here we go,
好吧,我们开始吧,

118
00:05:10,271 --> 00:05:13,871
So Core Data is this big framework inside of iOS for
这是核心数据iOS的大框架内

119
00:05:13,940 --> 00:05:16,574
doing object-oriented databases,
做面向对象数据库,

120
00:05:16,643 --> 00:05:19,409
So let's talk a little bit about what that means,
让我们讨论一下这意味着什么,

121
00:05:19,478 --> 00:05:21,545
So, when do you need a database?
所以,当你需要一个数据库吗?

122
00:05:21,613 --> 00:05:23,814
Well you need a database when you have a large amount of
你需要一个当你有大量的数据库

123
00:05:23,882 --> 00:05:26,916
data, and especially if you want to kind of make queries
数据,尤其是如果你想查询

124
00:05:26,985 --> 00:05:30,153
into that data and find out things about that data and
到数据,找出数据和事情

125
00:05:30,221 --> 00:05:32,654
the relationships between all the things in there,
之间的关系的所有事情,

126
00:05:32,723 --> 00:05:34,089
You really can't do that by like,
你真的不能通过,

127
00:05:34,158 --> 00:05:36,558
taking a big dictionary or a big array and
大字典或大数组和

128
00:05:36,627 --> 00:05:39,627
searching through it, you need a database,
搜索通过它,你需要一个数据库,

129
00:05:39,696 --> 00:05:42,797
And so there's a lot of technologies for databases out
所以有很多的数据库技术

130
00:05:42,866 --> 00:05:45,766
there but most of them are not object-oriented,
但他们中的大多数并不是面向对象的,

131
00:05:45,835 --> 00:05:48,769
So we have this framework that Apple provides called
所以我们有这个框架,苹果提供了

132
00:05:48,837 --> 00:05:51,705
Core Data, it's what we call an object-oriented database
核心数据,这就是我们所说的一个面向对象的数据库

133
00:05:51,774 --> 00:05:55,108
but actually, it's really not an object-oriented database
但实际上,这真的不是一个面向对象的数据库

134
00:05:55,177 --> 00:05:56,976
on the inside,
在里面,

135
00:05:57,045 --> 00:05:59,411
It's only an object-oriented database on the outside,
这只是一个面向对象的数据库,

136
00:05:59,480 --> 00:06:01,247
The side that you look at,
你看的一面,

137
00:06:01,315 --> 00:06:04,950
Underneath, it's actually a relational database usually,
下面,它实际上是一个关系数据库通常,

138
00:06:05,018 --> 00:06:08,987
Now Core Data is designed to have any backend of storage,
现在核心数据设计有任何后端存储,

139
00:06:09,055 --> 00:06:11,589
But it's primary implementation is on top of
但它的主要实现是最重要的

140
00:06:11,657 --> 00:06:13,957
SQL which is a relational database,
SQL是一种关系数据库,

141
00:06:14,026 --> 00:06:18,061
How many people know what SQL Database is?
有多少人知道什么是SQL数据库吗?

142
00:06:18,130 --> 00:06:19,396
Okay, almost all of you, good,
好吧,几乎所有的你,很好,

143
00:06:19,464 --> 00:06:25,268
So, if we had to do databases in our iOS apps using SQL,
所以,如果我们要做iOS应用程序使用SQL数据库,

144
00:06:25,336 --> 00:06:27,870
we'd be like no, I have to learn this whole query
我们就像不,我必须了解整个查询

145
00:06:27,939 --> 00:06:29,705
language, and how am I gonna do this?
语言,我要怎么做呢?

146
00:06:29,774 --> 00:06:32,708
Not to worry, we don't have to know any SQL to use core Data,
不要担心,我们不需要知道任何SQL使用核心数据,

147
00:06:32,776 --> 00:06:35,543
No SQL whatsoever- we're just gonna purely do this
没有任何SQL——我们要完全做到这一点

148
00:06:35,612 --> 00:06:38,280
on the object side,
在对象方面,

149
00:06:38,348 --> 00:06:39,380
So how does this work?
所以这是如何工作的呢?

150
00:06:39,449 --> 00:06:40,380
How does core Data work?
核心数据是如何工作的呢?

151
00:06:40,449 --> 00:06:43,551
Well, first we're gonna create a visual mapping
首先,我们要创建一个视觉映射

152
00:06:43,619 --> 00:06:45,985
between things in our database and
在我们数据库和之间的事情

153
00:06:46,054 --> 00:06:48,688
some objects that we're gonna be able to program with
一些对象,我们要能够计划

154
00:06:48,757 --> 00:06:51,791
in our object-oriented code that we like,
我们喜欢在我们的面向对象的代码,

155
00:06:51,860 --> 00:06:54,793
And kinda roughly, it's
有点粗略,它

156
00:06:54,862 --> 00:06:58,597
the tables in the database are kinda gonna be objects,
数据库中的表都有点要对象,

157
00:06:58,666 --> 00:07:01,833
And the columns in the tables are kind of vars,
和列在表的var,

158
00:07:01,902 --> 00:07:04,069
But we don't even really care what it's doing there,
但我们甚至不关心它在做什么,

159
00:07:04,137 --> 00:07:06,737
What we're gonna focus on is this visual map,
这是我们要关注的视觉地图,

160
00:07:06,806 --> 00:07:10,607
this visual description basically of our schema,
这种视觉描述基本的模式,

161
00:07:10,676 --> 00:07:12,509
Okay, how many people know what the word schema means?
好的,有多少人知道这个词模式意味着什么吗?

162
00:07:12,578 --> 00:07:15,812
Okay, so two-thirds of you,
好的,所以你的2/3,

163
00:07:15,881 --> 00:07:18,748
So schema is basically the description of what's
所以模式基本上是描述的

164
00:07:18,816 --> 00:07:22,218
in your database, not the contents of it but how all its
在您的数据库,而不是它的内容,但其所有

165
00:07:22,287 --> 00:07:24,687
data types are and how they relate to each other, etc,
数据类型以及它们与对方,等,

166
00:07:24,756 --> 00:07:27,923
So we're gonna do all that graphically,
所以我们要做所有的图形,

167
00:07:27,992 --> 00:07:30,325
And this is what it looks like,
这就是它的样子,

168
00:07:30,394 --> 00:07:33,428
First, if I wanna use Core Data in my app,
首先,如果我想要在我的程序中使用核心数据,

169
00:07:33,497 --> 00:07:37,498
I'm almost certainly going to wanna click this button
我几乎可以肯定会想点击这个按钮

170
00:07:37,567 --> 00:07:39,366
that says Use Core Data,
说使用核心数据,

171
00:07:39,435 --> 00:07:41,869
We've seen it every time we've created an app, and we haven't
我们已经看到它每次我们已经创建了一个应用程序,我们没有

172
00:07:41,938 --> 00:07:43,870
clicked it so far, but now we are going to click it,
点击它到目前为止,但现在我们要点击它,

173
00:07:43,939 --> 00:07:45,872
And clicking Use Core Data there,
点击使用核心数据,

174
00:07:45,940 --> 00:07:48,875
is gonna create two things for us, this visual map,
会为我们创建两个事物,这种视觉地图,

175
00:07:48,943 --> 00:07:50,943
and some code in your App Delegate,
和一些代码在应用程序委托,

176
00:07:51,012 --> 00:07:52,878
And I'm gonna talk about both of those things,
我要谈论这些事情,

177
00:07:52,946 --> 00:07:54,112
Now before I go to the next slide,
在我去下一张幻灯片之前,

178
00:07:54,181 --> 00:07:56,948
notice that the name of this app is CoreDataExample,
请注意,这个应用程序的名称是CoreDataExample,

179
00:07:57,017 --> 00:07:59,317
That's the, just the name of the app that I typed in there,
的,只是应用程序,我输入的名字,

180
00:08:00,487 --> 00:08:03,386
So when I create this app, clicking that
所以当我创建这个应用程序,点击

181
00:08:03,455 --> 00:08:06,790
Use Core Data on, you'll see that it created this file,
使用核心数据,你会发现它创建这个文件,

182
00:08:06,859 --> 00:08:10,260
CoreDataExample,xcdatamodeld,
CoreDataExample xcdatamodeld,

183
00:08:10,329 --> 00:08:12,395
So it chose the name of my app as it,
所以选择了我的程序,因为它的名字,

184
00:08:12,463 --> 00:08:16,332
And this is going to be our data model, all right?
这将是我们的数据模型,对吧?

185
00:08:16,401 --> 00:08:18,433
And so we'll, we'll talk about the AppDelegate
所以我们会,我们会讨论在AppDelegate

186
00:08:18,502 --> 00:08:21,570
code that Use Core Data also generated a little bit later,
代码也使用核心数据生成一点后,

187
00:08:21,639 --> 00:08:25,473
Right now we're gonna focus on this data model file,
现在我们要关注这个数据模型文件,

188
00:08:25,542 --> 00:08:28,977
All right, but before we even do that, what happens if we
好吧,但是在我们即使这样做,如果我们发生了什么

189
00:08:29,045 --> 00:08:32,413
have an existing app and you did not click Use Core Data?
有一个现有的应用程序和你没有点击使用核心数据?

190
00:08:32,482 --> 00:08:34,748
And now you decided, hey, I wanna add core data,
现在你决定,嘿,我想添加核心数据,

191
00:08:34,817 --> 00:08:38,318
Like maybe Smashtag Assignment 5 comes out and
比如Smashtag作业5出来

192
00:08:38,386 --> 00:08:40,953
I tell you to add some Core Data to Smashtag,
我告诉你添加一些Smashtag核心数据,

193
00:08:41,022 --> 00:08:42,789
And you're like, woh, I can't go back and
和你像,哇,我不能回去

194
00:08:42,857 --> 00:08:44,690
click Use Core Data, it's too late,
点击使用核心数据,太晚了,

195
00:08:44,759 --> 00:08:47,726
So you're gonna have to create this data model file
所以你必须创建这个数据模型文件

196
00:08:47,794 --> 00:08:48,827
using new file,
使用新文件,

197
00:08:48,896 --> 00:08:51,463
So you just go to File > New > File like this,
所以你只是去File > New >这样的文件,

198
00:08:51,532 --> 00:08:52,830
You're not gonna pick any of
你不会选择任何

199
00:08:52,899 --> 00:08:54,465
the things we've picked so far,
我们已经选择了到目前为止,

200
00:08:54,533 --> 00:08:56,600
You're gonna scroll down to the section that
你会向下滚动的部分

201
00:08:56,668 --> 00:08:57,401
says Core Data,
核心数据说

202
00:08:57,469 --> 00:08:59,669
And inside there these, there's two things,
里面,有两件事,

203
00:08:59,738 --> 00:09:01,137
Data Model and Mapping Model,
数据模型和映射模型,

204
00:09:01,206 --> 00:09:04,406
And make sure you pick Data Model because that's what you
并确保你选择的数据模型,因为这就是你

205
00:09:04,475 --> 00:09:06,775
want to do here is create your data model,
现在要做的是创建数据模型,

206
00:09:06,844 --> 00:09:09,511
your schema essentially, for your database,
您的数据库模式从本质上讲,,

207
00:09:09,580 --> 00:09:11,179
It's gonna ask you what you wanna call it,
它会问你你想叫它什么,

208
00:09:11,247 --> 00:09:13,948
Now, you don't have to call this the same as the name of
现在,你不需要调用这个一样的名字

209
00:09:14,017 --> 00:09:16,484
your application like Use Core Data button does,
您的应用程序像使用核心数据按钮,

210
00:09:16,552 --> 00:09:17,584
You can call it anything you want,
你可以叫它任何你想要的,

211
00:09:17,653 --> 00:09:20,220
So here, just to be different, I've called it Model,
这里,是不同的,我称它为模型,

212
00:09:20,289 --> 00:09:21,955
it's my model,
这是我的模型,

213
00:09:22,023 --> 00:09:23,355
And by the way,
顺便说一下,

214
00:09:23,424 --> 00:09:27,994
your core data is usually the model of a lot of MVCs,
你的核心数据通常是很多mvc模型,

215
00:09:28,062 --> 00:09:31,429
Okay, a lot of MVCs, their job is going to be to display
好,很多mvc,他们的工作是将会显示

216
00:09:31,498 --> 00:09:35,167
the data in the database, and so this data model is actually
数据库中的数据,所以这些数据模型

217
00:09:35,236 --> 00:09:37,568
the MVC model as well for a lot of MVCs,
MVC模型以及MVC,

218
00:09:37,637 --> 00:09:39,737
So I'll call this one model, and
所以我会打电话给这个模型,

219
00:09:39,806 --> 00:09:42,773
you can see it created model,xedatamodeld,
你可以看到它创建模型、xedatamodeld

220
00:09:42,842 --> 00:09:46,477
So whether you get that file by doing Use Core Data or
所以,不管你被做使用核心数据或文件

221
00:09:46,545 --> 00:09:48,445
whether you get it by creating it yourself,
是否你得到它通过创建它自己,

222
00:09:48,514 --> 00:09:51,281
you're gonna have this mapping file,
你会有一个映射文件,

223
00:09:51,350 --> 00:09:54,017
Now, let me go back to that AppDelegate thing,
现在,让我们回到AppDelegate的事情,

224
00:09:54,085 --> 00:09:56,819
I said they was gonna put some code in your AppDelegate,
我说他们是要把AppDelegate一些代码,

225
00:09:56,888 --> 00:09:58,954
It's very small amount of code,
很少量的代码,

226
00:09:59,023 --> 00:10:01,089
But I wanted to show it to you right here,
但是我想告诉你,

227
00:10:01,158 --> 00:10:02,891
This is what it looks like,
这就是它的样子,

228
00:10:02,960 --> 00:10:05,794
It just creates this one var right here,
它只是创建一个var在这里,

229
00:10:07,296 --> 00:10:10,130
By the way, if you didn't do Use Core Data, of course,
顺便说一下,如果您没有使用核心数据,当然,

230
00:10:10,199 --> 00:10:12,198
you need this code in your AppDelegate,
你需要这个代码AppDelegate,

231
00:10:12,267 --> 00:10:13,799
how are you gonna get it?
你如何得到它?

232
00:10:13,868 --> 00:10:16,669
Just go create some dummy application,
去创造一些虚拟应用程序,

233
00:10:16,738 --> 00:10:19,405
Call it Foo, it doesn't really matter what you call it,
调用Foo,你叫它什么,并不重要

234
00:10:19,474 --> 00:10:21,707
Click Use Core Data when you create it and
当您创建它,点击使用核心数据

235
00:10:21,775 --> 00:10:24,610
then copy this code from that AppDelegate to here,
然后从AppDelegate这段代码复制到这里,

236
00:10:24,678 --> 00:10:27,913
Okay, the code is identical from every app,
好吧,从每一个应用程序的代码是相同的,

237
00:10:27,981 --> 00:10:31,115
The only difference between any of those things is this
这些东西的唯一区别是这样的

238
00:10:31,183 --> 00:10:32,549
one string right here,
一个字符串,

239
00:10:32,618 --> 00:10:33,384
You see that string?
你看到那个字符串?

240
00:10:33,453 --> 00:10:36,253
That's the name of that xcmodeld file, so
这就是xcmodeld文件的名称,所以

241
00:10:36,321 --> 00:10:37,520
datamodeld file,
datamodeld文件,

242
00:10:37,589 --> 00:10:39,021
So with our core data example,
所以,我们的核心数据的例子,

243
00:10:39,090 --> 00:10:41,190
this string would be CoreDataExample,
这个字符串将CoreDataExample,

244
00:10:41,259 --> 00:10:43,692
When we went back and created it on our own with new file,
当我们回去,创建自己的新文件,

245
00:10:43,761 --> 00:10:45,093
of course, we called it Model,
当然,我们称它为模型,

246
00:10:45,162 --> 00:10:49,130
So just make sure this string matches the name of the file,
所以要确保这个字符串匹配的文件的名称,

247
00:10:49,198 --> 00:10:53,100
the xcmodel datamodeld file, okay?
的xcmodel datamodeld文件,好吗?

248
00:10:53,169 --> 00:10:55,736
So that's what you need to do if you didn't do the use
这就是你需要做的如果你没有使用

249
00:10:55,805 --> 00:10:57,805
Code Data originally you are going back and
代码数据最初你会回来

250
00:10:57,874 --> 00:10:59,038
adding it- just copy and paste,
添加-只是复制粘贴,

251
00:10:59,107 --> 00:11:03,509
It's only this one var really, it does provide another thing
只有这一个var真的,它提供了另一件事

252
00:11:03,578 --> 00:11:06,946
in your AppDelegate which is a function called saveContext,
在你AppDelegate一个名为saveContext的函数,

253
00:11:07,014 --> 00:11:08,147
It's a very simple little function,
这是一个非常简单的函数,

254
00:11:08,215 --> 00:11:11,016
I'm gonna show you how you could write it yourself,
我将向您展示如何编写它自己,

255
00:11:11,085 --> 00:11:12,918
If you wanna copy it in, you can,
如果你想复制,你可以,

256
00:11:12,987 --> 00:11:16,321
Also I notice that they have applicationWillTerminate which
我也注意到,他们有applicationWillTerminate哪个

257
00:11:16,390 --> 00:11:18,790
is this application, AppDelegate method,
这个应用程序,AppDelegate方法,

258
00:11:18,858 --> 00:11:21,592
that gets called right before you get terminated or
之前你有终止或调用该方法

259
00:11:21,661 --> 00:11:24,594
you terminate it in any way and they call saveContext,
你以任何方式终止它,他们叫saveContext,

260
00:11:24,663 --> 00:11:26,129
Well, it's a kind of an idea, a good idea,
嗯,这是一种一个想法,一个好主意,

261
00:11:26,198 --> 00:11:28,198
saveContext() just saves your database,
saveContext()只是保存您的数据库,

262
00:11:28,267 --> 00:11:30,566
That's what saveContext does, all right?
这是什么saveContext ?

263
00:11:30,635 --> 00:11:33,903
So this is how you can make up if you didn't do it,
这就是你可以如果你没有这样做,

264
00:11:33,971 --> 00:11:37,139
So anyway, you can see that the only thing in here
总之,在这里你可以看到唯一

265
00:11:37,208 --> 00:11:39,641
is this lazy var persistentContainer, and
这是懒惰的var persistentContainer,

266
00:11:39,709 --> 00:11:41,209
I'm gonna talk all about persistentContainer,
我要所有谈论persistentContainer,

267
00:11:41,277 --> 00:11:43,677
because that's the thing that essentially contains
因为这是本质上的东西

268
00:11:43,746 --> 00:11:46,346
your database, all right?
您的数据库?

269
00:11:46,415 --> 00:11:48,215
But let's go back and talk about the visual map,
但让我们回过头来讨论视觉地图,

270
00:11:48,284 --> 00:11:51,084
Cuz we have to have a visual map before we can do anything
因为我们必须有一个视觉地图之前,我们可以做任何事情

271
00:11:51,153 --> 00:11:53,853
in our database because we have to have some things in
在我们的数据库,因为我们需要一些东西

272
00:11:53,922 --> 00:11:56,556
our database, some objects and things like that,
我们的数据库中,一些对象之类的东西,

273
00:11:56,625 --> 00:12:00,292
And Core database stores things in this kind of very
和核心数据库存储在这种非常

274
00:12:00,361 --> 00:12:02,027
straightforward way,
直接的方法,

275
00:12:02,095 --> 00:12:05,764
It looks very object-oriented in our code because
面向对象的代码,因为它看起来很

276
00:12:05,833 --> 00:12:08,466
in Core Data terms it's storing entities,
在核心数据的存储实体方面,

277
00:12:08,535 --> 00:12:11,235
which look like classes to our code,
像类的代码,

278
00:12:11,304 --> 00:12:14,872
Attributes, which look like vars on our classes,
属性,它看起来像var在我们的类,

279
00:12:14,940 --> 00:12:18,242
And relationship, which just look like vars that point to
和关系,这看起来就像vars指向

280
00:12:18,310 --> 00:12:22,279
other objects in the database, other entities, etc,
数据库中的其他对象,其他实体等,

281
00:12:22,348 --> 00:12:25,181
And so we're gonna use this what I'm calling a storyboard,
所以我们要用这个板我打电话什么,

282
00:12:25,250 --> 00:12:26,081
It's not, don't get confused,
它不是,不感到困惑,

283
00:12:26,150 --> 00:12:27,716
this is not a storyboard, okay?
这不是一个故事板,好吗?

284
00:12:27,785 --> 00:12:30,319
You know what a storyboard is, your Interface Builder thing,
你知道什么是故事板,你的界面构建器的事情,

285
00:12:30,387 --> 00:12:32,087
But it's kind of like a storyboard,
但它就像一个故事板,

286
00:12:32,156 --> 00:12:34,823
that's why it's in quotes for databases,
这就是为什么在引用数据库,

287
00:12:34,892 --> 00:12:37,224
It's a graphical, visual editor to create and
这是一个图形,创建和可视化编辑器

288
00:12:37,293 --> 00:12:40,427
describe all these entities, attributes and relationships,
描述所有这些实体、属性和关系,

289
00:12:40,496 --> 00:12:42,896
okay, that's what we're gonna do here,
好的,这就是我们要做的,

290
00:12:42,965 --> 00:12:45,098
So let's start by adding an entity,
让我们开始通过添加一个实体,

291
00:12:45,166 --> 00:12:48,034
Very easy, we go down to this button on the bottom here
很简单,我们去这个按钮在底部

292
00:12:48,103 --> 00:12:49,502
called Add Entity,
叫添加实体,

293
00:12:49,571 --> 00:12:51,103
Okay, to add an entity,
好了,添加一个实体,

294
00:12:51,172 --> 00:12:53,305
By the way, there's couple other things in that if you
顺便说一下,如果你有其他一些事情

295
00:12:53,374 --> 00:12:55,807
hold down on that button you'll see Add Fetch Request,
按住按钮你会看到添加获取请求,

296
00:12:55,875 --> 00:12:56,774
and Add Configuration,
并添加配置,

297
00:12:56,843 --> 00:12:58,642
I don't have time to talk about those unfortunately,
我没有时间谈论这些不幸的是,

298
00:12:58,711 --> 00:13:01,345
but especially Add Fetch Request is kind of a cool one,
特别是添加获取请求是一种很酷的一个,

299
00:13:01,414 --> 00:13:04,247
So, if you can take what I teach you here and extend it
所以,如果你可以把我在这里教你和扩展它

300
00:13:04,316 --> 00:13:07,350
by going and learning about that, that would be great,
通过学习,那将是伟大的,

301
00:13:07,419 --> 00:13:08,884
So you click Add Entity,
所以你单击Add实体,

302
00:13:08,953 --> 00:13:11,754
it creates a new entity called Entity,
它创建一个新的实体称为实体,

303
00:13:11,822 --> 00:13:13,822
Cuz it doesn't know what name you want for it yet,
因为它不知道什么名字你想要它,

304
00:13:13,891 --> 00:13:16,491
And like I say, this analogous to a class,
就像我说的,这类似于一个类,

305
00:13:16,560 --> 00:13:20,295
Now in our code we're gonna see any instances of this
现在在我们的代码我们要看到任何实例

306
00:13:20,364 --> 00:13:24,432
entity as instances of a class called NSManagedObject,
实体类的实例称为NSManagedObject

307
00:13:24,501 --> 00:13:27,235
So NSManagedObject super important in Core Data,
所以NSManagedObject超级重要的核心数据,

308
00:13:27,304 --> 00:13:29,804
It is the super class or the class of everything that
它是超类或类的东西

309
00:13:29,872 --> 00:13:32,773
comes, all these entities that come out of the database,
来了,所有这些实体的数据库,

310
00:13:32,842 --> 00:13:36,142
It's like the thing that represents them in our code,
就像在我们的代码中代表自己的东西,

311
00:13:36,211 --> 00:13:37,710
and we'll see all about that,
我们会看到,

312
00:13:37,779 --> 00:13:40,679
So for my kind of slides here,
对于我的幻灯片,

313
00:13:40,748 --> 00:13:43,715
what I'm gonna do is create a database that would have
我要做的就是创建一个数据库,

314
00:13:43,784 --> 00:13:45,384
stuff like we got from Twitter,
我们从Twitter、

315
00:13:45,453 --> 00:13:46,952
So it's gonna have tweets and
所以它会有推特和

316
00:13:47,021 --> 00:13:48,086
we're gonna have Twitter users,
我们要有Twitter用户,

317
00:13:48,155 --> 00:13:49,954
So those are gonna be two entities that we have and
这些都是要我们有两个实体

318
00:13:50,023 --> 00:13:52,223
you're gonna see eventually, we're gonna have Tweet and
你会看到最后,我们要推

319
00:13:52,292 --> 00:13:53,557
TwitterUser classes in our code and
在我们的代码和TwitterUser类

320
00:13:53,625 --> 00:13:55,258
we're gonna access vars and all that stuff,
我们要访问var和所有的东西,

321
00:13:55,327 --> 00:13:57,126
So I'm gonna rename this entity,
所以我要重命名这个实体,

322
00:13:57,195 --> 00:13:59,828
this, that I added that was defaulted to entity,
这个,我还说,违约的实体,

323
00:13:59,897 --> 00:14:02,331
I'm gonna rename it and call it Tweet,
我要重命名,称之为微博,

324
00:14:02,400 --> 00:14:04,934
So this is gonna be the first entity that I'm creating
这是第一个我在创建实体

325
00:14:05,002 --> 00:14:06,568
in the database,
在数据库中,

326
00:14:06,636 --> 00:14:08,837
Now, an entity can have attributes,
现在,一个实体可以有属性,

327
00:14:08,906 --> 00:14:11,005
Those are kind of like vars, and relationships,
这些都是有点像var,关系,

328
00:14:11,074 --> 00:14:14,108
Those are like vars that point to other entities,
那些像var指向其他实体,

329
00:14:14,177 --> 00:14:16,276
And I told you this fetched properties down at the bottom,
我告诉过你这获取属性在底部,

330
00:14:16,345 --> 00:14:17,144
I'm not gonna talk about,
我不会讲,

331
00:14:17,213 --> 00:14:19,078
Very cool, but not gonna talk about them,
很酷,但不会谈论他们,

332
00:14:19,147 --> 00:14:21,047
Not just time-wise,
不仅仅是时间,

333
00:14:21,115 --> 00:14:23,315
So let's go and add some attributes to this entity,
所以让我们去添加一些属性的实体,

334
00:14:23,384 --> 00:14:24,783
Real easy, you click this plus button,
真正的轻松,你点击这个加号按钮,

335
00:14:24,852 --> 00:14:26,284
there's also an Add Attribute button,
还有一个按钮,添加属性

336
00:14:26,353 --> 00:14:28,419
see it down in the lower right hand corner there,
看到它的右下角,

337
00:14:28,488 --> 00:14:29,954
But I'm gonna click this little plus
但是我点击这个小+

338
00:14:30,023 --> 00:14:33,290
button right there under the section called Attributes,
按钮属性章节下,

339
00:14:33,359 --> 00:14:36,059
And when I do there it adds a new attribute called attribute
当我做它添加一个新的属性称为属性

340
00:14:36,128 --> 00:14:37,927
and I'm gonna edit its name directly,
我要直接编辑它的名字,

341
00:14:37,996 --> 00:14:39,495
just like I did the entity name,
就像我做的实体名称,

342
00:14:39,564 --> 00:14:40,663
I'm gonna change this to be text,
我要改变这个文本,

343
00:14:40,732 --> 00:14:45,268
So, this is gonna be our tweet text, the 140 characters
所以,这将是我们的推文,140个字符

344
00:14:45,336 --> 00:14:49,438
of the tweet is gonna be this particular attribute,
的推特是这个特殊的属性,

345
00:14:49,506 --> 00:14:53,008
Now, notice as soon as I did that, I got an error,
现在,请注意当我这么做的时候,我得到了一个错误,

346
00:14:53,077 --> 00:14:55,476
In the corner there, this red error,
在角落里,这个红色的错误,

347
00:14:55,545 --> 00:14:56,043
And the reason for
的原因

348
00:14:56,112 --> 00:14:58,846
that is all attributes have to have a type,
这是所有属性必须有一个类型,

349
00:14:58,914 --> 00:15:01,182
They can't just be undefined type like this one is,
他们不能只是这样的未定义的类型,

350
00:15:01,250 --> 00:15:03,350
You see where it says the type is undefined,
你知道它是未定义的类型,说

351
00:15:03,419 --> 00:15:05,919
So, we need to change that to be a type,
所以,我们需要改变类型,

352
00:15:05,988 --> 00:15:08,721
And it's really easy, right there where it says undefined,
很简单,在这里表示未定义,

353
00:15:08,790 --> 00:15:10,122
We're just going to mouse down,
我们将鼠标向下,

354
00:15:10,191 --> 00:15:12,924
it's gonna bring up a menu and we can choose our type,
它会弹出一个菜单,我们可以选择类型,

355
00:15:12,993 --> 00:15:15,393
Now, these are the types we have to choose from,
现在,这些都是我们必须选择类型,

356
00:15:15,462 --> 00:15:18,663
A lot of different numeric types like 16-bit integers,
很多不同的数值类型像16位整数,

357
00:15:18,732 --> 00:15:20,164
32-bit integer, etc,
32位整数,等等,

358
00:15:20,233 --> 00:15:23,900
Doubles, floats, can a be string of course,
双打,漂浮,当然可以是字符串,

359
00:15:23,969 --> 00:15:28,605
a Boolean value, a date which is going to look like a date,
一个布尔值,一个看起来像一个日期,日期

360
00:15:28,674 --> 00:15:32,142
you know, the date struct in our code,
你知道,日期在我们的代码结构,

361
00:15:32,210 --> 00:15:35,445
And binary data which is gonna look like the data struct
和二进制数据是数据结构

362
00:15:35,513 --> 00:15:36,513
inside our code,
在我们的代码,

363
00:15:36,581 --> 00:15:39,782
So, these are gonna map to very familiar data types
因此,这些会映射到非常熟悉数据类型

364
00:15:39,851 --> 00:15:40,849
that we see,
我们看到,

365
00:15:40,918 --> 00:15:42,317
There is that one at the bottom there,
有一个在底部,

366
00:15:42,386 --> 00:15:44,919
transformable, another thing I'm not gonna talk about,
可变形的,另一件我不会谈论,

367
00:15:44,988 --> 00:15:48,322
But transformable allows you to store anything
但可变形的允许您存储任何东西

368
00:15:48,391 --> 00:15:51,592
into the database by converting it to a data, and
将它转换为一个数据到数据库中,和

369
00:15:51,661 --> 00:15:53,326
then converting it back on the way out,
然后把它回来的路上,

370
00:15:53,395 --> 00:15:54,728
And so if you pick transformable there,
所以如果你选择可变形的,

371
00:15:54,797 --> 00:15:56,729
you're gonna have to do some extra work,
你需要做一些额外的工作,

372
00:15:56,798 --> 00:15:59,599
To tell Core Data about that transformation, and that's why
告诉核心数据转换,这就是原因

373
00:15:59,668 --> 00:16:02,001
I don't really have time to tell you about, but just know
我真的没有时间告诉你,只是知道

374
00:16:02,070 --> 00:16:04,003
that if you wanted to store something like a CGRect,
如果你想储存CGRect中,

375
00:16:04,071 --> 00:16:07,539
Actually, if I was going to store a CGRect, I might use
事实上,如果我要商店CGRect中,我可能会使用

376
00:16:07,607 --> 00:16:09,841
the function, there's some function called something like
功能,有一些函数类似

377
00:16:11,344 --> 00:16:13,143
NSStringFromCGRect,
NSStringFromCGRect,

378
00:16:13,212 --> 00:16:14,278
It gives you a string, and
它给你一个字符串,和

379
00:16:14,346 --> 00:16:16,112
then there's NSCGRectFromString or
还有NSCGRectFromString或

380
00:16:16,181 --> 00:16:16,746
something like that,
类似的,

381
00:16:16,815 --> 00:16:18,047
So I'd probably store it as a string,
所以,我可能会将其存储为字符串,

382
00:16:18,115 --> 00:16:20,482
but if I had something more complicated than that,
但如果我有比这更复杂的东西,

383
00:16:20,551 --> 00:16:21,783
then I might use a transformable,
然后我可能使用一个可变化的,

384
00:16:21,852 --> 00:16:27,388
All right, these attributes here are going to be accessed,
好吧,这些属性将被访问,

385
00:16:27,457 --> 00:16:29,390
we're gonna get and set their values,
我们要获取和设置值,

386
00:16:29,459 --> 00:16:32,159
Well actually, we're not going to do this but fundamentally
实际上,我们不会这样做,但从根本上

387
00:16:32,228 --> 00:16:34,595
the way you do it is you have these two methods,
你是这两种方法,

388
00:16:34,664 --> 00:16:36,430
value(forKey) and setValue (forKey),
值(forKey)和setValue(forKey),

389
00:16:36,498 --> 00:16:38,598
And I'll talk about how we're gonna use that, but
和我将讨论我们如何使用,但是

390
00:16:38,667 --> 00:16:43,036
that's how we're gonna set and get the values on an entity,
这就是我们要设置和获取的值在一个实体,

391
00:16:43,105 --> 00:16:44,971
Notice the error went away as soon as we
我们注意到错误就走了

392
00:16:45,040 --> 00:16:47,239
gave this thing, a type,
给了这个东西,一个类型,

393
00:16:47,308 --> 00:16:50,709
So here I'm gonna add some more attributes, identifier,
这里我要添加更多属性,标识符,

394
00:16:50,777 --> 00:16:52,978
which is just some string that identifies the tweet and
这只是一些字符串标识和推特

395
00:16:53,046 --> 00:16:55,714
then created, which was when it was tweeted,
然后创建,推时,

396
00:16:55,782 --> 00:17:00,251
Notice I'm setting created's type here to be date because
注意到我在这里设置的类型创建日期,因为

397
00:17:00,320 --> 00:17:03,287
it is a date, obviously, when the thing was created,
这是一个日期,显然,当创建的,

398
00:17:03,356 --> 00:17:06,189
Now this is one way to look at our entities and attributes,
现在这是一个方法来看看我们的实体和属性,

399
00:17:06,258 --> 00:17:07,257
this kind of table form,
这种表的形式,

400
00:17:07,326 --> 00:17:09,859
But we can actually look at it in graphical form as well,
但我们可以看看它以图形化的形式,

401
00:17:09,928 --> 00:17:12,094
If you see down in the corner where it says editor style,
如果你看到在角落编辑风格,

402
00:17:12,163 --> 00:17:13,829
If I click on the other button there,
如果我点击其他按钮,

403
00:17:13,898 --> 00:17:15,965
the one that looks a little more like a graph,
一个看起来更像一个图,

404
00:17:16,033 --> 00:17:17,832
then it shows me the same thing but
然后它向我展示了同样的事情

405
00:17:17,901 --> 00:17:18,867
in this graphical form,
在这个图形的形式,

406
00:17:18,936 --> 00:17:21,335
It's even on graph paper, all right?
即使在坐标纸,好吗?

407
00:17:21,404 --> 00:17:24,105
And in this form right here we can do
我们能做在这里的形式

408
00:17:24,173 --> 00:17:25,806
all the things that we did in the other one,
所有我们在另一个,

409
00:17:25,875 --> 00:17:27,941
For example, I can still add entity here,
例如,我仍然可以添加实体,

410
00:17:28,010 --> 00:17:30,543
So I'm gonna add another entity for my Twitter User,
所以我要为我的Twitter用户,添加另一个实体

411
00:17:30,612 --> 00:17:32,244
this is people who tweet,
这是微博的人,

412
00:17:32,313 --> 00:17:34,112
And there it is, it called it entity again,
在这里,它又称它为实体,

413
00:17:34,181 --> 00:17:35,280
that's the default,
这是默认的,

414
00:17:35,349 --> 00:17:38,583
We'll set its name to be TwitterUser,
我们将设置它的名字TwitterUser,

415
00:17:38,652 --> 00:17:40,986
All right, so we now have two entities, you see on there,
好了,现在我们有两个实体,你看,

416
00:17:41,054 --> 00:17:44,289
What's kinda cool is as you drag these entities around,
酷的是当你拖动这些实体,

417
00:17:44,358 --> 00:17:47,191
this, this kind of editor, this graphical
这种编辑器,这个图形

418
00:17:47,259 --> 00:17:49,727
editor, will automatically kind of keep them spaced apart
编辑器中,将自动保持间隔分开

419
00:17:49,795 --> 00:17:50,594
from each other,
从对方,

420
00:17:50,663 --> 00:17:52,595
Which is kind of fun, especially since they're going
这是很有趣的,特别是因为他们吗

421
00:17:52,664 --> 00:17:54,497
to start having wires connecting them because
因为开始有电线连接它们

422
00:17:54,566 --> 00:17:56,332
they're going to start having relationships
他们将开始有关系

423
00:17:56,400 --> 00:17:59,668
to each other as you're going to see in a moment,
对方为你会看到在一个时刻,

424
00:17:59,737 --> 00:18:02,871
We can add attributes in this graphical style as well- you
我们可以添加属性在这个图形风格——你

425
00:18:02,939 --> 00:18:05,874
can edit those right in there just by double clicking on
可以编辑这些在那里只要双击吗

426
00:18:05,943 --> 00:18:07,809
them, change whatever you want,
改变任何你想要的,

427
00:18:07,877 --> 00:18:11,078
So, here I got a screenName, now of course I got an error
所以,在这里,我有一个屏幕名,当然我有一个错误

428
00:18:11,147 --> 00:18:14,014
again because I didn't set the type of that screenName,
因为我没有设置类型的屏幕名,

429
00:18:14,083 --> 00:18:17,350
So, in this view you set the types by bringing up
所以,在这个视图中设置类型抚养

430
00:18:17,419 --> 00:18:18,017
the inspector,
检查员,

431
00:18:18,086 --> 00:18:20,286
So you just bring up your normal inspector,
所以你只要把你的正常的检查员,

432
00:18:20,355 --> 00:18:21,553
attribute inspector,
属性检查器,

433
00:18:21,622 --> 00:18:23,755
And the, here you can see it's inspecting screenName,
这里的,你可以看到它的检查屏幕名,

434
00:18:23,824 --> 00:18:25,357
it's got the name there,
它的名字,

435
00:18:25,425 --> 00:18:27,625
There's some other things in here like transient,
有一些其他的事情在这里像瞬态,

436
00:18:27,694 --> 00:18:28,626
indexed, optional,
索引,可选的,

437
00:18:28,694 --> 00:18:31,395
By the way, that optional doesn't mean this is optional
可选的方式,并不意味着这是可选的

438
00:18:31,464 --> 00:18:33,664
like the Swift thing optional,
喜欢快速的可选的,

439
00:18:33,732 --> 00:18:37,233
This is optional like in SQL database terms, right,
这是可选的像SQL数据库而言,正确的,

440
00:18:37,302 --> 00:18:39,469
In relational database optional,
在关系数据库中可选的,

441
00:18:39,538 --> 00:18:42,004
So I'm not gonna talk about any of the database
所以我不会谈论任何数据库

442
00:18:42,073 --> 00:18:43,539
You rarely need to set any of these properties right here,
你很少需要设置这些属性,

443
00:18:43,540 --> 00:18:45,006
stuff of it,
的东西,

444
00:18:46,743 --> 00:18:47,942
But you do need to set the type,
但你需要设置类型,

445
00:18:48,011 --> 00:18:49,143
So we're not gonna talk about that, but
所以我们不会谈论,但是

446
00:18:49,211 --> 00:18:51,279
we have to set the type right here,
我们必须设置类型,

447
00:18:51,347 --> 00:18:53,280
And the screenName, of course, is a string,
和屏幕名,当然,是一个字符串,

448
00:18:53,349 --> 00:18:56,116
So I'm just gonna change it to a string,
所以我要将其更改为一个字符串,

449
00:18:56,185 --> 00:18:59,652
I'm adding another attribute to the TwitterUser,
我向TwitterUser添加另一个属性,

450
00:18:59,721 --> 00:19:03,056
this one is the name, the person's actual name,
这个是名字,人的实际名称,

451
00:19:03,125 --> 00:19:06,458
not their @ sign handle, but their actual name,
不是他们的@符号处理,但他们的实际名称,

452
00:19:06,527 --> 00:19:09,327
Now we've built a couple of entities with a bunch of
现在我们已经建立了两个实体与一群

453
00:19:09,396 --> 00:19:12,030
attributes on them, okay, and this is gonna look like
属性,好吧,这是会是什么样子

454
00:19:12,099 --> 00:19:15,767
classes with vars in our code eventually,
类与var最终我们的代码,

455
00:19:15,836 --> 00:19:19,003
But what about relationships, obviously a Tweet and
但是关系,显然一条微博

456
00:19:19,072 --> 00:19:22,774
a TwitterUser have a relationship to each other,
TwitterUser有关系,

457
00:19:22,842 --> 00:19:25,209
And to create relationships between things we just
和创造的事情我们之间的关系

458
00:19:25,278 --> 00:19:28,145
Ctrl+drag, this is our favorite gesture in Xcode and
Ctrl +拖,这是我们最喜欢的手势在Xcode中,

459
00:19:28,213 --> 00:19:28,945
we're using it again,
我们使用一遍,

460
00:19:29,013 --> 00:19:31,780
Ctrl+drag to create a relationship
Ctrl +拖动创建一个关系

461
00:19:31,849 --> 00:19:32,648
between two things,
两件事之间,

462
00:19:32,717 --> 00:19:36,151
And it actually doesn't matter which direction you Ctrl+drag,
其实无所谓哪个方向你Ctrl +拖,

463
00:19:36,220 --> 00:19:38,820
because you're creating kind of a bidirectional
因为你创造一种双向的

464
00:19:38,889 --> 00:19:40,388
relationship,
的关系,

465
00:19:40,457 --> 00:19:43,057
So here, I did Ctrl+drag, and it automatically created this
这里,我做了Ctrl +拖,自动创建

466
00:19:43,126 --> 00:19:47,829
relationship, which it called newRelationship on both sides,
双方的关系,它叫做newRelationship,

467
00:19:47,897 --> 00:19:52,766
And this relationship is essentially just gonna be
和这种关系本质上是会

468
00:19:52,835 --> 00:19:54,768
a var in our class,
我们班上一个var,

469
00:19:54,837 --> 00:19:59,071
But the var's type is either going to be the type, if it's
但var的类型是类型,如果是

470
00:19:59,140 --> 00:20:01,508
like a Tweet, you know, it's gonna be a single one, or
像一个Tweet,你知道,它会是一个,或者

471
00:20:01,576 --> 00:20:04,343
it could be an NSSet, if it's many of them,
可能是NSSet,如果是他们中的许多人,

472
00:20:04,412 --> 00:20:06,679
Like a Twitter user might have many tweets, and
像一个Twitter用户可能有很多微博,和

473
00:20:06,747 --> 00:20:08,781
I'll talk about that in a moment,
我一会儿会讲到,

474
00:20:08,849 --> 00:20:12,383
So, from a Tweet's perspective this relationship to
所以,从微博的角度来看这种关系

475
00:20:12,452 --> 00:20:14,419
a TwitterUser is the Tweeter,
TwitterUser是推特,

476
00:20:14,487 --> 00:20:16,821
The person who tweeted this tweet,
发推特的人,

477
00:20:16,889 --> 00:20:19,557
So, I'm going to change the name of this relationship on
所以,我要改变这种关系的名称

478
00:20:19,625 --> 00:20:24,027
the Tweet side to be tweeter instead of newRelationship,
推特,而不是newRelationship推一边,

479
00:20:24,095 --> 00:20:25,361
which was the default,
这是默认的,

480
00:20:25,430 --> 00:20:27,763
But, on the other, okay, so that's why I call it tweeter,
但是,另一方面,好的,这就是为什么我叫它推特,

481
00:20:27,832 --> 00:20:29,865
On the other side the TwitterUser from its
另一方面从其TwitterUser

482
00:20:29,934 --> 00:20:33,502
perspective though, okay, the relationship of the tweet is
不过,角度好,推特的关系

483
00:20:33,571 --> 00:20:35,737
the tweets that this Twitter user has tweeted,
的微博推特用户写道:,

484
00:20:35,805 --> 00:20:38,840
Okay, it's not tweeter, the Twitter user is the tweeter,
好吧,这不是推特,推特用户的推特,

485
00:20:38,909 --> 00:20:41,342
so he would never call this relationship tweeter,
所以他永远不会叫这个关系来说,

486
00:20:41,411 --> 00:20:44,277
He's gonna call this relationship tweets
他会调用这个tweet的关系

487
00:20:44,346 --> 00:20:46,213
because this is the tweet,
因为这是一条推特,

488
00:20:46,282 --> 00:20:47,748
Now notice that's plural, okay,
现在注意到复数,

489
00:20:47,816 --> 00:20:50,583
we'll talk about that in a second,
我们会讲到,

490
00:20:50,652 --> 00:20:54,186
Notice that when we do this, Xcode tracks if I'm inspecting
请注意,当我们这样做时,Xcode跟踪如果我检查

491
00:20:54,255 --> 00:20:57,423
the tweet's relationship there on the TwitterUser side,
推特的关系在TwitterUser方面,

492
00:20:57,491 --> 00:20:58,858
it knows the inverse,
它知道逆,

493
00:20:58,926 --> 00:21:00,759
It knows that tweeter goes the opposite direction,
它知道推特走相反的方向,

494
00:21:00,828 --> 00:21:02,828
there's always gonna be an inverse relationship,
总是有会成反比关系,

495
00:21:04,631 --> 00:21:07,264
So let's talk about that tweets being a plural right?
所以让我们来谈谈微博是一个复数?

496
00:21:07,333 --> 00:21:10,100
So a tweet can only have one tweeter,
所以只能有一个推特,推特

497
00:21:10,169 --> 00:21:12,002
Only one person can have tweeted it, but
只有一个人可以推,但是

498
00:21:12,070 --> 00:21:16,873
a Twitter user can tweet thousands of tweets, okay?
Twitter用户可以推成千上万的微博,好吗?

499
00:21:16,942 --> 00:21:18,474
And so that's a little different
这有点不同

500
00:21:18,542 --> 00:21:19,374
kind of relationship,
的关系,

501
00:21:19,443 --> 00:21:21,410
So how do we specify that?
那么我们如何指定吗?

502
00:21:21,479 --> 00:21:24,679
We call the tweets relationship the,
我们所说的推文的关系,

503
00:21:24,748 --> 00:21:27,915
a to many relationship because obviously the Twitter
因为许多关系显然Twitter

504
00:21:27,984 --> 00:21:29,951
user can have many tweets,
用户可以有很多微博,

505
00:21:30,019 --> 00:21:32,953
So that's called to many in database parlance, and
这是许多数据库的说法,和

506
00:21:33,022 --> 00:21:34,321
you set that right in the Inspector,
您设置的检查员,

507
00:21:34,390 --> 00:21:36,123
So you just click on that tweets and
所以你只需点击微博

508
00:21:36,192 --> 00:21:37,690
you go over here to where it says Type,
你去这里,类型,

509
00:21:37,759 --> 00:21:40,927
and instead of having it be To One you're gonna change it
相反的它是一个你会改变它

510
00:21:40,995 --> 00:21:43,962
to be To Many, okay, so now it's a to many relationship,
对许多人来说,好的,现在许多的关系,这是一个

511
00:21:44,031 --> 00:21:49,568
Right there, you can see that it's changed a little bit as,
在这里,你可以看到它的改变了一点,

512
00:21:49,637 --> 00:21:51,336
and we'll show that in a second,
我们会显示在第二个,

513
00:21:51,404 --> 00:21:54,339
But the type of this relationship now on the tweet
但现在这种关系的类型在推特上

514
00:21:54,407 --> 00:21:57,909
side is still type NSManagedObject,
方仍NSManagedObject类型,

515
00:21:57,978 --> 00:22:00,111
because it points to another entity in the database,
因为它指向另一个实体在数据库中,

516
00:22:00,179 --> 00:22:02,279
And we know that the objects in the database
我们知道,数据库中的对象

517
00:22:02,348 --> 00:22:04,081
are represented by an NSManagedObject,
由一个NSManagedObject,

518
00:22:04,150 --> 00:22:06,783
So that's gonna be the type of that var,
这是将var的类型,

519
00:22:06,851 --> 00:22:09,118
Although we're eventually gonna make it even better than
虽然我们最终会使它甚至比

520
00:22:09,187 --> 00:22:11,420
that, but on the other side though,
,但另一方面,

521
00:22:11,488 --> 00:22:17,493
the type of that var is NSSet of NSManagedObject, okay?
var是NSSet NSManagedObject的的类型,对吧?

522
00:22:17,562 --> 00:22:23,598
Now NSSet, there is a Swift struct called set,
现在NSSet,迅速结构被称为集,

523
00:22:23,667 --> 00:22:25,766
It's a generic type, it's just like an array where you have
这是一个泛型类型,就像一个数组中

524
00:22:25,835 --> 00:22:26,667
to say what's in an array,
说什么一个数组,

525
00:22:26,736 --> 00:22:29,270
same thing with a set you have to say what's in it,
同样一套你说什么,

526
00:22:29,338 --> 00:22:33,240
NSSet is kind of an older Objective-C kind of set,
NSSet objective - c是一种老的,

527
00:22:33,309 --> 00:22:35,375
It's not generic, it's untyped,
它不是通用的,它是无类型,

528
00:22:35,443 --> 00:22:39,212
The things in NSSet are any, which we kinda need a little
NSSet任何的事情,我们需要一点

529
00:22:39,281 --> 00:22:42,214
bit here cuz we really don't know what kinds of things
在这里因为我们真的不知道什么样的事情

530
00:22:42,283 --> 00:22:43,149
are in there,
在那里,

531
00:22:43,217 --> 00:22:47,619
However, in your code you can cast from this NSSet
然而,在您的代码可以从这个NSSet

532
00:22:47,688 --> 00:22:51,656
of NSManagedObject to a set of what you know to be in there
NSManagedObject一组你知道在那里

533
00:22:51,725 --> 00:22:53,158
using as question mark, and
使用问号,

534
00:22:53,226 --> 00:22:55,293
if that in fact is what's in there, it will work,
如果,事实上就是在那里,它会工作,

535
00:22:57,296 --> 00:22:58,462
So that's the NSSet there,
这就是NSSet那里,

536
00:22:59,664 --> 00:23:01,164
One last thing I'm gonna show you here before
最后一件事我要告诉你这里之前

537
00:23:01,233 --> 00:23:04,300
we get back to the slides is this Delete Rule,
这是我们回到幻灯片删除规则,

538
00:23:04,369 --> 00:23:06,268
You see the delete rule on the,
你看到删除的规则,

539
00:23:06,337 --> 00:23:10,005
clicked on tweets on here so we're inspecting tweets,
点击微博在这里我们检查微博,

540
00:23:10,074 --> 00:23:13,608
And this delete rule tells you what happens
这个删除规则告诉你发生了什么

541
00:23:13,677 --> 00:23:17,979
to the pointed-to tweets if we deleted this Twitter user,
指针微博如果我们删除这个Twitter用户,

542
00:23:18,047 --> 00:23:19,880
Cuz if I delete this Twitter user,
因为如果我删除这个Twitter用户,

543
00:23:19,949 --> 00:23:23,417
does that mean I delete all of the Twitter user's tweets?
这是否意味着我删除所有的Twitter用户的推文?

544
00:23:23,486 --> 00:23:26,287
Well, it depends on this delete rule right here,
嗯,这取决于这个删除规则,

545
00:23:26,355 --> 00:23:27,821
this delete rule is saying nullify, which would mean no,
这个删除规则说取消,这意味着没有,

546
00:23:27,822 --> 00:23:29,288
So right now,
现在,

547
00:23:29,358 --> 00:23:32,091
Those tweets would stay in the database, and their tweeter
这些tweet留在数据库中,和他们的推特

548
00:23:32,160 --> 00:23:35,261
will be set to nil because their tweeter got deleted,
将被设置为零,因为他们的推特被删除,

549
00:23:35,330 --> 00:23:37,829
But there is a cascading delete rule, which would say
但有一个级联删除规则,会说

550
00:23:37,898 --> 00:23:40,332
if I delete this thing then delete everything that it
如果我删除这个东西然后删除一切

551
00:23:40,401 --> 00:23:42,367
points to, just go right down the graph and
点,就图和

552
00:23:42,436 --> 00:23:43,434
delete everything,
删除一切,

553
00:23:43,503 --> 00:23:46,170
So that's what controls what happens when you delete,
这就是控制当你删除,

554
00:23:46,238 --> 00:23:48,405
Now I'm not gonna ask you to even do delete;
甚至现在我不会要求你做删除;

555
00:23:48,474 --> 00:23:51,141
I guess I might ask you an extra credit to do delete in
我想我可能会问你一个额外的信用做删除

556
00:23:51,209 --> 00:23:52,141
assignment five,
作业五,

557
00:23:52,210 --> 00:23:54,744
Because deletion kinda- you're really gonna know what
因为删除——你会知道

558
00:23:54,812 --> 00:23:56,612
you're doing- when you can delete things, and
你在做什么,当你可以删除东西,和

559
00:23:56,681 --> 00:23:58,413
what kind of delete rules you want,
你想要什么样的删除规则,

560
00:23:58,482 --> 00:24:00,215
But I just want to let you know that you specify
但我只是想让你知道你指定

561
00:24:00,283 --> 00:24:02,317
the delete rule right here in the inspector,
删除规则检查员,

562
00:24:03,986 --> 00:24:07,955
Okay, now that you've defined all your entities, attributes
好吧,既然你已经定义了所有的实体、属性

563
00:24:08,023 --> 00:24:11,792
in relationships, then what can we do with these things?
与这些关系,那么我们能做些什么事情?

564
00:24:11,861 --> 00:24:15,462
Well to do anything with it we need to get a hold of them
我们用它来做任何事情需要控制住它们

565
00:24:15,531 --> 00:24:18,531
in our code, grab onto them basically, and
在我们的代码中,抓住他们基本上,

566
00:24:18,600 --> 00:24:20,466
to do that we need another important class,
要做到这一点,我们需要另一个重要的类,

567
00:24:20,535 --> 00:24:23,502
NSManagedObjectContext, so I told you
NSManagedObjectContext,所以我告诉你

568
00:24:23,571 --> 00:24:26,071
all those things in the database are NSManagedObjects,
nsmanagedobject数据库中的所有这些事情,

569
00:24:26,139 --> 00:24:28,206
you need an NSManagedObjectContext,
你需要一个NSManagedObjectContext,

570
00:24:28,275 --> 00:24:32,009
which represents a database to do anything with them,
代表一个数据库做任何事,

571
00:24:32,078 --> 00:24:34,578
to get any of them, to create any of them, etc,
其中任何一个,创建的,等等,

572
00:24:34,647 --> 00:24:37,381
this is the hub around which Core Data activity turns,
这是核心数据的中心活动,

573
00:24:37,449 --> 00:24:38,615
as I say there,
就像我说的,

574
00:24:38,684 --> 00:24:41,185
So how do I get one of these NSManagedObjectContext?
所以我怎么得到这些NSManagedObjectContext之一?

575
00:24:41,253 --> 00:24:43,920
And the answer is, you need a persistentContainer,
答案是,你需要一个persistentContainer,

576
00:24:43,989 --> 00:24:46,623
Woo-hoo, and you know where to get one of those,
啊,你知道的,

577
00:24:46,691 --> 00:24:48,190
You just click, Use Core Data, and
你点击,使用核心数据,

578
00:24:48,259 --> 00:24:49,858
it's gonna appear in your AppDelegate,
它会出现在你AppDelegate,

579
00:24:49,927 --> 00:24:51,693
You're gonna get that lazy var,
你会得到,懒惰的var,

580
00:24:51,761 --> 00:24:53,461
that's called persistentContainer,
这叫做persistentContainer,

581
00:24:53,530 --> 00:24:55,262
And that is gonna be a persistentContainer,
这将是一个persistentContainer,

582
00:24:55,331 --> 00:24:57,431
And from that you can get the context,
从那你可以得到的背景下,

583
00:24:57,499 --> 00:25:00,568
Now, if you have the lazy var in your AppDelegate,
现在,如果你有懒惰AppDelegate var,

584
00:25:00,636 --> 00:25:02,636
How the heck do you call that var?
你叫var到底如何?

585
00:25:02,705 --> 00:25:04,003
How do you get that var?
你怎么得到var ?

586
00:25:04,072 --> 00:25:05,571
And this is how you do it, okay?
这是你怎么做,好吗?

587
00:25:05,640 --> 00:25:10,009
You get a copy of the shared UIApplication, now,
你拿到一份UIApplication共享,现在,

588
00:25:10,077 --> 00:25:12,678
we didn't talk about this but your app has this one and
我们不谈论这个但是你的应用

589
00:25:12,747 --> 00:25:16,415
only UIApplication object that represents your application
只有UIApplication对象代表您的应用程序

590
00:25:16,484 --> 00:25:19,784
and you get it by doing UIApplication,shared,
你UIApplication得到通过,共享,

591
00:25:19,853 --> 00:25:20,919
it's a var,
这是一个var,

592
00:25:20,987 --> 00:25:23,887
Static var in UIApplication class,
UIApplication类中的静态变量,

593
00:25:23,956 --> 00:25:24,955
Gives you the shared one,
给你共享一个,

594
00:25:25,024 --> 00:25:28,191
Then you're gonna access this var in UIApplication which is
然后你要访问这UIApplication var在

595
00:25:28,260 --> 00:25:29,159
its delegate,
其委托,

596
00:25:30,528 --> 00:25:32,762
Now, its delegate is automatically set up for
现在,它的代表是自动设置

597
00:25:32,830 --> 00:25:35,597
you to be this Swift class AppDelegate that you see
你这个迅速类AppDelegate你看到

598
00:25:35,666 --> 00:25:37,999
always; we always put it off in Supporting Files and
总是,我们总是把它在支持文件,

599
00:25:38,068 --> 00:25:40,134
get it out of our way, but it's created for you,
把它从我们的方式,但它是为你创建的,

600
00:25:40,203 --> 00:25:41,035
it's a nice little class,
这是一个很好的小类,

601
00:25:41,104 --> 00:25:43,604
We're going to talk about the application life cycle, and
我们将讨论应用程序生命周期,和

602
00:25:43,672 --> 00:25:46,707
where it fits in, in a little bit, but for now all
它适合在一点,但是现在呢

603
00:25:46,776 --> 00:25:49,542
you need to know is you can get AppDelegate, and you want
你需要知道的是你可以得到AppDelegate,和你想要的

604
00:25:49,611 --> 00:25:52,845
to send persistentContainer to it to get that var, but of
向它发送persistentContainer var,但是

605
00:25:52,914 --> 00:25:57,450
course you have to as it to be the AppDelegate class first,
当然你必须首先在AppDelegate类,

606
00:25:57,519 --> 00:25:58,885
So this is the code you're going to use,
这是你要使用的代码,

607
00:25:58,953 --> 00:26:01,120
(UIApplication,shared,delegate as!
(UIApplication,共享,委托!

608
00:26:01,189 --> 00:26:03,956
AppDelegate) All that in one expression
AppDelegate)在一个表达式

609
00:26:04,024 --> 00:26:06,758
dot persistentContainer now you're gonna get this
点persistentContainer现在你会得到这个

610
00:26:06,826 --> 00:26:09,794
persistentContainer, and notice I'm doing as
persistentContainer,注意到我所做的

611
00:26:09,862 --> 00:26:12,863
exclamation point this will crash if my App Delegate is
感叹号崩溃如果我的应用程序委托

612
00:26:12,932 --> 00:26:15,866
not in fact App Delegate, but it's already wired up
不实际上应用程序委托,但它已经连接起来

613
00:26:15,934 --> 00:26:18,669
to be that for you when you create a new project,
为您,当您创建一个新项目,

614
00:26:18,737 --> 00:26:20,103
so that should never be a problem,
所以不应该成为一个问题,

615
00:26:21,306 --> 00:26:21,770
Okay? So
好吧?

616
00:26:21,839 --> 00:26:24,640
now I have this persistentContainer,
现在我有这个persistentContainer,

617
00:26:24,709 --> 00:26:27,275
I need to get the context out of it,
我需要的上下文,

618
00:26:27,344 --> 00:26:28,643
And, so,
所以,

619
00:26:28,712 --> 00:26:33,281
the container has an awesome var called viewContext,
容器有一个很棒的var称为viewContext,

620
00:26:33,349 --> 00:26:36,684
And the viewContext is an NSManagedObjectContext that's
和viewContext NSManagedObjectContext就是

621
00:26:36,753 --> 00:26:39,620
only suitable for use on the main queue,
只适合用在主要的队列,

622
00:26:39,688 --> 00:26:40,520
This is in red,
这是红色的,

623
00:26:40,588 --> 00:26:42,956
you know whenever you see anything in red on my slides,
你知道每当你看到任何红色的幻灯片,

624
00:26:43,024 --> 00:26:45,191
this means pay attention, it will matter for
这意味着关注,将物质

625
00:26:45,260 --> 00:26:47,960
your homework, and in life, but
你的家庭作业,在生活中,但是

626
00:26:48,029 --> 00:26:51,029
you can only use this viewContext in the main queue,
你只能用这个viewContext在主队列,

627
00:26:51,098 --> 00:26:54,333
it called viewContext because you use it with your views,
这叫viewContext因为你使用它与你的观点,

628
00:26:54,401 --> 00:26:57,869
okay, your UI views, that's why we call it viewContext,
好的,UI视图,这就是为什么我们称之为viewContext,

629
00:26:59,706 --> 00:27:02,773
So why do I make a point about this main queue?
为什么我对这个主要强调队列?

630
00:27:02,842 --> 00:27:05,809
Well, the reason I do that is because NSManagedObjectContext
好吧,我之所以这么做是因为NSManagedObjectContext

631
00:27:05,878 --> 00:27:07,744
is not thread-safe,
不是线程安全的,

632
00:27:07,813 --> 00:27:10,747
But I'm gonna talk you, talk to you about how we can do
但是我要告诉你,和你谈谈我们如何做

633
00:27:10,816 --> 00:27:13,883
multithreaded database stuff towards the end of this talk,
多线程数据库的东西在这个演讲,

634
00:27:13,951 --> 00:27:16,552
All right, so now you have this viewContext then you can
好了,现在你有了这个viewContext然后你可以

635
00:27:16,621 --> 00:27:18,020
use it to do things,
用它来做事情,

636
00:27:18,089 --> 00:27:21,690
Now, it's so
现在,就是这样的

637
00:27:21,759 --> 00:27:23,892
{UIApplication,shared,delegate as!
UIApplication {、共享,委托!

638
00:27:23,960 --> 00:27:26,027
Appdelegate),persistentContai- ner,
Appdelegate),persistentContai -尼珥,

639
00:27:26,096 --> 00:27:27,394
that's kind of a messy line of code,
这是一个混乱的代码,

640
00:27:27,463 --> 00:27:30,330
There's a lot of, there's as and all these things in there,
有很多,和所有这些事情,

641
00:27:30,399 --> 00:27:34,100
So at times we'll just create a static version of
所以有时我们会创建一个静态的版本

642
00:27:34,169 --> 00:27:37,537
persistentContainer in our AppDelegate,
persistentContainer AppDelegate,

643
00:27:37,606 --> 00:27:39,138
Okay, we'll just call it the same thing,
好吧,我们就叫它同样的事情,

644
00:27:39,207 --> 00:27:41,307
persistentContainer but it's static and
persistentContainer但静态和

645
00:27:41,376 --> 00:27:43,776
it's just gonna return that messy line of code,
它会返回,混乱的代码,

646
00:27:43,845 --> 00:27:46,011
So now we can get that persistentContainer with
所以现在我们可以得到persistentContainer

647
00:27:46,079 --> 00:27:48,747
AppDelegate,persistentContai- ner,
AppDelegate persistentContai——尼珥,

648
00:27:48,815 --> 00:27:50,248
See what I did there?
看看我在做什么吗?

649
00:27:50,317 --> 00:27:52,683
I just made it easier to get up by making that be a static,
我做到了容易通过,是一个静态的,

650
00:27:52,752 --> 00:27:56,153
a class var, and we can do the same thing with viewContext,
一个类变量,我们可以用viewContext做同样的事情,

651
00:27:56,222 --> 00:27:59,455
you might create a static called viewContext and for
您可以创建一个静态viewContext和呼吁

652
00:27:59,524 --> 00:28:02,092
the rest of these slides you can assume I've done this,
剩下的这些幻灯片你可以假设我做这个,

653
00:28:02,160 --> 00:28:04,793
Which is good because typing that long messy thing would
这很好,因为打字脏乱不堪的事情

654
00:28:04,862 --> 00:28:07,563
make all my slides spill over the edge,
让我所有的幻灯片溢出的边缘,

655
00:28:07,632 --> 00:28:09,831
So I'm gonna use this shorter version as well,
所以我要用这个短的版本,

656
00:28:09,900 --> 00:28:11,300
And you're welcome to create the static
和欢迎你来创建静态的

657
00:28:11,369 --> 00:28:13,201
version in your AppDelegate if you want
版本在你AppDelegate如果你想要的

658
00:28:13,270 --> 00:28:14,568
to make your code a little cleaner,
让你的代码更干净一点,

659
00:28:14,637 --> 00:28:17,104
Now this viewContext in the persistentContainer
现在这个viewContext persistentContainer

660
00:28:17,173 --> 00:28:18,456
There's one of them that represents your entire
有其中一个代表你的全部

661
00:28:18,457 --> 00:28:19,740
are shared,
是共享的,

662
00:28:19,808 --> 00:28:20,573
database,
数据库,

663
00:28:20,642 --> 00:28:22,709
So it's perfectly fine to create a single static
所以完全可以创建一个静态的

664
00:28:22,777 --> 00:28:23,643
that does this,
做这个,

665
00:28:23,711 --> 00:28:26,178
By the way, what if you wanted multiple databases?
顺便说一下,如果你想要多个数据库呢?

666
00:28:26,246 --> 00:28:27,679
You could even have multiple databases with
你甚至可以有多个数据库

667
00:28:27,748 --> 00:28:29,180
different schema,
不同的模式,

668
00:28:29,249 --> 00:28:31,316
Very easy, if you go look at the code for
很简单,如果你去看看代码

669
00:28:31,384 --> 00:28:34,819
persistentContainer in AppDelegate,
persistentContainer AppDelegate,

670
00:28:34,887 --> 00:28:37,087
you'll see it's only like four lines of code,
你会看到只有四行代码,

671
00:28:37,156 --> 00:28:39,289
And you could just copy it to create a different
你可以复制它创建一个不同的

672
00:28:39,358 --> 00:28:42,759
persistentContainer using a different xcmodeld file,
使用不同的xcmodeld persistentContainer文件,

673
00:28:42,828 --> 00:28:45,295
Instead of using model according to the example,
根据这个例子中,而不是使用模型

674
00:28:45,363 --> 00:28:46,828
create another one with a different one and
创建另一个与另一个

675
00:28:46,897 --> 00:28:50,399
you can just go file, new file and create another data model,
你可以去文件,新文件并创建另一个数据模型,

676
00:28:50,468 --> 00:28:54,403
You could even create two persistent containers with
你甚至可以创建两个持久性容器

677
00:28:54,471 --> 00:28:55,904
the same model,
相同的模型,

678
00:28:55,973 --> 00:28:58,006
So they would be separate databases, but
所以他们会单独的数据库,但是

679
00:28:58,074 --> 00:28:59,640
have the same model, the same entities to that and
有相同的模式,相同的实体,

680
00:28:59,709 --> 00:29:00,674
the same relationship to that,
相同的关系,

681
00:29:00,743 --> 00:29:02,309
It's perfectly allowed as well,
这是完全允许的,

682
00:29:02,377 --> 00:29:04,243
But for everything you're going to do in this class, and
但是对于你要做的每件事都在这个类中,和

683
00:29:04,312 --> 00:29:05,444
for really with most apps,
对于真正与大多数应用程序,

684
00:29:05,513 --> 00:29:08,046
you're going to have one big database,
你将会有一个大的数据库,

685
00:29:08,115 --> 00:29:10,582
And you're going to have this one persistent container that
和你要这一个持久的容器

686
00:29:10,651 --> 00:29:12,384
is the container for it,
是它的容器,

687
00:29:12,452 --> 00:29:14,452
All right,
好吧,

688
00:29:14,521 --> 00:29:18,055
So now I have a context in my hand, this viewContext,
现在我手中有一个上下文,这viewContext,

689
00:29:18,124 --> 00:29:19,023
And what can I do?
我能做什么?

690
00:29:19,091 --> 00:29:21,391
Well, of course, I can insert objects into the database,
当然,我可以将对象插入到数据库,

691
00:29:21,460 --> 00:29:23,227
I can delete objects from the database,
我可以从数据库中删除对象,

692
00:29:23,295 --> 00:29:25,361
And I can query for objects in the database,
我可以查询数据库中的对象,

693
00:29:25,430 --> 00:29:26,662
So, let's talk about all those things,
所以,让我们来谈谈那些东西,

694
00:29:26,731 --> 00:29:29,765
Let's start with insert because until we insert some
让我们从插入开始因为直到我们插入一些

695
00:29:29,834 --> 00:29:32,267
data in the database we can't do any of those other things,
数据库中的数据我们不能做任何其他的事情,

696
00:29:32,336 --> 00:29:35,136
And the way you insert an object in the database, or
你在数据库中插入一个对象,或

697
00:29:35,205 --> 00:29:36,538
a way to do it, and actually for
一个方法,实际上

698
00:29:36,607 --> 00:29:39,107
the next few slide I'm going to kind of show you the,
接下来的几张我要给你们看,

699
00:29:39,175 --> 00:29:40,741
the essentials,
生活必需品,

700
00:29:40,810 --> 00:29:43,843
But, we're eventually going to move up to a high level and
但是,我们最终会上升到一个高水平

701
00:29:43,912 --> 00:29:46,479
access this stuff in a much nicer way,
访问这个东西好得多的方式,

702
00:29:46,548 --> 00:29:48,414
But I'll tell you the basics of it first,
但我要告诉你的基本知识,

703
00:29:48,483 --> 00:29:51,117
So the basic way to put something in the database is
所以把东西放在数据库的基本方法

704
00:29:51,186 --> 00:29:53,252
with this really interesting method,
这个非常有趣的方法,

705
00:29:53,321 --> 00:29:57,923
NSEntityDescription,insertNew- Object(forEntityName: into:
NSEntityDescription insertNew——对象(forEntityName:到:

706
00:29:57,991 --> 00:29:59,624
context),
context),

707
00:29:59,693 --> 00:30:02,260
Okay, that's a mouthful, used to be even more of a mouthful
好了,这就是一口,更多的一口

708
00:30:02,329 --> 00:30:04,128
before they renamed it,
他们改了之前,

709
00:30:04,197 --> 00:30:08,366
And you just specify the name of the entity, so
你只是指定实体的名称,所以

710
00:30:08,434 --> 00:30:09,933
Tweet or TwitterUser,
推特或TwitterUser,

711
00:30:10,002 --> 00:30:12,435
And you give it a context that is gonna be the viewContext
你给它一个上下文是viewContext

712
00:30:12,504 --> 00:30:13,570
you got from the AppDelegate,
你有在AppDelegate,

713
00:30:13,639 --> 00:30:15,871
And boom, it's gonna create one of these in the database,
和繁荣,它会创建一个在数据库中,

714
00:30:15,940 --> 00:30:19,708
Now all of its attributes will be nil,
现在它的所有属性将是零,

715
00:30:19,777 --> 00:30:21,810
Okay, although you can inspect the attributes in
好吧,虽然你可以检查属性

716
00:30:21,879 --> 00:30:24,313
the data model editor and specify default value,
数据模型编辑器和指定默认值,

717
00:30:24,381 --> 00:30:26,848
And so it might start out with the default value,
所以它可能从默认值,

718
00:30:26,917 --> 00:30:30,785
But if it doesn't, then they'll start out as nil,
但如果没有,那么他们就会开始是零,

719
00:30:30,853 --> 00:30:34,055
Okay, so that's great,
好了,这很好,

720
00:30:34,123 --> 00:30:36,323
I can now create one,
我现在可以创建一个,

721
00:30:36,392 --> 00:30:40,460
And now I need to set those vars to have some value,
现在我需要设置这些增值有价值,

722
00:30:40,529 --> 00:30:43,496
I need to set the text of the tweet and things like that and
我需要设置的文本推特之类的东西

723
00:30:43,565 --> 00:30:46,465
I told you I'm gonna do this with value for key and
我告诉你我要做的这个键和值

724
00:30:46,534 --> 00:30:48,867
set value for key,
为关键的设置值,

725
00:30:48,936 --> 00:30:53,872
So for example I wanted to set the let's say the text,
比如我想设置的文本,

726
00:30:53,941 --> 00:30:56,074
I could just say tweet,
我可以只说推特,

727
00:30:56,143 --> 00:31:00,212
A set value for key quote text, to be a string,
一组值的键引用文本,是一个字符串,

728
00:31:03,817 --> 00:31:06,117
And you can do dot notation here, with value for key path,
你可以在这里做点符号,为关键路径与价值,

729
00:31:06,186 --> 00:31:08,318
That's what I'm showing in green right there,
这就是我用绿色显示,

730
00:31:08,387 --> 00:31:10,754
You can have, if you had a tweet you can actually set
你可以,如果你有一个你可以设置

731
00:31:10,823 --> 00:31:15,325
the tweet's tweeter's name, using this dot notation to set
推特的推特的名字,使用这个点符号

732
00:31:15,394 --> 00:31:17,761
value for key path tweeter dot name and it would go through
价值关键路径名称和它会通过推特点

733
00:31:17,829 --> 00:31:20,696
the tweeter relationship which is kinda fun,
推特的关系有点有趣,

734
00:31:20,765 --> 00:31:23,198
I'm kinda going fast through this because this is a really
我有点快通过这个因为这是真的

735
00:31:23,267 --> 00:31:25,333
terrible API,
可怕的API,

736
00:31:25,402 --> 00:31:27,502
First of all it's got any in there so
首先它有任何在那里

737
00:31:27,571 --> 00:31:30,070
there's not type checking going on here, okay?
没有类型检查,好吗?

738
00:31:30,139 --> 00:31:37,311
You could say, set value date for key quote text, all right?
你可能会说,设置值的日期键引用文本,对吧?

739
00:31:37,380 --> 00:31:39,480
And that would be perfectly accepted by Swift,
这将是完全被迅速接受,

740
00:31:39,549 --> 00:31:43,617
Date is an Any and quote text is a String, but
日期是一个任何引用的文本是一个字符串,但是

741
00:31:43,685 --> 00:31:46,452
of course that's gonna fail miserably at run time, okay,
当然,会在运行时失败,好吧,

742
00:31:46,521 --> 00:31:48,087
because the text is a Atring,
因为文本是atr,

743
00:31:48,155 --> 00:31:50,822
So we're not really gonna use this API but this is
所以我们不使用这个API,但这是

744
00:31:50,891 --> 00:31:55,561
the underlying basic way that Core Data is doing this,
底层核心数据的基本方式是这样做,

745
00:31:55,629 --> 00:31:57,695
Yes the key is just the name of the attribute, and
是的,关键是属性的名称,以及

746
00:31:57,764 --> 00:32:00,732
the value is all the things we've talked about before,
价值是我们之前谈论的所有事情,

747
00:32:02,769 --> 00:32:04,769
I do have the blue Use Scalar Type there which
我有蓝色的使用标量类型

748
00:32:04,837 --> 00:32:05,536
is interesting,
很有趣,

749
00:32:05,604 --> 00:32:09,839
If the thing you're putting in the database is a flow or
如果你把数据库中是一个流或

750
00:32:09,908 --> 00:32:12,575
an Int32 or one of these things,
Int32或其中的一个东西,

751
00:32:12,644 --> 00:32:15,678
It's actually gonna be stored in a database as an NSNumber,
它实际上会作为NSNumber存储在数据库中,

752
00:32:15,747 --> 00:32:16,879
which is a class,
这是一个类,

753
00:32:16,947 --> 00:32:20,515
it's an object, kind of generic holder of numbers,
这是一个对象,通用的数字,

754
00:32:20,584 --> 00:32:25,320
But if you flip on the switch in the inspector in your data
但是如果你打开开关检查员在您的数据

755
00:32:25,389 --> 00:32:28,689
modeller for that attribute saying use a scalar type,
分析员说使用一个标量类型属性,

756
00:32:28,758 --> 00:32:32,360
then it'll make the type be double or int or whatever,
然后它会让双或int类型等等,

757
00:32:32,429 --> 00:32:33,394
instead of NSNumber, so,
而不是NSNumber,所以,

758
00:32:33,463 --> 00:32:35,596
I know, you had a question?
我知道,你有问题吗?

759
00:32:35,664 --> 00:32:38,298
>> Yes, so the question is, does set value reject
> >是啊,问题是,拒绝并设置值

760
00:32:38,367 --> 00:32:39,799
something where the types don't match?
类型不匹配的地方吗?

761
00:32:39,868 --> 00:32:41,434
And the answer is, it can't,
答案是,它不能,

762
00:32:41,502 --> 00:32:43,702
It doesn't know the type, the types are any,
它不知道类型,类型是什么

763
00:32:43,771 --> 00:32:46,138
as long as it matches any- and everything matches any,
只要它匹配任何匹配任何的一切,

764
00:32:46,207 --> 00:32:47,939
So, it can't,
所以,它不能,

765
00:32:48,008 --> 00:32:52,577
There's no way for it to have enough information to reject,
没有办法拒绝的它有足够的信息,

766
00:32:52,645 --> 00:32:55,079
As long as it matches any, it'll accept that as the type,
只要它匹配任何,它会接受的类型,

767
00:32:55,147 --> 00:32:56,447
And then at runtime, it will crash,
然后在运行时,它会崩溃,

768
00:32:56,515 --> 00:32:59,216
If you try to set a date to be into a string field,
如果你尝试设定一个日期字符串字段,

769
00:32:59,285 --> 00:33:03,553
>> So when it's like [INAUDIBLE]
> >当它就像(听不清)

770
00:33:03,622 --> 00:33:06,856
save context,
拯救环境,

771
00:33:06,925 --> 00:33:09,125
do you have to like make it go through,
你有喜欢让它通过,

772
00:33:09,193 --> 00:33:10,293
Or is it, >> Go and remove,
还是,> >去删除

773
00:33:10,361 --> 00:33:11,660
>> [CROSSTALK] >> What do you
> >[CROSSTALK]> >你的

774
00:33:11,728 --> 00:33:12,794
mean go and remove it?
意思是去删除它?

775
00:33:12,863 --> 00:33:13,428
Remove what?
删除什么?

776
00:33:21,971 --> 00:33:23,604
Yeah, we'll talk about saving in this,
是的,我们会讲节约,

777
00:33:23,673 --> 00:33:24,638
So, the question is,
所以,问题是,

778
00:33:24,707 --> 00:33:26,773
when the app terminates it does save context and
在应用程序终止时保存上下文和

779
00:33:26,842 --> 00:33:29,609
they're trying to save this, we'll talk all about saving in
他们试图保存,我们将谈论所有储蓄

780
00:33:29,677 --> 00:33:31,944
a minute cause that's an important piece of this,
一分钟的这是一个重要的原因,

781
00:33:32,013 --> 00:33:35,247
That's the keys and values, pretty straightforward there;
键和值,很简单;

782
00:33:35,316 --> 00:33:38,150
in fact we're going to talk about saving right now,
事实上我们现在要讲的储蓄,

783
00:33:38,218 --> 00:33:39,885
We do a nice lead in,
我们做一个好领导,

784
00:33:39,953 --> 00:33:43,020
All these changes that you make with that set value even
所有这些变化,甚至设置值

785
00:33:43,089 --> 00:33:45,123
insert entity description for
插入实体描述

786
00:33:45,191 --> 00:33:48,125
entity name context whatever that thing is called,
实体名称上下文的任何事情,

787
00:33:48,194 --> 00:33:50,728
All that stuff only happens in memory,
所有这些只发生在内存中,

788
00:33:50,796 --> 00:33:53,796
if you want that to actually happen permanently in
如果你想真正发生永久

789
00:33:53,865 --> 00:33:55,998
the database you need to save it,
数据库需要保存它,

790
00:33:56,067 --> 00:33:58,233
And you do that by telling the context,
你这样做,告诉上下文,

791
00:33:58,302 --> 00:34:01,370
like that view context thing, to save with the method save,
这样的视图上下文,保存方法保存,

792
00:34:01,438 --> 00:34:04,240
It couldn't be simpler, except that it can throw,
不可能是简单的,除了可以扔,

793
00:34:05,910 --> 00:34:07,842
Save is a method that can throw because
节约是一个方法,可以把因为

794
00:34:07,911 --> 00:34:10,144
maybe there's a problem writing out to the database,
也许有一个问题写数据库,

795
00:34:10,213 --> 00:34:12,880
And there's many problems that could happen writing
还有许多问题可能发生的写作

796
00:34:12,949 --> 00:34:14,448
out to the database,
数据库,

797
00:34:14,517 --> 00:34:15,882
And you need to look at documentation and
你需要看文档和

798
00:34:15,951 --> 00:34:17,783
kind of figure out what they all are,
算出的都是什么,

799
00:34:17,852 --> 00:34:20,687
But the take home message here is you do need to save,
但这里的带回家的信息是你需要保存,

800
00:34:20,755 --> 00:34:23,189
If you don't save, that substance is gonna be lost
如果你不救,物质会丢失

801
00:34:23,257 --> 00:34:25,324
when your app exists or whatever,
当你的应用存在之类的,

802
00:34:25,393 --> 00:34:26,558
So you definitely just save,
所以你肯定只是保存,

803
00:34:26,627 --> 00:34:29,627
And especially when talking about multithreaded Core Data,
特别是在谈到多线程的核心数据,

804
00:34:29,696 --> 00:34:30,928
And one thread is working,
和一线工作时,

805
00:34:30,997 --> 00:34:33,531
That thread needs to save if it wants any of the other
该线程需要拯救如果它希望的任何其他

806
00:34:33,600 --> 00:34:36,066
threads to see the work that it's done,
线程看到工作的完成,

807
00:34:36,135 --> 00:34:40,370
Okay, so you can use try question mark here, remember,
好的,那么你可以使用问号,记住,

808
00:34:40,439 --> 00:34:41,604
which means try and
这意味着试着

809
00:34:41,673 --> 00:34:44,807
if it fails, just return nil and ignore it,
如果失败了,就返回nil,忽略它,

810
00:34:44,875 --> 00:34:48,310
You can do that, if you don't mind that it didn't save,
你可以这样做,如果你不介意的话,它没有保存,

811
00:34:48,379 --> 00:34:50,946
And the kinda things that can happen, saving errors,
和有点事情发生,保存错误,

812
00:34:51,015 --> 00:34:53,248
You could obviously have file system problems,
你可以很明显有文件系统问题,

813
00:34:53,317 --> 00:34:55,617
your disk is full or something like that,
磁盘已满或类似的东西,

814
00:34:55,686 --> 00:34:57,919
But you can also have inconsistencies in
但是你也可以不一致

815
00:34:57,988 --> 00:35:01,121
the database, maybe you had conflicting
数据库中,也许你有冲突

816
00:35:01,190 --> 00:35:04,291
data of two threads trying to save to the same database, and
数据的两个线程试图保存到同一个数据库,和

817
00:35:04,359 --> 00:35:06,126
they've tried to write over the top of each other,
他们想写的,

818
00:35:06,194 --> 00:35:08,261
those kind of things,
这样的事情,

819
00:35:08,330 --> 00:35:10,496
Again, a lot of those problems you're not gonna have,
再次,很多这些问题你不会有,

820
00:35:10,565 --> 00:35:12,365
unless you build a pretty complicated,
除非你建立一个相当复杂,

821
00:35:12,433 --> 00:35:14,733
multithreaded application, or something like that,
多线程应用程序,或类似的东西,

822
00:35:14,802 --> 00:35:17,335
but, again, you gotta check the documentation, I couldn't,
但是,你必须检查文档,我不能,

823
00:35:17,404 --> 00:35:19,971
it would take too long for me to go through all of it,
需要太长时间我经历的所有,

824
00:35:21,441 --> 00:35:25,776
Okay now, as I said value forKey and setValue forKey,
好,正如我所说的价值forKey setValue forKey,

825
00:35:25,845 --> 00:35:29,713
Really ugly,
真的很丑,

826
00:35:29,782 --> 00:35:32,483
What we really want to do is be able to set these vars
我们真正要做的是能够设置这些增值

827
00:35:32,551 --> 00:35:35,685
as vars, we just wanna have a var called text
作为增值,我们只是想有一个var叫文本

828
00:35:35,754 --> 00:35:37,487
somewhere that we can set,
我们可以设置的地方,

829
00:35:37,556 --> 00:35:39,521
And of course we're exactly going to do that,
当然,我们到底要这样做,

830
00:35:39,590 --> 00:35:42,791
And the way we're going to do that is create a subclass of
和我们要做的是创建一个子类

831
00:35:42,860 --> 00:35:45,561
NSManagedObject, instead of having NSManagedObject in
NSManagedObject,而不是NSManagedObject

832
00:35:45,629 --> 00:35:47,295
the database we doing set-value, get-value on it,
我们的数据库做设定值,能创造更多的价值,

833
00:35:47,364 --> 00:35:51,465
Instead we're going to create a subclass of NSManageObjects
相反我们要创建NSManageObjects的一个子类

834
00:35:51,534 --> 00:35:54,635
and it's going to have vars on there for all the attributes,
它会在那里var属性,

835
00:35:54,704 --> 00:35:57,971
like text, and screen name and all those things,
喜欢文字,屏幕名称和所有这些事情,

836
00:35:58,040 --> 00:36:00,307
And Xcode will generate all that code for
和Xcode将生成代码

837
00:36:00,375 --> 00:36:01,208
you behind the scenes,
你在幕后,

838
00:36:01,276 --> 00:36:03,676
you don't have to do any work to make that happen,
你不需要做任何工作要做到这一点,

839
00:36:03,744 --> 00:36:05,811
Quite quite simple, so let's look and see how we do that,
很简单,让我们看看我们如何做到这一点,

840
00:36:05,880 --> 00:36:09,280
You do that by inspecting the entity,
你通过检查实体,

841
00:36:09,349 --> 00:36:11,083
So here I've chosen tweet,
这里我选择了微博,

842
00:36:11,151 --> 00:36:12,316
Okay, not any of its attributes but
好吧,但不是它的任何属性

843
00:36:12,385 --> 00:36:15,786
tweet itself, and I want to make it so
tweet本身,我想让它如此

844
00:36:15,855 --> 00:36:17,988
it generates this magic code, and how do I do that?
它生成这个神奇的代码,我该怎么做?

845
00:36:18,057 --> 00:36:20,857
Well, if you go down on the inspector
好吧,如果你去检查

846
00:36:20,926 --> 00:36:23,260
a little ways you see it says Codegen,
你看到它说Codegen一点方法,

847
00:36:23,329 --> 00:36:24,760
See that Codegen, that's for
看到Codegen,

848
00:36:24,829 --> 00:36:26,729
generating this code, this magic code,
生成此代码,这个神奇的代码,

849
00:36:26,797 --> 00:36:29,198
Now, you actually have a couple of choices here for
现在,你在这里有两个选择

850
00:36:29,267 --> 00:36:30,299
the Codegen,
Codegen,

851
00:36:30,367 --> 00:36:33,769
The default I believe is this one Class Definition,
默认我相信这是一个类的定义,

852
00:36:33,837 --> 00:36:36,837
If you choose this one it will generate that subclass for
如果你选择这个会生成子类

853
00:36:36,906 --> 00:36:38,873
you and it will just work,
你只会工作,

854
00:36:38,942 --> 00:36:41,809
Okay, you'll be able to access your tweets as a class
好的,你可以访问你的微博作为一个类

855
00:36:41,878 --> 00:36:42,543
called tweet,
推特,

856
00:36:42,612 --> 00:36:44,744
With all the vars,
所有的var,

857
00:36:44,813 --> 00:36:46,312
Now this sounds good and
现在,这听起来不错

858
00:36:46,381 --> 00:36:49,215
it is good; by the way if you do this class definition
它是好的,如果你做这类定义

859
00:36:49,284 --> 00:36:52,251
codegen it will not show up in your navigator,
codegen它不会出现在你的导航器,

860
00:36:52,320 --> 00:36:54,686
It's all behind the scenes- you never really see this file
这都是在幕后,你从来没有真正看到这个文件

861
00:36:54,755 --> 00:36:58,290
that is, this codegen file that generates,
这个codegen文件生成,

862
00:36:58,359 --> 00:36:59,024
So don't look for
所以不要找

863
00:36:59,092 --> 00:37:00,792
it there if you put this on class definition,
如果你把这类定义,

864
00:37:00,861 --> 00:37:02,393
This might even be the default actually,
这实际上可能是默认的,

865
00:37:02,461 --> 00:37:04,028
To be Class Definition might be on,
类定义可能在,

866
00:37:05,063 --> 00:37:07,030
But there's other choices in here,
但是有其他的选择,

867
00:37:07,099 --> 00:37:11,200
And the one we choose the most often is Category/Extension,
和我们选择最经常是类别/扩展,

868
00:37:11,269 --> 00:37:15,271
By the way, category just is the Objective-C word for
顺便说一下,类别的objective - c字

869
00:37:15,339 --> 00:37:16,805
extension,
扩展,

870
00:37:16,874 --> 00:37:20,008
Objective-C has something like extensions called categories,
objective - c有类似扩展称为类别,

871
00:37:20,077 --> 00:37:21,809
So that's why it says Category/Extension,
这就是为什么它说类别/扩展,

872
00:37:21,878 --> 00:37:24,845
But you can think in your mind that this just says extension,
但是你可以在你的头脑中认为这只是说扩展,

873
00:37:24,914 --> 00:37:28,215
And what this is gonna do is only generate an extension
这是要做的只是生成一个扩展

874
00:37:28,284 --> 00:37:30,017
of your Tweet class,
你的推类,

875
00:37:30,085 --> 00:37:32,852
You have to actually write the Tweet class itself,
你必须写微博类本身,

876
00:37:32,921 --> 00:37:35,121
But it's all gonna have only your code in it, or
但都是只有你的代码,或

877
00:37:35,190 --> 00:37:36,989
it could be empty if you want,
它可以是空的,如果你想要的,

878
00:37:37,058 --> 00:37:40,325
The extension's gonna take care of all making the vars,
扩展会照顾所有的增值,

879
00:37:40,394 --> 00:37:42,061
Okay, the var magic right there,
好的,var魔法,

880
00:37:43,497 --> 00:37:47,165
So let's see how this works,
让我们看看这是如何工作的,

881
00:37:47,234 --> 00:37:48,933
Even when I switch to Category/Extension,
甚至当我切换到分类/扩展,

882
00:37:49,002 --> 00:37:51,268
Again, I don't get that extension showing up in
我不出现在得到扩展

883
00:37:51,337 --> 00:37:52,035
my navigator,
我的导航器,

884
00:37:52,104 --> 00:37:54,838
It's kind of hidden from you,
这是一种隐藏的你,

885
00:37:54,907 --> 00:37:57,674
Here I'm gonna add the extension way of doing it for
在这里我要添加扩展的方法

886
00:37:57,742 --> 00:37:58,507
TwitterUser too,
TwitterUser也

887
00:37:58,576 --> 00:38:01,176
So both of them, both Tweet and TwitterUser, I'm gonna
所以他们两人,推特和TwitterUser,我要

888
00:38:01,245 --> 00:38:07,182
have an extension generated and, why do we like this one?
生成一个扩展,我们为什么要这样?

889
00:38:07,251 --> 00:38:08,917
Because, a lot of times for
因为,很多时候

890
00:38:08,986 --> 00:38:11,520
our Tweet or TwitterUser we want to add our own code,
我们的推特或TwitterUser我们想添加自己的代码,

891
00:38:13,222 --> 00:38:14,021
Like in a tweet,
像在一条微博,

892
00:38:14,089 --> 00:38:18,859
Imagine you wanted to add a static method that took data
想象你想添加一个静态方法,数据

893
00:38:18,927 --> 00:38:22,595
from Twitter and turned it into a tweet in the database,
来自Twitter和把它变成了一条微博在数据库中,

894
00:38:22,664 --> 00:38:23,930
Where would you put that code?
你把这段代码在哪里?

895
00:38:23,998 --> 00:38:26,498
Well, a great place to put it would be in a tweet class,
一个伟大的地方放它在推类,

896
00:38:26,567 --> 00:38:27,699
if there was such a thing,
如果有这样的事情,

897
00:38:27,768 --> 00:38:30,502
And so, you're in fact, going to create such a thing,
事实上,所以,你要创造这样一个东西,

898
00:38:30,571 --> 00:38:33,772
And the extension is going to handle all of the var business
和var的扩展将处理所有业务

899
00:38:33,841 --> 00:38:34,705
for you,
给你的,

900
00:38:34,774 --> 00:38:37,708
If you did choose Manual/None, right here for Codegen,
如果你选择手动/没有,这里Codegen,

901
00:38:37,777 --> 00:38:40,544
meaning don't do any Codegen, then you're doing value for
意思不做任何Codegen,那么你做的价值

902
00:38:40,613 --> 00:38:41,445
set value for key,
为关键的设置值,

903
00:38:43,081 --> 00:38:45,682
Good luck with that, the code's gonna be a mess, okay?
祝你好运,代码会一团糟,好吗?

904
00:38:45,750 --> 00:38:48,284
So, we almost always do it this way with this extension,
所以,我们几乎总是这样做这个扩展,

905
00:38:49,654 --> 00:38:52,721
Also, if we build our app using multiple modules
同样,如果我们构建应用程序使用多个模块

906
00:38:52,789 --> 00:38:55,523
like we have in Smash Tag, we have a framework module and
就像我们在粉碎标签,我们有一个模块和框架

907
00:38:55,592 --> 00:38:57,158
then we have the main module,
然后我们有主模块,

908
00:38:57,227 --> 00:38:58,926
Then you're probably gonna wanna choose
然后你可能会想选择

909
00:38:58,995 --> 00:39:01,228
from this pull-down here where it says module,
从这个下拉模块,

910
00:39:01,297 --> 00:39:03,230
current product module,
当前的产品模块,

911
00:39:03,299 --> 00:39:06,467
I think if you have a single app that's not modularized
我认为如果你有一个单独的应用程序,不是模块化

912
00:39:06,535 --> 00:39:10,470
like that you probably don't need to set that, but
这样你可能不需要设置,但是

913
00:39:10,539 --> 00:39:14,707
in a multi-modual app you probably do want to,
在你可能想multi-modual应用,

914
00:39:14,776 --> 00:39:18,577
So, since we've chosen here to create only the extension,
所以,既然我们选择这里创建的扩展,

915
00:39:18,646 --> 00:39:22,080
we obviously need to write the code for the classes Tweet And
我们显然需要编写的代码类微博

916
00:39:22,149 --> 00:39:25,017
TwitterUser, we have to create those classes ourselves,
TwitterUser,我们必须创建这些类,

917
00:39:25,085 --> 00:39:26,551
So how do we do that?
那么我们该如何做呢?

918
00:39:26,619 --> 00:39:28,419
Well, just like we create anything,
好吧,就像我们创造任何东西,

919
00:39:28,487 --> 00:39:30,220
we use file, new file,
我们使用文件,新文件,

920
00:39:30,289 --> 00:39:32,256
Then we do file, new file, this time we are back
然后我们做文件,新文件,这一次我们又回来了

921
00:39:32,325 --> 00:39:35,559
to saying it's a cocoa touch class because NSManageObject,
说它是一个因为NSManageObject可可触摸类,

922
00:39:35,628 --> 00:39:37,660
Why is it code called cocoa touch class,
为什么代码叫做可可触摸类,

923
00:39:37,729 --> 00:39:40,229
we wanna make sure we set our super class to be in its
我们要确保我们的超类

924
00:39:40,297 --> 00:39:42,030
managed object, right?
管理对象,对吧?

925
00:39:42,099 --> 00:39:43,665
So, I'm creating a class called Tweet,
所以,我创建一个类称为Tweet,

926
00:39:43,734 --> 00:39:46,701
you see, which is a subclass of NSManagedObject,
你看,这是NSManagedObject的子类,

927
00:39:46,770 --> 00:39:48,436
And is gonna create this for us,
会为我们创建这个,

928
00:39:48,504 --> 00:39:51,539
See? Class Tweet: NSManagedObject,
看到了吗?

929
00:39:51,608 --> 00:39:52,706
No code in there,
没有代码,

930
00:39:52,775 --> 00:39:56,043
That space is for us, we get write anything we want,
空间对我们来说,我们得到写任何我们想要的,

931
00:39:56,112 --> 00:39:58,778
The code that does the vars is in that extension which we
的代码的var在扩展我们

932
00:39:58,847 --> 00:39:59,746
don't even see, but but
甚至没有看到,但是

933
00:39:59,815 --> 00:40:02,082
I'm gonna show it to yo in a second here,
我将展示给你在第二个,

934
00:40:04,785 --> 00:40:07,452
Notice that I picked the name of this class Tweet
注意,我选择这门课的名字

935
00:40:07,521 --> 00:40:09,888
to be the same as the name of the entity in the database,
是一样的实体的名称在数据库中,

936
00:40:09,956 --> 00:40:12,290
which, you want to do,
你想做什么,

937
00:40:12,359 --> 00:40:16,027
It is possible to not do that by inspecting the entity
可以不通过检查实体

938
00:40:16,096 --> 00:40:18,229
in the data model, but, don't do it,
的数据模型,但不这样做,

939
00:40:18,298 --> 00:40:20,231
Just have the entity with the same name,
具有相同名称的实体,

940
00:40:20,299 --> 00:40:22,699
People reading your code are going to expect this class,
阅读代码的人会期待这门课,

941
00:40:22,768 --> 00:40:24,400
this subclass of NSManageObject that
这个子类NSManageObject

942
00:40:24,469 --> 00:40:25,602
represents a tweet,
代表一条微博,

943
00:40:25,670 --> 00:40:28,371
Entity to be called tweet, so called it that,
实体被称为tweet,所以叫它,

944
00:40:30,441 --> 00:40:33,708
Now, we've got an error here, I'll just created this class,
现在,这里有一个错误,我就创建了这个类,

945
00:40:33,777 --> 00:40:34,976
how I'm gonna possibly have an error,
我怎么可能有一个错误,

946
00:40:35,045 --> 00:40:36,944
I'm done anything how could I've done anything wrong?
我做什么怎么做错什么了?

947
00:40:37,013 --> 00:40:38,379
Well, the problem the problem here is,
嗯,这里的问题是问题,

948
00:40:38,448 --> 00:40:41,081
really, Xcode has done something wrong,
真的,Xcode所做的错事,

949
00:40:41,150 --> 00:40:45,685
When Xcode created this, it didn't seem to realize that
当Xcode创建时,它似乎并没有意识到

950
00:40:45,754 --> 00:40:47,687
NSManageObject is not in UIKit,
NSManageObject UIKit,

951
00:40:47,756 --> 00:40:50,790
You see how it put import UIKit at the top?
你看到它如何把进口UIKit顶部吗?

952
00:40:50,859 --> 00:40:54,593
Really, what we need there is import CoreData, okay,
真的,我们需要有进口CoreData,好吧,

953
00:40:54,662 --> 00:40:55,761
All the code that you write,
所有你写的代码,

954
00:40:55,829 --> 00:40:57,129
any time you're doing something in CoreData,
任何时候你做一些CoreData,

955
00:40:57,198 --> 00:40:58,997
you have to import CoreData,
你有进口CoreData,

956
00:40:59,065 --> 00:41:01,032
It's a different framework that the UIKit so
这是一个不同的框架,UIKit

957
00:41:01,101 --> 00:41:02,934
you must import it everywhere that you're going to use it,
你必须导入它无处不在,你要使用它,

958
00:41:03,002 --> 00:41:05,235
Just like we had to import Twitter everywhere we want to
就像无处不在我们想进口Twitter

959
00:41:05,304 --> 00:41:06,937
use that Twitter framework that I gave you,
我给你使用Twitter框架,

960
00:41:08,507 --> 00:41:09,906
So, I don't know why Xcode, I think it's just an oversight
所以,我不知道为什么Xcode,我认为它只是一个监督

961
00:41:09,907 --> 00:41:11,306
Okay?
好吧?

962
00:41:11,376 --> 00:41:13,842
that Xcode when you choose NSManagedObject
,当你选择NSManagedObject Xcode

963
00:41:13,911 --> 00:41:15,944
as your super class you should know, that's in Core Data so
作为超类你应该知道,在核心数据

964
00:41:16,013 --> 00:41:17,546
it should be import Core Data there,
它应该是进口核心数据,

965
00:41:17,614 --> 00:41:19,714
Don't know why it doesn't do that,
不知道为什么它没有这样做,

966
00:41:19,782 --> 00:41:22,784
So here I've created one for the TwitterUser class,
所以我创建了一个用于TwitterUser类,

967
00:41:22,852 --> 00:41:25,352
Again you can put anything you want in there,
你可以把你想要的任何东西,

968
00:41:25,421 --> 00:41:26,219
This is your class,
这是你的类,

969
00:41:26,288 --> 00:41:27,086
You can do anything you want,
你可以做任何你想要的,

970
00:41:27,155 --> 00:41:29,588
All the stuff about the vars is off in
所有的东西在var

971
00:41:29,657 --> 00:41:31,390
an extension somewhere,
一个扩展的地方,

972
00:41:31,459 --> 00:41:34,092
In fact, let's go take a look at that extension,
事实上,我们去看看扩展,

973
00:41:34,161 --> 00:41:34,910
Even though it's not going to show up in your next navigator
即使它不会出现在你的下一个导航器

974
00:41:34,911 --> 00:41:35,660
what it looks like,
它看起来像什么,

975
00:41:35,729 --> 00:41:37,127
you're probably never going to look at it,
你可能永远不会看,

976
00:41:37,196 --> 00:41:38,363
I thought I'd show it to you so
我想展示给你

977
00:41:38,431 --> 00:41:40,164
you understand a little bit what's going on,
你了解一点这是怎么回事,

978
00:41:40,232 --> 00:41:43,300
So, this is the extension, this generated for
这是扩展,这个生成的

979
00:41:43,369 --> 00:41:43,933
TwitterUser,
TwitterUser,

980
00:41:44,002 --> 00:41:45,568
You see that is an extension
你可以看到这是一个扩展

981
00:41:45,637 --> 00:41:47,236
of the TwitterUser class, right?
TwitterUser类的,对吧?

982
00:41:47,305 --> 00:41:52,074
Remember extensions and it's got the vars,
记得扩展了var,

983
00:41:52,143 --> 00:41:54,643
They're defined not just name and screenName but
他们不仅定义名字和屏幕名

984
00:41:54,712 --> 00:41:57,279
it's got that relationship var tweets as well,
它有这种关系var推,

985
00:41:58,281 --> 00:41:59,012
All right?
好吧?

986
00:41:59,081 --> 00:42:01,048
And look at the type of tweets,
看看微博的类型,

987
00:42:01,116 --> 00:42:03,917
As promised, it's an NSSet, it's an optional because it
作为承诺,NSSet,它是一个可选的,因为它

988
00:42:03,986 --> 00:42:07,153
comes out of the database as not set,
出来的数据库没有设置,

989
00:42:07,222 --> 00:42:08,221
It's gonna get set,
它会得到设置,

990
00:42:09,823 --> 00:42:11,022
So these are the vars,
这些是var,

991
00:42:11,091 --> 00:42:12,224
And I'll talk a little bit about
和我谈一谈

992
00:42:12,292 --> 00:42:17,095
how these vars are actually implemented in a minute but
这些var实际上是如何实现在一分钟吗

993
00:42:17,164 --> 00:42:18,463
all the vars are there,
所有的vars那里,是

994
00:42:18,532 --> 00:42:19,663
There's also some functions,
也有一些功能,

995
00:42:19,732 --> 00:42:20,964
now at the bottom you see those functions,
现在在底部你看到这些功能,

996
00:42:21,033 --> 00:42:23,967
those are kind of fun, those are convenience functions for
这些都是很有趣的,这些都是方便的功能

997
00:42:24,036 --> 00:42:28,438
adding and removing tweets from the tweets set
添加和删除微博的微博

998
00:42:28,506 --> 00:42:33,876
because NSSet is immutable, okay?
因为NSSet是不可变的,对吧?

999
00:42:33,945 --> 00:42:36,913
It's not var verses let like swift things,
这不是var诗句让喜欢斯威夫特的东西,

1000
00:42:36,981 --> 00:42:40,349
NS set is kind of old Objective-C way, and NSSet,
NS组是一种古老的objective - c,NSSet,

1001
00:42:40,418 --> 00:42:44,552
like NSAttributedString, is immutable, cannot be changed,
像NSAttributedString,是不可变的,无法改变,

1002
00:42:44,621 --> 00:42:47,588
so how can I add any tweets to my database here?
那么我可以在这里添加任何推到我的数据库吗?

1003
00:42:47,657 --> 00:42:50,158
Well you used these functions instead, add to tweets,
你使用这些函数相反,增加微博,

1004
00:42:50,226 --> 00:42:51,825
remove from tweets, add to tweets,
删除微博,添加微博,

1005
00:42:51,894 --> 00:42:55,896
remove from tweets, there's a pair for doing a single tweet,
删除从微博,有一对做一个微博,

1006
00:42:55,965 --> 00:42:58,531
and there having adding a whole bunch of tweets, or
在加一大堆的tweet,或

1007
00:42:58,600 --> 00:43:00,833
removing a whole bunch of tweets, okay?
删除很多微博,好吗?

1008
00:43:00,902 --> 00:43:03,603
So you're definitely going to want those functions for
所以你肯定会想要这些功能

1009
00:43:03,671 --> 00:43:04,337
your assignment five,
作业五,

1010
00:43:05,840 --> 00:43:08,540
Cuz you're gonna have some relationships where you're
因为你会有你的关系

1011
00:43:08,608 --> 00:43:11,609
gonna want to add them using these functions,
要想将它们添加使用这些函数,

1012
00:43:11,678 --> 00:43:12,643
Now it adds those functions for
现在添加这些功能

1013
00:43:12,712 --> 00:43:16,346
any too many relationship, any time you have a too many var
任何太多的关系,任何时候你有太多的var

1014
00:43:16,415 --> 00:43:19,549
like tweets, it's going to add these functions automatically
就像微博一样,它会自动添加这些功能

1015
00:43:19,618 --> 00:43:21,151
It actually put it in its own little extension, this file
它实际上把它放在自己的扩展,这个文件

1016
00:43:21,152 --> 00:43:22,685
in the extensions,
在扩展,

1017
00:43:22,754 --> 00:43:26,622
has two extensions in it, both through TwitterUser,
有两个扩展,通过TwitterUser,

1018
00:43:26,691 --> 00:43:29,825
Any questions about extensions there or any of that?
任何扩展或有任何问题吗?

1019
00:43:29,894 --> 00:43:34,429
Okay, let's look at tweets extension real quick,
好吧,让我们来看看微博扩展很快,

1020
00:43:34,498 --> 00:43:36,565
Couple other things to look at here that I didn't look
看一些其他的内容我没有看

1021
00:43:36,634 --> 00:43:37,599
in the other one,
在另一个,

1022
00:43:37,667 --> 00:43:41,035
Notice this static func called fetchRequest?
注意到这个静态函数称为fetchRequest吗?

1023
00:43:41,103 --> 00:43:41,735
Put that in your mind,
把它放在你的思想,

1024
00:43:41,804 --> 00:43:43,904
I'm gonna talk about that in a few slides,
我要讲几张幻灯片,

1025
00:43:43,973 --> 00:43:46,640
fetchRequest is a really cool little static func that will
fetchRequest是一个很酷的小静态函数

1026
00:43:46,709 --> 00:43:50,577
give you something you can use to fetch tweets,
给你一些你可以用来获取tweet,

1027
00:43:50,646 --> 00:43:52,245
And if you call fetchrRquest on twitter users,
如果你打电话给fetchrRquest twitter用户,

1028
00:43:52,313 --> 00:43:54,213
you'll get something to fetch twitter users,
你会获取twitter用户,

1029
00:43:54,282 --> 00:43:57,282
And we'll talk about all about fetch in a moment here,
我们会讨论关于引进一个时刻,

1030
00:43:57,351 --> 00:44:01,886
Notice the type of tweeter, see the tweeter var,
注意到推特的类型,看到推特var,

1031
00:44:01,955 --> 00:44:04,589
Its type is TwitterUser,
它的类型是TwitterUser,

1032
00:44:04,657 --> 00:44:06,324
Because of course that's what the tweeter is,
因为这是推特,

1033
00:44:06,393 --> 00:44:09,494
we control drag between the tweet and the tweeter user so
我们控制拖在微博和推特用户

1034
00:44:09,562 --> 00:44:11,929
that tweeter var is of course a tweeter user,
推特var当然是推特的用户,

1035
00:44:11,997 --> 00:44:15,432
not an NSSet, because it's a two one relationship, okay,
不是NSSet,因为它是一二一的关系,好吧,

1036
00:44:15,501 --> 00:44:18,301
there's only one TwitterUser, who is my tweeter,
只有一个TwitterUser,谁是我的推特,

1037
00:44:20,105 --> 00:44:23,138
And what about this @NSManaged?
这@NSManaged呢?

1038
00:44:23,207 --> 00:44:27,009
Okay, @NSManaged I'm just gonna say it's magic,
好的,@NSManaged我会说这是魔法,

1039
00:44:27,077 --> 00:44:28,210
It's not really magic,
这不是魔术,

1040
00:44:28,278 --> 00:44:33,181
It's essentially something that says to the runtime, hey,
它本质上是说到运行时的东西,嘿,

1041
00:44:33,250 --> 00:44:35,083
When someone accesses this var,
当有人访问这个变量,

1042
00:44:35,152 --> 00:44:37,485
Core Data's gonna figure it out for you,
核心数据会算出来给你,

1043
00:44:37,554 --> 00:44:40,053
And what Core Data does, is when you try to say
什么核心数据,当你试图说

1044
00:44:40,122 --> 00:44:45,058
Tweet,created equals some date, it gets trapped
推特,创建等于某个日期,它被困

1045
00:44:45,127 --> 00:44:48,228
at a low level in the runtime and Core Data swoops in and
在一个较低水平,俯冲而下,在运行时和核心数据

1046
00:44:48,297 --> 00:44:51,731
does set value for key for you, okay,
设置值为关键,好的,

1047
00:44:51,799 --> 00:44:55,268
Same thing if you get the created var, it swoops in and
同样的事情如果你创建的var,俯冲而下

1048
00:44:55,337 --> 00:44:57,603
does value for key and gets it that way,
对关键值,这样,

1049
00:44:57,671 --> 00:45:01,339
But it's all happening at a low level behind the scenes,
但这都是发生在一个较低水平,在幕后,

1050
00:45:01,408 --> 00:45:05,309
So this extension does satisfy the extension limitation where
这扩展并满足扩展限制

1051
00:45:05,378 --> 00:45:06,544
it can't have any storage,
它不能有任何存储,

1052
00:45:06,612 --> 00:45:09,580
All of the storage for these vars isn't in the database,
所有的数据库中存储这些var不是,

1053
00:45:10,616 --> 00:45:12,416
And when you ask for it,
当你问,

1054
00:45:12,484 --> 00:45:14,985
Or when you set it, it's using its value for
或者当你设置它,使用它的价值

1055
00:45:15,053 --> 00:45:17,019
key instead of value for key, to set it in the database,
关键值的键,设置它在数据库中,

1056
00:45:17,088 --> 00:45:18,087
Now again, it sets in memory,
现在,它集在内存中,

1057
00:45:18,156 --> 00:45:19,021
You have to save it for
你必须保存它

1058
00:45:19,090 --> 00:45:20,955
it to actually go out into the database,
实际上,出去到数据库中,

1059
00:45:21,024 --> 00:45:25,159
But that what's happening,
但是,发生了什么,

1060
00:45:25,228 --> 00:45:29,130
All right, so
好吧,那么

1061
00:45:29,199 --> 00:45:34,334
now that we have these class so here's some
现在,这里是一些我们有这些类

1062
00:45:34,403 --> 00:45:39,206
code that creates a tweets and sets it's attributes, okay so
代码创建一个tweet,并设置它的属性,所以

1063
00:45:39,274 --> 00:45:41,875
let's look at this piece by piece and see what it does,
让我们看看这一块一块的,看看,

1064
00:45:41,943 --> 00:45:45,078
The first thing is to create a tweet, we don't have to do
第一件事是创建一个tweet,我们不需要做

1065
00:45:45,146 --> 00:45:49,449
NSEntityDescription, Entity, insert Entity for name into
NSEntityDescription,实体,实体名称插入

1066
00:45:49,517 --> 00:45:52,318
contacts, or whatever that huge, long terrible thing was-
联系人,或任何巨大,长——可怕的事情

1067
00:45:52,386 --> 00:45:55,421
we can just say, tweet, parenthesis context,
我们可以说,推特,括号的背景下,

1068
00:45:55,489 --> 00:45:58,223
You just say what context, which means what database you
你说什么情况下,这意味着你的数据库

1069
00:45:58,292 --> 00:46:00,859
want the tweet to put in and it creates a new tweet,
希望推放在它创建一个新的微博,

1070
00:46:00,928 --> 00:46:03,994
Okay, just use a normal initializer for
好的,只使用一个正常初始化

1071
00:46:04,063 --> 00:46:05,496
new things so that's super cool,
新事物,这样的超级酷,

1072
00:46:05,565 --> 00:46:07,364
That's one of the coolest features right there,
这是最酷的功能之一,

1073
00:46:07,432 --> 00:46:09,666
Not having to use an NSEntityDescription thing, so
没有使用一个NSEntityDescription事情,所以

1074
00:46:09,735 --> 00:46:13,002
no more NSEntityDescription, we'll not have to do that,
NSEntityDescription,我们不需要这样做,

1075
00:46:13,071 --> 00:46:13,769
And then here,
然后在这里,

1076
00:46:13,838 --> 00:46:18,107
I'm setting the text to be 140 characters of pure joy,
我要140个字符设置文本纯粹的快乐,

1077
00:46:18,175 --> 00:46:21,176
And I don't have to say set value 140 characters of pure
我不必说值140个字符的纯

1078
00:46:21,244 --> 00:46:24,646
joy for key text and have all these literal strings like
快乐关键文本和所有这些字符串

1079
00:46:24,715 --> 00:46:28,016
text in there in this untyped thing,
文本在这无类型的事情,

1080
00:46:28,084 --> 00:46:29,918
I just say tweet,text equals that,
我只是说推特,文本=,

1081
00:46:29,986 --> 00:46:33,620
And the same thing here with created, again, so we don't
和创建同样的事,所以我们不

1082
00:46:33,689 --> 00:46:36,857
even have to worry about the thing, if we tried to say
甚至需要担心的事情,如果我们试图说

1083
00:46:36,926 --> 00:46:41,228
tweet,created equals quote hello, this Swift would say,
推特,创造=报价你好,我迅速会说,

1084
00:46:41,297 --> 00:46:44,330
no, created is of type Date, so you can't do that, so
不,创建日期类型,所以你不能这样做

1085
00:46:44,399 --> 00:46:46,899
it finds all of our, it type checks everything,
它发现我们所有的类型检查一切,

1086
00:46:46,968 --> 00:46:49,801
finds all of our possible errors,
发现我们所有的可能的错误,

1087
00:46:49,870 --> 00:46:52,170
What about relationships, okay, setting relationships?
是什么关系,设置关系?

1088
00:46:52,239 --> 00:46:56,675
So here I've created another object, a TwitterUser and
所以我创建了另一个对象,TwitterUser和

1089
00:46:56,743 --> 00:46:59,144
again I just set TwitterUser with a context,
我刚和一个上下文设置TwitterUser,

1090
00:46:59,212 --> 00:47:01,111
I'll talk about that argument in just a second but
我将讨论这个论点只是一秒

1091
00:47:01,180 --> 00:47:06,050
I told what database I wanna create in TwitterUser and
我告诉什么我想创建TwitterUser和数据库

1092
00:47:06,118 --> 00:47:10,588
I set my tweet's tweeter equal to that TwitterUser,
我把我的推特的推特TwitterUser等于,

1093
00:47:10,656 --> 00:47:12,522
So, it's exactly what you're, would imagine right?
所以,这就是你,想象对吗?

1094
00:47:12,591 --> 00:47:14,290
Just set it equal to Joe,
把它等于乔,

1095
00:47:14,359 --> 00:47:18,794
And what's interesting about this is that when you set one
有趣的是,当你设置一个

1096
00:47:18,863 --> 00:47:22,865
side of a relationship, the other side gets updated
方的关系,另一方得到更新

1097
00:47:22,934 --> 00:47:26,001
automatically, 100% of the time,
自动,100%的时间,

1098
00:47:26,070 --> 00:47:27,369
This is call maintaining
这是呼叫保持

1099
00:47:27,438 --> 00:47:30,038
the integrity of the database, okay?
数据库的完整性,对吧?

1100
00:47:30,106 --> 00:47:33,341
And Core Data always maintains database integrity,
和核心数据总是保持数据库的完整性,

1101
00:47:33,410 --> 00:47:35,543
So, when you change one side relationship,
所以,当你改变一方的关系,

1102
00:47:35,611 --> 00:47:36,710
It changes the other,
它改变了,

1103
00:47:36,779 --> 00:47:39,546
So, that means for example if I say tweet,tweeter
所以,这意味着例如如果我说推特,推特

1104
00:47:39,614 --> 00:47:42,282
equals Joe, then if I went over to the Joe side and
等于乔,那么如果我走到乔一边

1105
00:47:42,350 --> 00:47:46,152
said hey give me Joe's tweets and I'm even gonna turn it
说嗨乔给我的推特,我甚至会把它

1106
00:47:46,220 --> 00:47:49,855
into a Swift kind of set from an NSSet to a set of
为一种快速组从NSSet到一组

1107
00:47:49,924 --> 00:47:52,291
tweet because we know that's what tweets are, right?
微博因为我们知道微博是什么,对吧?

1108
00:47:52,360 --> 00:47:56,461
Tweets are a set of Tweets, so I'm gonna as it to do that,
推特是一组微博,所以我要这样做,

1109
00:47:56,530 --> 00:48:00,365
Then I can say, if Joe's tweet contains that tweet print yes
我可以说,如果乔的这条微博包含打印是的

1110
00:48:00,434 --> 00:48:02,533
and of course it is going to print yes,
当然,它将打印是的,

1111
00:48:02,602 --> 00:48:05,002
Because when I said tweet,tweeter = joe,
因为当我说推特,推特=乔,

1112
00:48:05,071 --> 00:48:07,538
it automatically got added to joe's tweets,
它会自动添加到乔的微博,

1113
00:48:08,573 --> 00:48:09,238
That make sense?
这说得通吗?

1114
00:48:09,307 --> 00:48:10,640
And same thing the other way,
一样和其他方式,

1115
00:48:10,709 --> 00:48:13,375
If I added a tweet into joe's tweets,
如果我添加了一个推到乔的微博,

1116
00:48:13,444 --> 00:48:16,112
that tweet tweeter would automatically set to be joe,
微博推特会自动将乔,

1117
00:48:17,614 --> 00:48:18,546
Okay? Both sides will always
好吧?

1118
00:48:18,615 --> 00:48:19,614
point to each other,
指向对方,

1119
00:48:19,682 --> 00:48:21,482
You never have to do anything to make that happen,
你不必做任何事情发生,

1120
00:48:23,086 --> 00:48:27,688
tweet,tweeter=joe is exactly
推特,推特=乔就是

1121
00:48:27,756 --> 00:48:30,623
the same as saying joe dot addToTweets tweet,
说乔•addToTweets tweet,一样

1122
00:48:30,692 --> 00:48:32,959
Remember addToTweets is one of those convenience functions
记住addToTweets是其中的一个便利的函数

1123
00:48:33,027 --> 00:48:34,427
that it created for us over there,
它为我们创造了,

1124
00:48:35,763 --> 00:48:37,529
Now, notice the argument I used for
现在,请注意我用的论证

1125
00:48:37,598 --> 00:48:40,398
the context to create the Twitter user there,
上下文创建Twitter用户,

1126
00:48:40,467 --> 00:48:43,434
I didn't say AppDelegate,viewContext,
我没有说AppDelegate viewContext,

1127
00:48:43,503 --> 00:48:45,502
I didn't use that same context bar that I had,
我没有使用相同的上下文酒吧,我,

1128
00:48:45,571 --> 00:48:47,537
I said tweet,manageObjectContext,
我说推特,manageObjectContext,

1129
00:48:47,606 --> 00:48:51,107
In other words, I got, I found out what database the tweet is
换句话说,我得到了,我发现数据库的微博是什么

1130
00:48:51,176 --> 00:48:53,977
in, and I put the Twitter user in the same database,
,我把Twitter用户在同一个数据库中,

1131
00:48:54,046 --> 00:48:57,212
And this is a common way of programming in Core Data
这是一个编程的核心数据的常用方法

1132
00:48:57,281 --> 00:48:59,148
where when you wanna get a context and
当你想要一个上下文,在哪里

1133
00:48:59,217 --> 00:49:01,717
you already have a object in the database you
你已经有一个数据库中的对象

1134
00:49:01,786 --> 00:49:04,786
ask the object you already have what context to use,
问你的对象已经有什么情况下使用,

1135
00:49:04,855 --> 00:49:08,256
And you can see that if I ever change my code to not put this
你可以看到,如果我不把这个曾经改变我的代码

1136
00:49:08,325 --> 00:49:12,059
into this context, to put it into another context, at least
在这种情况下,至少把它放到另一个上下文

1137
00:49:12,128 --> 00:49:14,695
the Twitter user and the tweet would always be together
Twitter用户和微博将永远在一起

1138
00:49:14,764 --> 00:49:16,330
in whatever that context is,
不管上下文,

1139
00:49:16,399 --> 00:49:18,865
So you can see why I used the tweets can't
所以你可以看到我为什么微博不能使用

1140
00:49:18,934 --> 00:49:22,702
manage object context here to create that instead of using
管理对象上下文创建,而不是使用

1141
00:49:22,771 --> 00:49:24,170
the context again,
再次,

1142
00:49:24,239 --> 00:49:26,905
So, it, it would work to say context, of course,
所以,说工作背景下,当然,

1143
00:49:26,974 --> 00:49:30,575
but I'm just saying there's a paradigm of development where
但我只是说有一个范式的发展

1144
00:49:30,644 --> 00:49:33,612
we're gonna try and use the context of related object,
我们将尝试使用上下文相关的对象,

1145
00:49:33,680 --> 00:49:35,480
So they end up in the same database for sure,
所以他们最终在同一个数据库中,

1146
00:49:37,150 --> 00:49:37,715
Okay?
好吧?

1147
00:49:39,385 --> 00:49:41,351
All right, so
好吧,那么

1148
00:49:41,420 --> 00:49:44,821
we can also use dot notation, because these are just vars,
我们还可以使用点符号,因为这些只是var,

1149
00:49:44,889 --> 00:49:47,723
So when I say tweet,tweeter, I get a TwitterUser object,
所以当我说推特,推特,我得到一个TwitterUser对象,

1150
00:49:47,792 --> 00:49:50,059
So, of course, I can say dot name on it and
当然,我能说点的名字

1151
00:49:50,128 --> 00:49:52,228
set it equal to Joe Schmo, whatever, right?
令它等于乔愚人等等,对吗?

1152
00:49:52,296 --> 00:49:57,266
tweet,tweeter,name = "Joe Schmo", all right?
推特,推特,name = "乔愚人”,对吧?

1153
00:49:57,334 --> 00:49:59,134
No restriction there on those vars,
没有限制的var,

1154
00:50:00,703 --> 00:50:03,337
All right, remember I told you about the scalars?
好吧,记住我告诉你的标量吗?

1155
00:50:03,406 --> 00:50:06,240
This is that switch I was telling you about before,
这是开关我之前告诉你,

1156
00:50:06,309 --> 00:50:09,777
If you don't do this, then when you say,
如果你不这样做,当你说,

1157
00:50:09,845 --> 00:50:13,313
if you had an int, let's say you had retweet
如果你有一个int,假设你已经转发

1158
00:50:13,382 --> 00:50:17,950
count which was an int here let's say on Int32,
数是一个int假设Int32,

1159
00:50:18,019 --> 00:50:19,185
If you don't switch this button,
如果你没有这个按钮,切换

1160
00:50:19,253 --> 00:50:22,188
then that's going to be an NSNumber not an Int32,
那是一个NSNumber不是Int32,

1161
00:50:22,256 --> 00:50:24,489
But when you click this switch on,
但是当你点击这个开关,

1162
00:50:24,558 --> 00:50:26,958
now that var will be of type Int32,
现在,var将Int32类型,

1163
00:50:27,027 --> 00:50:28,893
So you almost always want this for numbers,
所以你几乎总是希望这个数字,

1164
00:50:28,962 --> 00:50:32,296
99,9% of the time, you want to have this switch on,
99年,9%的时间,你想有一个开关,

1165
00:50:32,365 --> 00:50:33,964
Luckily, it's on by default so
幸运的是,它在默认情况下

1166
00:50:34,033 --> 00:50:36,065
you don't even have to think about it much, but
你甚至不需要过多地考虑这些,但是

1167
00:50:36,134 --> 00:50:37,300
I just wanted to let you know about it,
我只是想让你知道,

1168
00:50:38,736 --> 00:50:40,970
All right, so now lets talk about deletion,
好,现在让我们谈谈删除,

1169
00:50:41,038 --> 00:50:44,773
Okay, now, I want to delete something from the database,
好的,现在,我想从数据库删除一个条目,

1170
00:50:44,842 --> 00:50:46,641
And that's incredibly easy,
这是令人难以置信的简单,

1171
00:50:46,710 --> 00:50:50,378
almost too easy because your data's precious you don't want
几乎太简单了,因为你的数据是宝贵的你不想要

1172
00:50:50,447 --> 00:50:53,547
to be deleting it to easily, but you do that by asking
删除它很容易,但你问

1173
00:50:53,616 --> 00:50:56,851
the context to delete the NSManagedObject, so you can
中删除的NSManagedObject,这样你就可以

1174
00:50:56,919 --> 00:50:59,920
pass any NSManagedObject to this method delete and
通过任何NSManagedObject这种方法删除

1175
00:50:59,989 --> 00:51:02,189
it will delete it from the database,
它将从数据库中删除它,

1176
00:51:02,258 --> 00:51:05,325
And it could cascade and delete other things as well
和它可以级联删除其他的事情

1177
00:51:05,393 --> 00:51:08,161
depending on what delete rule is, all right?
根据删除规则是什么,对吧?

1178
00:51:08,230 --> 00:51:11,530
Most of the time by default, when I delete something,
大部分时间在默认情况下,当我删除一些东西,

1179
00:51:11,599 --> 00:51:15,067
other things that point to it get that pointer set to nil,
其他的东西,它的指针指向的设置为零,

1180
00:51:15,136 --> 00:51:18,036
That's the nullify delete rule,
这是取消删除规则,

1181
00:51:18,105 --> 00:51:20,038
Now, when things get deleted from the database they got
现在,当事情变得从数据库中删除

1182
00:51:20,107 --> 00:51:23,541
sent this message first, prepare for deletion,
先发送此消息,准备删除,

1183
00:51:23,610 --> 00:51:26,177
Okay, and this is a really good method,
好吧,这是一个很好的方法,

1184
00:51:26,245 --> 00:51:28,812
Again, in here you don't have to do anything
同样,在这里你不需要做任何事

1185
00:51:28,881 --> 00:51:31,748
to worry about the other pointers point to you
担心另一个指针指向你

1186
00:51:31,817 --> 00:51:33,583
that's all fixed by the delete rule,
删除所有固定的规则,

1187
00:51:33,652 --> 00:51:36,919
But what if you had another field in your database?
但是如果你有另一个字段在数据库中?

1188
00:51:36,988 --> 00:51:39,421
Back to the retweet count example again,
再次转发数的例子,

1189
00:51:39,490 --> 00:51:43,592
Let's say I had an int somewhere in TwitterUser,
假设有一个int在TwitterUser某处,

1190
00:51:43,661 --> 00:51:46,227
which counted the number of retweets
计算转发的数量

1191
00:51:46,296 --> 00:51:48,296
that this twitter user had done,
这个twitter用户所做的,

1192
00:51:48,365 --> 00:51:51,065
And so if I was deleting a tweet and it happened to be
如果我删除微博,它的发生而笑

1193
00:51:51,133 --> 00:51:54,902
a retweet then I need to set that to be minus equal one,
转发,那么我需要设置- = 1,

1194
00:51:54,971 --> 00:51:56,636
And here's the perfect place to do it,
这是完美的地方,

1195
00:51:56,705 --> 00:51:58,372
So tweet, and it's prepared for
所以微博,准备

1196
00:51:58,441 --> 00:52:00,507
deletion saying whoop, I'm about to be deleted,
删除说一点点,我要被删除,

1197
00:52:00,575 --> 00:52:03,376
I'd better tell my Twitter user, cuz I'm a retweet,
我最好告诉我的Twitter用户,因为我是一个转发,

1198
00:52:03,444 --> 00:52:07,013
that he needs to decrement his retweet count,
他需要减量转发数,

1199
00:52:07,081 --> 00:52:09,381
So you see why you would use prepare for deletion?
所以你知道为什么你会使用准备删除?

1200
00:52:09,449 --> 00:52:11,416
It's a way to kind of update other things in the database
它是一种方法的更新数据库中的其他事情

1201
00:52:11,485 --> 00:52:14,252
when as you're leaving the database,
当你要离开数据库,

1202
00:52:15,855 --> 00:52:17,955
All right, so that's it for deletion,
好了,这就是删除,

1203
00:52:18,023 --> 00:52:19,789
Next topic, querying,
下一个话题、查询

1204
00:52:19,858 --> 00:52:22,158
the most important piece of this whole database thing,
整个数据库最重要的东西,

1205
00:52:22,227 --> 00:52:24,294
It's really a waste of time doing all this stuff if you're
这真是浪费时间做这些东西如果你

1206
00:52:24,362 --> 00:52:24,961
not gonna query, okay?
不会查询,好吗?

1207
00:52:25,029 --> 00:52:28,831
If you're not gonna make sophisticated requests for
如果你不会做复杂的要求

1208
00:52:28,900 --> 00:52:32,767
the information based on the relationships, etc,
基于关系的信息,等等,

1209
00:52:32,836 --> 00:52:36,238
So, to do a query the most important thing you need to
所以,做一个查询你所需要的最重要的事

1210
00:52:36,306 --> 00:52:40,475
know is NSFetchRequest, this class NSFetchRequest,
知道这类NSFetchRequest NSFetchRequest,,

1211
00:52:40,544 --> 00:52:43,077
And NSFetchRequest encapsulates
和NSFetchRequest封装

1212
00:52:43,146 --> 00:52:45,946
what you want from the database,
你想要从数据库中,

1213
00:52:46,015 --> 00:52:47,915
So let's talk about an NSFetchRequest and
所以让我们来谈谈一个NSFetchRequest和

1214
00:52:47,984 --> 00:52:51,351
how we build one,
如何构建一个,

1215
00:52:51,420 --> 00:52:52,552
So when we're building one,
所以当我们正在构建一个,

1216
00:52:52,621 --> 00:52:54,487
there's three important things we need to know,
有三个重要的事情我们需要知道,

1217
00:52:54,556 --> 00:52:57,323
One, what entity are we fetching?
1、我们抓取的实体是什么?

1218
00:52:57,391 --> 00:53:01,626
Because a FetchRequest can only Fetch one kind of entity,
因为FetchRequest只能获取一种实体,

1219
00:53:01,695 --> 00:53:03,962
You can, there's no such thing a FetchRequest that will give
可以,没有这样的事FetchRequest给

1220
00:53:04,031 --> 00:53:06,565
you some tweet and some Twitter user,
你一些推特和Twitter用户,

1221
00:53:06,633 --> 00:53:07,464
No, okay?
不,好吗?

1222
00:53:07,533 --> 00:53:09,700
A fetch always gives you all tweets or
获取总是给你所有微博或

1223
00:53:09,769 --> 00:53:12,136
all Twitter users, make sense?
Twitter的用户,有意义吗?

1224
00:53:12,205 --> 00:53:13,070
So that's the number one thing,
这是一件事,

1225
00:53:13,139 --> 00:53:14,905
is we're gonna create the fetch request,
我们要创建获取请求,

1226
00:53:14,973 --> 00:53:17,606
And it will be a fetch request or a very specific entity,
这将是一个获取请求或一个非常具体的实体,

1227
00:53:17,675 --> 00:53:20,576
And it will only be able to fetch those entities,
它只能取回这些实体,

1228
00:53:20,645 --> 00:53:24,446
The second thing is is an array of sort descriptors,
第二件事是数组类型描述符,

1229
00:53:24,515 --> 00:53:25,647
And why do we want this?
为什么我们想要的吗?

1230
00:53:25,716 --> 00:53:29,017
Because when we execute this fetch it's gonna come back
因为当我们执行这个取回它会回来

1231
00:53:29,086 --> 00:53:31,151
as an array, okay?
作为一个数组,好吗?

1232
00:53:31,220 --> 00:53:32,753
All the matching tweets or
所有匹配的tweet

1233
00:53:32,822 --> 00:53:34,888
Twitter user will come back in an array,
Twitter用户会回来在一个数组,

1234
00:53:34,957 --> 00:53:35,922
And since it's an array,
因为它是一个数组,

1235
00:53:35,991 --> 00:53:39,693
arrays are not sets, arrays are ordered and so
数组不是集,数组是有序的,所以

1236
00:53:39,761 --> 00:53:42,361
we have specify what order the things are in the arrays,
我们已经指定数组中的事情,

1237
00:53:42,430 --> 00:53:44,830
So we do that with these sort descriptors,
所以我们使用这类描述符,

1238
00:53:44,898 --> 00:53:47,833
And finally, we just specify or what is it that we want,
最后,我们只是指定或者我们想要什么,

1239
00:53:47,902 --> 00:53:51,236
which tweets do we want, which Twitter users do we want and
微博我们想要,Twitter用户做我们想要的吗

1240
00:53:51,305 --> 00:53:53,971
we do that with something called a predicate,
我们所做的,在一个叫做谓词,

1241
00:53:54,040 --> 00:53:55,039
Okay, so let's dive in and
好的,让我们在和潜水

1242
00:53:55,107 --> 00:53:57,174
look at all three of these things,
看看这三个东西,

1243
00:53:57,243 --> 00:53:58,575
This is what it looks like,
这就是它的样子,

1244
00:53:58,644 --> 00:54:00,777
kinda top level to create a fetch request,
有点顶层创建获取请求,

1245
00:54:00,846 --> 00:54:02,479
Okay, you get a fetch request,
好的,你会得到一个获取请求,

1246
00:54:02,547 --> 00:54:04,447
You set the source descriptor and you set its predicate,
你设置源描述符设置它的谓语,

1247
00:54:04,516 --> 00:54:07,016
So you get each of these three parts,
所以这三个部分,

1248
00:54:07,085 --> 00:54:08,650
So getting the fetch request is easy,
所以获取请求是很容易的,

1249
00:54:08,719 --> 00:54:10,852
We're gonna use that little static function
我们将使用这个小静态函数

1250
00:54:10,921 --> 00:54:14,455
that the extension that I talked about, made for
我谈到的扩展,使

1251
00:54:14,524 --> 00:54:16,223
us called fetchRequest,
我们叫fetchRequest,

1252
00:54:16,292 --> 00:54:19,127
Now, this is one of the very few times when Swift
现在,这是为数不多的时候迅速

1253
00:54:19,195 --> 00:54:22,830
cannot infer the type of this return value,
不能推断出这个返回值的类型,

1254
00:54:24,132 --> 00:54:26,500
Should've put this in red, okay?
应该把这个红色的,好吗?

1255
00:54:26,568 --> 00:54:27,133
Because it's so
因为它是如此

1256
00:54:27,202 --> 00:54:29,568
rare, Swift can almost always infer things,
罕见,斯威夫特几乎总是可以推断,

1257
00:54:29,637 --> 00:54:31,169
But in turns out NSManagedObject
但在NSManagedObject

1258
00:54:31,238 --> 00:54:34,506
has a fetchRequest method and it returns the more generic
有一个fetchRequest方法,它返回更通用的

1259
00:54:34,574 --> 00:54:37,108
kind of fetchRequest and so when you're getting it,
种fetchRequest所以当你得到它,

1260
00:54:37,177 --> 00:54:39,610
it doesn't quite know which one you want,
完全不知道你想要哪一个,

1261
00:54:39,679 --> 00:54:41,579
So when you ask a Tweet for
所以,当你问一个Tweet

1262
00:54:41,648 --> 00:54:44,582
its fetch request right here, you have to tell it did you
其获取请求,你必须告诉你

1263
00:54:44,650 --> 00:54:48,318
want the one in Tweet not the one from its super class?
想要一个在推特不是一个从其超类?

1264
00:54:48,387 --> 00:54:48,884
All right? And so
好吧?

1265
00:54:48,953 --> 00:54:51,186
say let request equal NSFetchRequest,
说让请求NSFetchRequest相等,

1266
00:54:51,255 --> 00:54:53,756
It's a generic type like array or something like that, right?
这是一个泛型类型数组或类似的东西,对吧?

1267
00:54:53,825 --> 00:54:55,958
This is a fetch request only for Tweets,
这是一个只有微博获取请求,

1268
00:54:56,026 --> 00:54:58,594
So you say NSFetchRequest<tweet> =
所以你说NSFetchRequest <微博> =

1269
00:54:58,662 --> 00:55:00,595
Tweet,fetchRequest(),
微博,fetchRequest(),

1270
00:55:00,664 --> 00:55:02,396
And it knows, of course,
当然,它知道

1271
00:55:02,465 --> 00:55:05,900
that the only one that returns an NSFetchRequest for
返回一个NSFetchRequest的只有一个

1272
00:55:05,968 --> 00:55:09,003
tweets is the fetchRequest, and that's Tweet extension,
微博是fetchRequest,微博扩展,

1273
00:55:11,106 --> 00:55:12,439
So now, you have a fetchRequest,
现在,你有一个fetchRequest,

1274
00:55:12,507 --> 00:55:14,741
this is how you get a fetch request- couldn't be easier,
这是你如何获取请求,不容易,

1275
00:55:14,809 --> 00:55:17,442
You just have to remember to do that static
你只需要记住这样做静态的

1276
00:55:17,511 --> 00:55:19,378
typing right there,
打字,

1277
00:55:19,446 --> 00:55:21,446
Okay, now we need the sortDescriptor, right?
好了,现在我们需要sortDescriptor ?

1278
00:55:21,515 --> 00:55:22,947
It's got this array coming back,
它有这个数组返回,

1279
00:55:23,016 --> 00:55:25,516
What order are they going to be?
他们会是什么订单?

1280
00:55:25,585 --> 00:55:27,851
SortDescriptor looks like this,
SortDescriptor看起来是这样的,

1281
00:55:27,920 --> 00:55:29,352
You create it with a key,
您创建一个关键,

1282
00:55:29,421 --> 00:55:32,188
That is the key, the attribute in
这就是关键,属性

1283
00:55:32,257 --> 00:55:35,258
the database that you want to sort on, so the screen name or
上你想要的数据库,所以屏幕名称或

1284
00:55:35,327 --> 00:55:38,828
even the text in the tweet or the actual name of
甚至微博中的文本或实际的名称

1285
00:55:38,897 --> 00:55:40,896
the tweeter, whatever it's gonna be,
推特,不管它是什么,

1286
00:55:40,965 --> 00:55:42,230
This right here, sortDescriptor,
这里,sortDescriptor,

1287
00:55:42,299 --> 00:55:45,867
will be a sort descriptor only suitable for fetching Twitter
将一个类描述符只适用于抓取微博

1288
00:55:45,936 --> 00:55:49,471
users, because screenName is a key in Twitter user,
用户,因为在Twitter用户屏幕名是一个关键,

1289
00:55:49,540 --> 00:55:51,906
not in tweet, so we're gonna use this SortDescriptor
没有推特,所以我们要使用这个SortDescriptor

1290
00:55:51,975 --> 00:55:53,641
in a tweet request,
要求,在推特上

1291
00:55:53,709 --> 00:55:55,175
And I say that because on the previous slide,
我说,因为之前的幻灯片上,

1292
00:55:55,244 --> 00:55:57,611
I just showed you how to make a fetch request for a tweet,
我只是向您展示了如何获取请求一条微博,

1293
00:55:57,680 --> 00:55:59,312
Anyway, I should just, that should have been Twitter user,
无论如何,我应该,应该是Twitter用户,

1294
00:55:59,381 --> 00:56:01,648
But anyway, so this is a Twitter user,
但无论如何,这是一个Twitter用户,

1295
00:56:01,716 --> 00:56:02,781
SortDescriptor,
SortDescriptor,

1296
00:56:02,850 --> 00:56:05,951
And notice it has ascending or descending like us A to Z or
注意它有像我们这样的升序或降序A到Z

1297
00:56:06,020 --> 00:56:10,588
Z to A and then it has this argument selector and
Z,然后它有这个参数选择器

1298
00:56:10,657 --> 00:56:13,458
this one creates some confusion,
这个造成了一些困惑,

1299
00:56:13,527 --> 00:56:15,859
But really this selector just says,
但实际上这选择器只是说,

1300
00:56:15,928 --> 00:56:20,497
what method am I gonna use to compare items to do the sort,
我要用什么方法来比较项目排序,

1301
00:56:20,566 --> 00:56:24,735
All right now, you don't even have to specify the selector
现在好了,你甚至不需要指定选择器

1302
00:56:24,804 --> 00:56:26,837
if you don't want to and for
如果你不想

1303
00:56:26,906 --> 00:56:29,906
almost all data types, numbers,
几乎所有的数据类型、数字

1304
00:56:29,975 --> 00:56:34,410
dates, it's going to use a method called compare, okay,
日期,它会使用一种称为比较,好吧,

1305
00:56:34,479 --> 00:56:38,747
Compare returns something called a comparison result
返回一个叫做比较结果进行比较

1306
00:56:38,816 --> 00:56:41,450
which is either, it's the same, it's greater than, or
不是,是一样的,大于,还是

1307
00:56:41,518 --> 00:56:42,084
it's less than,
不到,

1308
00:56:42,153 --> 00:56:43,618
So, that's what this compare method does,
所以,这就是这个方法并进行比较,

1309
00:56:43,687 --> 00:56:44,885
And it's implemented by date,
实施日期,

1310
00:56:44,954 --> 00:56:46,187
It's implemented by Int32,
这是由Int32,实现

1311
00:56:46,256 --> 00:56:47,888
It's implemented by double,
它是实现双,

1312
00:56:47,957 --> 00:56:49,823
It's even implemented by string,
甚至实现字符串,

1313
00:56:49,892 --> 00:56:50,724
Okay? So,
好吧?

1314
00:56:50,793 --> 00:56:52,358
you could just use compare,
你可以使用比较,

1315
00:56:52,427 --> 00:56:54,594
But, for strings,
但是,对于字符串,

1316
00:56:54,662 --> 00:56:56,695
You wanna think a little bit about what kind
你想要一点思考什么

1317
00:56:56,764 --> 00:56:57,895
of comparison do you want?
你想要比较的?

1318
00:56:57,964 --> 00:57:01,233
Do you want case-insensitive compare?
你想要以不区分大小写的比较吗?

1319
00:57:01,301 --> 00:57:03,734
Or you could even use this special compare,
或者你甚至可以使用这种特殊的比较,

1320
00:57:03,803 --> 00:57:05,736
called localizedStandardCompare,
叫localizedStandardCompare,

1321
00:57:05,805 --> 00:57:06,737
This will compare them so
这将比较他们

1322
00:57:06,806 --> 00:57:09,573
that it is sourced just like the finder on the Mac,
这是采购就像仪在Mac上,

1323
00:57:09,641 --> 00:57:11,575
And what does the finder on the Mac do that's different
的发现者在Mac上做的不同的事情

1324
00:57:11,643 --> 00:57:12,942
than case insensitive?
比不区分大小写吗?

1325
00:57:13,010 --> 00:57:15,444
Well, there's a lot of issues with things like diacritic
嗯,有很多诸如可区别的问题

1326
00:57:15,513 --> 00:57:17,912
marks, and you know,
是,你知道,

1327
00:57:17,981 --> 00:57:20,616
things in your local language where things sort differently,
事情在你的当地语言不同,

1328
00:57:20,684 --> 00:57:23,284
depending on what language you're in, what locale it is,
取决于你在什么语言,语言环境是什么,

1329
00:57:23,353 --> 00:57:25,419
You'd, you sometimes you ignore the diacritics,
你,你有时候你忽略变音符号,

1330
00:57:25,488 --> 00:57:26,320
like accent marks,
像重音符号,

1331
00:57:26,389 --> 00:57:28,154
Sometimes they mean something,
有时他们的意思是什么,

1332
00:57:28,223 --> 00:57:31,992
And, so localized standard compare is a special compare
因此本地化标准的比较是一种特殊的比较

1333
00:57:32,061 --> 00:57:35,194
for strings, that knows how to do that, okay?
字符串,知道怎么做,好吗?

1334
00:57:35,263 --> 00:57:38,197
And this is very commonly the one we will use for strings,
这是非常常见的一个我们将使用字符串,

1335
00:57:38,266 --> 00:57:39,832
When we're gonna show something in our UI,
当我们将展示一些在我们的界面,

1336
00:57:39,901 --> 00:57:42,334
maybe this array of thing for fetching,
也许这一系列的抓取,

1337
00:57:42,403 --> 00:57:43,168
we're gonna put it in the UI,
我们要把它在UI中,

1338
00:57:43,237 --> 00:57:44,769
We would want it to be in order,
我们会想要,

1339
00:57:44,838 --> 00:57:46,304
this localizedStandardCompare,
这个localizedStandardCompare,

1340
00:57:46,372 --> 00:57:50,374
You notice that it's an NSString dot method,
你注意到这是一个NSString点方法,

1341
00:57:50,443 --> 00:57:53,343
It's not String,localizedStandardComp-
这不是字符串,localizedStandardComp -

1342
00:57:53,412 --> 00:57:55,679
that's because this has to be an Objective-C visible method,
因为这是一个objective - c可见的方法,

1343
00:57:55,680 --> 00:57:57,947
are, And
是,

1344
00:57:58,950 --> 00:58:01,584
And you need the NSString version,
你需要NSString版本,

1345
00:58:01,652 --> 00:58:03,285
So basically you're going to say NSString dot, and
所以基本上你要说NSString点,和

1346
00:58:03,354 --> 00:58:07,522
you can go look, search for compare in NSString or string,
你可以去看,寻找比较NSString或字符串,

1347
00:58:07,591 --> 00:58:09,690
because a string implements them all as well but
但是因为一个字符串来实现

1348
00:58:09,759 --> 00:58:12,393
you need NSString dot and then the name of the method,
你需要NSString点方法的名称,

1349
00:58:12,462 --> 00:58:14,995
And you can search, and there is case insensitive and
你可以搜索,不分大小写

1350
00:58:15,064 --> 00:58:18,232
the standard compare and then the regular compare and etc,
标准的比较,然后定期比较等,

1351
00:58:18,301 --> 00:58:22,335
Now one other thing about this is that,
现在另一件事是,

1352
00:58:22,404 --> 00:58:27,273
these methods some of them are special in that,
这些方法有些特殊,

1353
00:58:27,342 --> 00:58:32,211
it does to compare on the database side, okay,
它确实比较在数据库方面,好的,

1354
00:58:32,280 --> 00:58:36,082
Using SQL to do it, see what I'm saying?
使用SQL,看到我在说什么吗?

1355
00:58:36,150 --> 00:58:39,251
It's not actually bringing all the data over,
实际上并不是把所有的数据,

1356
00:58:39,320 --> 00:58:41,786
Calling this method on every string, and
在每一个字符串,调用该方法

1357
00:58:41,855 --> 00:58:43,989
doing some kind of quicksort or something,
做一些快速排序,

1358
00:58:44,057 --> 00:58:46,690
It's using super powerful sorting mechanisms that
这是使用超级强大的排序机制

1359
00:58:46,759 --> 00:58:48,993
are built into an SQL database, okay,
构建成一个SQL数据库,

1360
00:58:49,062 --> 00:58:52,896
So, in fact, all of the NSString ones will do that,
事实上,所有NSString的都会这样做,

1361
00:58:52,965 --> 00:58:56,834
Okay, so they're super duper efficient,
好的,所以他们超级有效,

1362
00:58:56,902 --> 00:59:00,537
Now, if you wanted to use your own compare though,
现在,如果你想使用自己的比较,

1363
00:59:00,606 --> 00:59:01,971
it's not gonna be efficient,
它不会有效,

1364
00:59:02,040 --> 00:59:02,838
Because it is gonna have to
因为这是必须的

1365
00:59:02,906 --> 00:59:05,674
bring all the data from the database into your memory so
把所有的数据从数据库到你的记忆

1366
00:59:05,743 --> 00:59:07,509
it can run your little method over it,
它可以运行你的小方法,

1367
00:59:07,578 --> 00:59:08,776
So I strongly recommend
所以我强烈推荐

1368
00:59:08,845 --> 00:59:11,479
against using your own selector here,
不要使用你自己的选择,

1369
00:59:11,548 --> 00:59:13,413
I would use the standard selectors,
我将使用标准的选择器,

1370
00:59:13,482 --> 00:59:14,548
If you're gonna use your own selector
如果你要使用自己的选择器

1371
00:59:14,617 --> 00:59:16,449
it's gotta be on a pretty small dataset,
它应该是在一个非常小的数据集,

1372
00:59:16,518 --> 00:59:20,487
Cuz it's not gonna be very efficient,
因为它不会很有效,

1373
00:59:22,123 --> 00:59:24,423
Notice that when we do the fetch request,
注意,当我们获取请求,

1374
00:59:24,492 --> 00:59:26,759
we don't just give it a sort descriptor,
我们不只是给它一个描述符,

1375
00:59:26,828 --> 00:59:29,427
we give it an array of sort descriptors,
我们给它一个数组的类型描述符,

1376
00:59:29,496 --> 00:59:33,632
That's the old sort by last name, and then first name,
这是老按姓排序,然后名字,

1377
00:59:33,700 --> 00:59:34,432
Right? So if
对吧?

1378
00:59:34,501 --> 00:59:37,167
we have 12 Smiths in there, we'll sort them and
我们有12个铁匠,排序

1379
00:59:37,236 --> 00:59:38,936
the Smiths will be in the right spot,
史密斯一家将在正确的位置,

1380
00:59:39,005 --> 00:59:40,870
And then all of the first names of the Smiths
然后所有的史密斯的名字

1381
00:59:40,939 --> 00:59:41,971
will be in order by that,
将在订单,

1382
00:59:42,040 --> 00:59:44,240
So we can have as many of these sub sort by the one
所以我们可以有许多的这些子

1383
00:59:44,308 --> 00:59:45,675
thing, sub sort by the next thing,
子类型,接下来,

1384
00:59:45,744 --> 00:59:47,476
sub sort by the next thing,
子,接下来,

1385
00:59:47,544 --> 00:59:50,612
Basically, we can break ties with subsequent sorting and
基本上,我们可以打破与随后的排序和的关系

1386
00:59:50,681 --> 00:59:53,749
that's why we give an array of sort descriptors,
这就是为什么我们给一个数组类型描述符,

1387
00:59:56,619 --> 01:00:00,688
Okay, so, that's the fetch request and
好了,这就是获取请求和

1388
01:00:00,757 --> 01:00:02,790
its sort descriptors and now the predicate,
类型描述符和谓词,

1389
01:00:02,858 --> 01:00:06,192
Okay, the predicate is the guts of saying which tweets do
谓词是勇气说的tweet

1390
01:00:06,261 --> 01:00:06,993
we want,
我们想要的,

1391
01:00:07,062 --> 01:00:08,962
Which Twitter users do we want?
我们想要的Twitter用户?

1392
01:00:09,030 --> 01:00:12,031
We create them with kind of interesting API,
我们用有趣的API创建它们,

1393
01:00:12,099 --> 01:00:17,069
It looks a lot like printf from C,
它看起来很像printf从C,

1394
01:00:17,137 --> 01:00:20,672
NSPredicate format colon, and then a string,
结肠NSPredicate格式,然后一个字符串,

1395
01:00:20,740 --> 01:00:23,008
And the string is a format string,
是一个格式字符串和字符串,

1396
01:00:23,076 --> 01:00:24,608
And again, looks a lot like printf,
看起来很像printf,

1397
01:00:24,677 --> 01:00:28,045
So the best way to explain this is probably by example,
所以最好的方法解释这可能是以身作则,

1398
01:00:28,114 --> 01:00:30,114
But the way you're gonna learn this is you're gonna go
但是你要学习这个的方式是你要走了

1399
01:00:30,182 --> 01:00:33,884
read the documentation for NSPredicate, you've got to go
NSPredicate阅读文档,你必须去

1400
01:00:33,953 --> 01:00:37,053
read that documentation, in its class documentation,
阅读文档,在它的类文档,

1401
01:00:37,122 --> 01:00:39,856
there's gonna be a link that says, creating predicates,
会有一个链接,创建谓词,

1402
01:00:39,924 --> 01:00:42,858
or something like that, click on that, and go there, and
之类的,点击,和去那里

1403
01:00:42,927 --> 01:00:45,327
learn all the things you can put in this format string,
学习所有的东西你可以把这种格式字符串,

1404
01:00:45,396 --> 01:00:48,497
cuz it's all very specific to doing database queries, but
因为这都是非常特定于数据库查询,但是

1405
01:00:48,566 --> 01:00:49,631
I'll show you some examples, so
我将向您展示一些例子

1406
01:00:49,700 --> 01:00:51,666
you get an idea of what's going on here,
你知道这是怎么回事,

1407
01:00:51,735 --> 01:00:53,067
So here's the first one,
这是第一个,

1408
01:00:53,136 --> 01:00:54,935
let's have the search string called foo,
让我们搜索字符串foo,

1409
01:00:58,207 --> 01:01:00,039
All these searches then I'm gonna do right here
然后我要做所有这些搜索在这里

1410
01:01:00,108 --> 01:01:01,307
are tweet searches,
微博搜索,

1411
01:01:01,375 --> 01:01:04,710
These are for predicates for searching for a tweet,
这些都是为寻找一条微博,谓词

1412
01:01:04,778 --> 01:01:08,113
So first, I'm gonna find all the tweets whose text,
首先,我要找到所有的消息文本,

1413
01:01:08,182 --> 01:01:11,617
the actual tweet, the 140 characters of pure joy or
实际的推特,140个字符或纯粹的快乐

1414
01:01:11,685 --> 01:01:14,151
whatever, contains case sensitive,
无论如何,包含大小写敏感的,

1415
01:01:14,220 --> 01:01:15,320
Case insensitively,
区分大小写,

1416
01:01:15,388 --> 01:01:18,222
That's what [c] means,
这就是[c]的意思,

1417
01:01:18,290 --> 01:01:20,624
%@, %@ is a substitution variable,
% @ % @,是替代变量,

1418
01:01:20,693 --> 01:01:22,659
and I have to give its value at the end,
最后,我不得不给它的价值,

1419
01:01:22,728 --> 01:01:25,328
And so I'm substituting search string,
所以我用搜索字符串,

1420
01:01:25,397 --> 01:01:28,298
Okay, note that I can't say, text contains foo,
好的,请注意,我不能说,文本包含foo,

1421
01:01:28,367 --> 01:01:32,902
I have to say, text contains %@ and then,
我不得不说,文本包含% @然后,

1422
01:01:32,971 --> 01:01:35,037
Put something at the end there,
最后放点东西,

1423
01:01:35,106 --> 01:01:36,237
Okay, so that's an obvious one,
好了,这是很明显的一个,

1424
01:01:36,306 --> 01:01:38,739
I'm searching for all my tweets that contain foo,
我寻找我的所有包含foo的微博,

1425
01:01:38,808 --> 01:01:41,309
How about this one?
这一个怎么样?

1426
01:01:41,378 --> 01:01:46,213
I want all the tweets whose tweeter equals %@,
我希望所有的推特的推特= % @,

1427
01:01:46,282 --> 01:01:48,615
I'm going to put Joe in there as the substitution variable
我要把乔作为替代变量

1428
01:01:48,684 --> 01:01:52,986
and created after some date that I create,
后,创建一些我创建的日期,

1429
01:01:54,155 --> 01:01:56,489
See that? I'm using greater
看到了吗?

1430
01:01:56,557 --> 01:01:57,556
than to do that,
比,

1431
01:01:57,625 --> 01:01:59,324
And I'm doing && for and,
和我做& &,

1432
01:01:59,393 --> 01:02:01,326
you can also use the word and there,
你也可以用这个词,

1433
01:02:02,295 --> 01:02:03,094
Okay? So that's all gonna be
好吧?

1434
01:02:03,163 --> 01:02:05,129
the tweets created by Joe since that date,
自那天起,乔创造的微博,

1435
01:02:07,199 --> 01:02:09,198
You're starting to see the power of building the query
你开始看到的力量构建查询

1436
01:02:09,267 --> 01:02:10,133
into the database, right?
到数据库中,对吧?

1437
01:02:10,202 --> 01:02:12,601
If I had thousands of tweets, it'd be really easy to find
如果我有成千上万的微博,会很容易找到的

1438
01:02:12,670 --> 01:02:14,570
the ones since yesterday, for example,
例如,从昨天开始的

1439
01:02:14,639 --> 01:02:16,839
I'll show you that in a second here,
我将向您展示,在这里,

1440
01:02:16,907 --> 01:02:21,910
Aand then I can also though, search through dot notation,
不过,和然后我也可以搜索点符号,

1441
01:02:21,979 --> 01:02:23,844
on other fields, in other entities, but
在其他领域,在其他实体,但是

1442
01:02:23,913 --> 01:02:28,616
this tweeter,screenName equals percent @ sign%@ with CS193P,
这个推特,与CS193P屏幕名= % @ % @,

1443
01:02:28,684 --> 01:02:30,617
that's still searching for tweets,
这仍然是搜索微博,

1444
01:02:30,686 --> 01:02:31,185
That's searching for
这是寻找

1445
01:02:31,253 --> 01:02:34,621
tweets whose tweeter's screen name is CS193P,
推的推特的屏幕名字是CS193P,

1446
01:02:34,689 --> 01:02:37,056
Do you see what it's doing there?
你看到它在做什么?

1447
01:02:37,125 --> 01:02:38,557
This is still a tweet predicate,
这仍然是一个tweet谓词,

1448
01:02:38,626 --> 01:02:41,060
This is not a twitter user predicate,
这不是一个twitter用户谓词,

1449
01:02:41,996 --> 01:02:43,094
Okay?
好吧?

1450
01:02:43,163 --> 01:02:45,263
So here's a different predicate,
这是一个不同的谓语,

1451
01:02:45,332 --> 01:02:47,932
This one is for Twitter user,
这是Twitter用户,

1452
01:02:48,001 --> 01:02:49,234
So here I'm searching for all the Twitter users
这里我寻找所有的Twitter用户

1453
01:02:49,235 --> 01:02:50,468
Okay?
好吧?

1454
01:02:52,438 --> 01:02:56,506
who has a Tweet whose text contains foo,
谁有一个微博,其文本包含foo,

1455
01:02:57,743 --> 01:02:58,708
Okay?
好吧?

1456
01:02:58,777 --> 01:03:01,009
So it even knows how to do a pluralistic
所以即使知道如何做一个多元化

1457
01:03:01,078 --> 01:03:03,278
search right here where you've got tweets dot text that means
搜索在这里,这意味着你有微博点文本

1458
01:03:03,346 --> 01:03:08,049
all the tweets, texts and doing contains and
所有的微博,包含文本和做

1459
01:03:08,118 --> 01:03:10,919
we can do [c] if we wanted foo,
我们可以做[c]如果我们希望foo,

1460
01:03:10,987 --> 01:03:13,054
So that's a twitter user search right there,
这是一个twitter用户搜索,

1461
01:03:13,122 --> 01:03:14,555
the twitter users who have tweeted anything that includes
twitter用户,包括任何东西

1462
01:03:14,556 --> 01:03:15,989
We're looking for
我们正在寻找

1463
01:03:16,058 --> 01:03:19,493
foo, again a powerful search, really easy to express,
foo,再强大的搜索,很容易表达,

1464
01:03:22,563 --> 01:03:24,197
Question,
问题,

1465
01:03:24,265 --> 01:03:27,733
>> [INAUDIBLE] >> So the question,
> > > >(听不清)问题,

1466
01:03:27,801 --> 01:03:29,801
does it infer this from the name of the variable,
它推断出这个名字的变量,

1467
01:03:29,869 --> 01:03:31,035
it's not inferring it,
这不是推断,

1468
01:03:31,104 --> 01:03:34,172
it's actually using the name of the attribute tweets
它实际上是使用的名称属性的微博

1469
01:03:34,240 --> 01:03:36,674
right there and the name of the attribute text and it's
这里和文本的属性的名称

1470
01:03:36,742 --> 01:03:40,177
building a SQL statement that will go and do this fetch,
建立一个SQL语句,会去做这个取回,

1471
01:03:40,246 --> 01:03:41,878
Okay now it's doing all that underneath the covers,
好了现在这么做封面,下面

1472
01:03:41,947 --> 01:03:44,314
we don't care how, but it's doing it,
我们不关心,但这样做,

1473
01:03:47,952 --> 01:03:48,718
Yeah, compound predicate,
是的,复合谓语,

1474
01:03:48,787 --> 01:03:51,453
You can build a compound predicate like an and
您可以构建一个复合谓词和

1475
01:03:51,522 --> 01:03:52,887
predicate or an or predicate,
谓词或一个谓词,

1476
01:03:52,956 --> 01:03:55,957
You could put or or and in the string, or
你可以把或字符串,或

1477
01:03:56,025 --> 01:03:58,026
you could create separate predicates and and
你可以创建单独的谓词和

1478
01:03:58,094 --> 01:04:00,794
them together by creating an NSCompoundPredicate,
通过创建一个NSCompoundPredicate一起,

1479
01:04:00,863 --> 01:04:02,195
And predicate with sub-predicates, and
与sub-predicates和谓词,

1480
01:04:02,264 --> 01:04:03,864
just given an array of predicates and
给出一个谓词和数组

1481
01:04:03,932 --> 01:04:04,664
it ands them together,
它and一起,

1482
01:04:04,733 --> 01:04:06,699
Why would you ever want to do this versus just putting and
为什么你会想要这样做只有把和吗

1483
01:04:06,767 --> 01:04:07,600
or, or in there?
或者,还是在那里?

1484
01:04:07,669 --> 01:04:10,970
Well, maybe you're computing what the predicates are,
好吧,也许你计算谓词是什么,

1485
01:04:11,038 --> 01:04:14,139
based on some, depending on what the user clicked on or
基于一些,这取决于用户点击或

1486
01:04:14,208 --> 01:04:14,939
something, you're computing it, and
什么,你计算它,

1487
01:04:15,008 --> 01:04:18,009
so you want to add these things you computed together,
所以你想要添加这些东西一起计算,

1488
01:04:19,845 --> 01:04:22,980
All right, there's also function predicates,
好吧,还有谓词函数,

1489
01:04:23,049 --> 01:04:25,382
Now these are super powerful predicates,
现在这些都是超级强大的谓词,

1490
01:04:25,451 --> 01:04:27,284
and you don't need these for your homework, so
并为你的作业,你不需要这些

1491
01:04:27,352 --> 01:04:30,120
don't worry too much about these, but they're cool,
不要过于担心这些,但是他们很酷,

1492
01:04:30,188 --> 01:04:32,621
You can even say, you have a search like this one,
你甚至会说,你有一个像这样的搜索,

1493
01:04:32,690 --> 01:04:35,291
tweets,@count > 5,
微博,@count > 5,

1494
01:04:35,360 --> 01:04:37,926
this is a Twitter user search, that finds
这是一个Twitter用户搜索,发现

1495
01:04:37,994 --> 01:04:42,363
all the Twitter users who have more than 5 Tweets, okay?
所有的Twitter用户已超过5条,好吗?

1496
01:04:42,432 --> 01:04:45,266
So, @count is actually running, kind of a function in
所以,@count实际运行,一种功能

1497
01:04:45,335 --> 01:04:49,003
the database, to go count the number of Tweets that
数据库,去数一数的tweet

1498
01:04:49,071 --> 01:04:50,770
the Twitter user has,
Twitter用户,

1499
01:04:50,839 --> 01:04:52,639
So, again, you'll see all of this when you go look at
再说一遍,你会发现当你去看

1500
01:04:52,707 --> 01:04:55,708
the NSPredicate documentation, it's incredibly powerful,
NSPredicate文档,这是令人难以置信的强大,

1501
01:04:55,777 --> 01:04:59,445
you can see you barely have to type anything in as the format
你可以看到你几乎没有输入任何格式

1502
01:04:59,514 --> 01:05:02,081
string, and you get these really powerful searches,
字符串,得到这些真正强大的搜索,

1503
01:05:04,218 --> 01:05:06,718
All right, so let's put it all together now to create
好了,现在让我们把它放在一起来创建

1504
01:05:06,787 --> 01:05:08,019
our fetch request, okay,
我们获取请求,

1505
01:05:08,088 --> 01:05:09,154
I'm gonna create,
我要创建、

1506
01:05:09,222 --> 01:05:11,189
in this case, a Twitter user fetch request,
在这种情况下,一个Twitter用户获取请求,

1507
01:05:11,257 --> 01:05:13,857
So I'm saying a FetchRequest<TwitterUser> =
所以我说一个FetchRequest < TwitterUser > =

1508
01:05:13,926 --> 01:05:16,527
TwitterUser,fetchRequest(), then I'm gonna
TwitterUser,fetchRequest(),然后我要

1509
01:05:16,595 --> 01:05:18,161
create a time which was yesterday,
创建一个时间是昨天,

1510
01:05:18,230 --> 01:05:21,030
it's actually not, it's 24 hours ago,
其实不是,这是24小时前,

1511
01:05:21,099 --> 01:05:24,133
Time interval since now, minus 24 times 60 times 60,
时间间隔从现在,- 24 * 60 * 60,

1512
01:05:24,202 --> 01:05:27,068
that's 24 hours ago, and I'm creating a predicate
24小时前,我正在创建一个谓词

1513
01:05:27,137 --> 01:05:31,239
that says, find me any Twitter users that have a Tweet that's
说,发现我任何Twitter用户的Tweet

1514
01:05:31,308 --> 01:05:36,378
created before yesterday, or since yesterday I guess,
昨天之前创建的,或从昨天我猜,

1515
01:05:36,447 --> 01:05:38,812
yes, created is greater than yesterday,
是的,昨天创造大于,

1516
01:05:38,881 --> 01:05:42,917
So I'm finding all the Twitter users who have created Tweets
我发现所有的Twitter用户创建的tweet

1517
01:05:42,985 --> 01:05:45,419
in the last twenty-four hours, that's what this one does,
在过去的24小时,这就是这一个,

1518
01:05:45,487 --> 01:05:49,556
So any is a special term that means match any
所以是一个特殊的词,它意味着匹配任何

1519
01:05:49,625 --> 01:05:51,424
of these things, and
这些东西,

1520
01:05:51,492 --> 01:05:54,828
these things are Tweets that are created since yesterday,
这些都是创建从昨天的微博,

1521
01:05:56,096 --> 01:05:58,831
And I'm gonna sort the result by the actual name,
我将排序结果的实际名称,

1522
01:05:58,899 --> 01:06:01,733
the real name of the Twitter user,
Twitter用户的真实姓名,

1523
01:06:01,802 --> 01:06:04,436
So I'm just doing sortDescriptor, key of name,
我只是做sortDescriptor,关键的名字,

1524
01:06:04,504 --> 01:06:07,305
ascending true, I'm not specifying a selector, so
提升真的,我不是指定一个选择器

1525
01:06:07,374 --> 01:06:09,873
I'm gonna get kind of the default comparison,
我要得到默认的比较,

1526
01:06:09,942 --> 01:06:12,743
Okay, that's it, so that's how you create a fetch request,
好吧,就这样,这就是你创建一个获取请求,

1527
01:06:12,811 --> 01:06:16,914
Now, since I have a fetch request, how do I make it go?
现在,因为我有一个获取请求,我怎么去吗?

1528
01:06:16,982 --> 01:06:19,782
Give me those Tweets, give me those Twitter users,
给我那些微博,给我这些Twitter用户,

1529
01:06:19,851 --> 01:06:22,618
We do that with the very simple method in context, so
我们做的非常简单的方法在上下文,所以

1530
01:06:22,687 --> 01:06:25,721
we ask the context to do the fetch, and it will go out and
我们问下取回,并将出去

1531
01:06:25,790 --> 01:06:28,623
return an array of all those things,
返回一个数组的所有这些事情,

1532
01:06:28,692 --> 01:06:31,627
sorted in the way the fetch request says to sort them,
排序的方式获取请求说他们,

1533
01:06:31,695 --> 01:06:33,228
Okay, simple as that,
好吧,就这么简单,

1534
01:06:33,297 --> 01:06:37,832
The only thing not so simple, it throws, okay?
唯一没有这么简单,它把,好吗?

1535
01:06:37,901 --> 01:06:43,004
Just like context save throws, context execute also throws,
就像上下文保存抛出,上下文执行也抛出,

1536
01:06:43,073 --> 01:06:45,539
So, you could put in a try question mark,
所以,你可以试着问号,

1537
01:06:45,608 --> 01:06:48,942
in that case, if the execute fails, and usually it's gonna
在这种情况下,如果执行失败,通常它会

1538
01:06:49,011 --> 01:06:51,411
fail because your predicate is wrong, or something,
失败,因为你的谓词是错误的,或者别的什么,

1539
01:06:53,114 --> 01:06:56,182
Like your predicate just makes no sense then you could fail,
喜欢你的谓语就毫无意义,那么你可以失败,

1540
01:06:56,251 --> 01:06:57,916
If it's gonna fail, you're gonna get back nil,
如果它会失败,你会回到零,

1541
01:06:57,985 --> 01:06:58,984
if you do try question mark,
如果你试着问号,

1542
01:06:59,052 --> 01:07:00,652
remember that's what try question mark means,
记住,就是试着问号的意思,

1543
01:07:00,720 --> 01:07:03,054
It means try this, and if it fails, give back nil,
这意味着试试这个,如果失败,返回nil,

1544
01:07:03,123 --> 01:07:04,188
But it if doesn't fail,
但如果不失败,

1545
01:07:04,257 --> 01:07:06,524
then you're gonna get an optional array,
然后你会得到一个可选的数组,

1546
01:07:06,592 --> 01:07:08,892
And that array is gonna be empty,
数组是空,

1547
01:07:08,961 --> 01:07:11,928
if it couldn't find anything that matches your request, or,
如果找不到任何匹配你的要求,或者,

1548
01:07:11,997 --> 01:07:14,130
it's gonna be full of objects, okay?
它会布满对象,好吗?

1549
01:07:14,199 --> 01:07:16,832
Tweets, or Twitter users, an array of tweets, or
微博,或Twitter用户,一个tweet数组,或

1550
01:07:16,901 --> 01:07:18,200
an array of Twitter users,
一个Twitter用户数组,

1551
01:07:18,268 --> 01:07:19,501
at least that's what it's gonna look like to you,
至少它会是什么样子,

1552
01:07:19,570 --> 01:07:22,404
it's not quite that, looks like it, all right?
看起来,它不是很好吗?

1553
01:07:22,472 --> 01:07:24,939
That's the result you're gonna get back, so, again,
结果你会回来,所以,再一次,

1554
01:07:25,007 --> 01:07:26,974
super simple querying,
超级简单的查询,

1555
01:07:27,042 --> 01:07:31,445
Now, you might be a little scared of doing this request,
现在,你可能有点害怕做这个请求,

1556
01:07:31,513 --> 01:07:35,415
what if it's matches a million things, okay?
如果匹配一百万件事,好吗?

1557
01:07:35,484 --> 01:07:38,818
Are you gonna get a million Tweets back in one
你要拿回一百万条在一个

1558
01:07:38,887 --> 01:07:39,719
request like this?
这样的请求吗?

1559
01:07:39,788 --> 01:07:41,621
The answer is no,
答案是否定的,

1560
01:07:41,689 --> 01:07:45,658
This array that you get back is really super smart array,
这个数组,你回来是非常聪明的数组,

1561
01:07:45,726 --> 01:07:48,693
It doesn't actually bring the data in from the database,
它实际上并不带来从数据库中的数据,

1562
01:07:48,762 --> 01:07:51,496
until you start asking for it, okay?
直到你开始问,好吗?

1563
01:07:51,565 --> 01:07:53,964
So until I ask for the Twitter user,
所以,直到我问Twitter用户,

1564
01:07:54,033 --> 01:07:56,133
a certain Twitter user's information,
一个Twitter用户的信息,

1565
01:07:56,201 --> 01:07:58,401
the Twitter user's name, the Twitter user's screen name,
Twitter用户的名称、Twitter用户的屏幕名字,

1566
01:07:58,470 --> 01:08:00,403
the Twitter user did not get faulted from the database,
Twitter用户从数据库中没有得到断裂,

1567
01:08:00,472 --> 01:08:01,904
This is called faulting, okay?
这就是所谓的断层,好吗?

1568
01:08:01,973 --> 01:08:03,706
And so, these objects, you can imagine,
因此,这些对象,你可以想象,

1569
01:08:03,775 --> 01:08:05,941
they're kind of shells, empty shells,
它们的贝壳,空壳,

1570
01:08:06,010 --> 01:08:07,276
And until you crack open the shell and
直到你打开壳

1571
01:08:07,344 --> 01:08:08,810
start looking inside,
开始在里面,

1572
01:08:08,879 --> 01:08:10,811
it doesn't actually get the data for you,
它实际上并不为你获取数据,

1573
01:08:10,880 --> 01:08:12,546
And the reason this matters to you is,
这很重要的原因是,

1574
01:08:12,615 --> 01:08:15,482
if you go in the debugger, or you do a print statement,
如果你在调试器中,或者做一个print语句,

1575
01:08:15,551 --> 01:08:20,220
like this one where you say, for user in recentTweeters
像这样,你说,recentTweeters用户

1576
01:08:20,289 --> 01:08:23,423
fetched user whatever, when you print that out,
获取用户,当你打印出来,

1577
01:08:23,492 --> 01:08:26,159
it's not gonna print the, a Tweeter user object,
这不是要打印,推特的用户对象,

1578
01:08:26,227 --> 01:08:29,261
it's gonna print some kind of faulting shel,
它会打印一些断层替代高能激光,

1579
01:08:29,330 --> 01:08:30,529
Because you haven't actually asked for
因为你没有要求

1580
01:08:30,598 --> 01:08:32,631
any of the data inside that thing yet, so
任何内部数据的事情,所以

1581
01:08:32,699 --> 01:08:34,065
it hasn't faulted yet,
它还没有断,

1582
01:08:34,134 --> 01:08:34,899
But if you say, for
但如果你说

1583
01:08:34,968 --> 01:08:38,169
user in recentTweeters and say fetched user named, and
用户在recentTweeters说获取用户命名和

1584
01:08:38,238 --> 01:08:41,438
now you say user,name, now you are faulting this object in,
现在你说用户名,现在你是断层这个对象,

1585
01:08:41,507 --> 01:08:42,205
In fact, this for
事实上,这

1586
01:08:42,274 --> 01:08:45,809
loop would fault all these objects in to memory,
循环将所有这些对象在内存故障,

1587
01:08:45,877 --> 01:08:47,410
Okay, fetch them all, cuz you're asking for
好的,拿,因为你要求

1588
01:08:47,479 --> 01:08:48,411
the name of every single one,
每一个人的名字,

1589
01:08:48,480 --> 01:08:50,445
Boom, fault, fault, fault, they're all coming in,
繁荣,错,错,错,他们都进来,

1590
01:08:50,514 --> 01:08:53,449
Now, it doesn't do it one by one, it faults in batches,
现在,没有一个接一个,它在批量故障,

1591
01:08:53,517 --> 01:08:55,717
it's really high performance, so,
很高的性能,所以,

1592
01:08:55,785 --> 01:08:57,752
you know, don't worry about that,
你知道的,不要担心,

1593
01:08:57,821 --> 01:09:00,455
But just, I just don't want you to be surprised
但是,我只是不想让你感到惊讶

1594
01:09:00,524 --> 01:09:01,054
when you go in the debugger and
当你在调试器中去

1595
01:09:01,123 --> 01:09:02,957
you're like, I printed out this Twitter, user and
你喜欢,我打印这个Twitter,用户和

1596
01:09:03,026 --> 01:09:04,858
there's no screen name, what's going on?
没有屏幕名,怎么回事?

1597
01:09:04,927 --> 01:09:06,492
Well, it hasn't faulted it in,
嗯,还没有断,

1598
01:09:06,561 --> 01:09:07,993
In fact, the debugger you could say,
事实上,你可以说,调试器

1599
01:09:08,062 --> 01:09:09,862
print the user,name,
打印用户名,

1600
01:09:09,931 --> 01:09:13,332
and it would fault it in, okay, give it to you,
它会错,好吧,给你,

1601
01:09:15,369 --> 01:09:17,568
All right, I told you I was gonna talk about Core Data
好吧,我告诉你我要讲核心数据

1602
01:09:17,637 --> 01:09:19,470
thread safety, so here it is,
线程安全,所以在这里,

1603
01:09:19,539 --> 01:09:22,873
NSManagedObjectContext, the context thing,
NSManagedObjectContext,上下文的事情,

1604
01:09:22,942 --> 01:09:24,775
that thing that you're sending executes to,
那个东西你发送执行,

1605
01:09:24,844 --> 01:09:27,544
that thing that you're hitting save, the things that you're
那件事你保存,你的事情

1606
01:09:27,613 --> 01:09:30,280
using to create Tweet, Tweet, subcontext,
子上下文使用创建推特,推特,

1607
01:09:30,349 --> 01:09:33,817
colon whatever, that handle on database is not thread safe,
结肠,处理数据库不是线程安全的,

1608
01:09:35,052 --> 01:09:38,420
A context can only be used on the queue
一个上下文只能用于队列

1609
01:09:38,489 --> 01:09:41,156
that it was created on, period,
上创建,期间,

1610
01:09:41,225 --> 01:09:44,492
If you past a context to another queue,
如果你过去一个环境到另一个队列,

1611
01:09:44,561 --> 01:09:47,194
like you tried to dispatch off to some
像你试图派出去

1612
01:09:47,263 --> 01:09:50,030
global concurrent queue, and you pasted the context, or
全球并发队列,你粘贴的上下文,或

1613
01:09:50,099 --> 01:09:52,866
even just pasted a Tweet, okay, that's not gonna work,
只是贴一条微博,好吧,这不是要工作,

1614
01:09:52,935 --> 01:09:55,335
cuz that Tweet was created on this other context,
因为,推特上创建另一个上下文,

1615
01:09:55,403 --> 01:09:56,870
So in fact, not only the context,
所以实际上,不仅上下文中,

1616
01:09:56,939 --> 01:09:59,372
but everything that you create on that context
但是所有你创建上下文

1617
01:09:59,441 --> 01:10:01,907
has to all be done in the same queue,
都在相同的队列,

1618
01:10:01,976 --> 01:10:03,175
So now you're probably thinking,
现在你可能会想,

1619
01:10:03,244 --> 01:10:07,145
well how the heck do I do multithreading then?
到底如何我做多线程呢?

1620
01:10:07,214 --> 01:10:10,315
Cuz a database especially, you can imagine, for
特别是因为一个数据库,你可以想象,

1621
01:10:10,384 --> 01:10:13,584
temple one to load your database off the main queue,
寺庙加载数据库的一个主要队列,

1622
01:10:13,653 --> 01:10:15,853
cuz you, you might be loading lots and lots of things,
因为你,你可能会加载很多很多的东西,

1623
01:10:15,922 --> 01:10:16,586
Now your queries,
现在你的查询,

1624
01:10:16,655 --> 01:10:19,255
your probably gonna do those on the main queue because,
你可能要做那些队列,因为上主

1625
01:10:19,324 --> 01:10:20,890
the user's looking at that information,
用户查看这些信息,

1626
01:10:20,959 --> 01:10:22,157
You want it to be highly responsive,
你想要高度敏感,

1627
01:10:22,226 --> 01:10:25,794
Okay, it's probably worth, and core data is super fast,
好吧,可能是值得的,和核心数据非常快,

1628
01:10:25,863 --> 01:10:27,029
especially with queries,
尤其是在查询,

1629
01:10:27,097 --> 01:10:28,797
So, you could probably do that on the main queue,
所以,你可能在主队列,

1630
01:10:28,866 --> 01:10:29,464
But loading it up,
但加载它,

1631
01:10:29,532 --> 01:10:31,432
you probably don't want to do that,
你可能不想这么做,

1632
01:10:31,501 --> 01:10:33,734
All right, so, how do we do multithreading?
好的,那么,我们如何做多线程?

1633
01:10:33,803 --> 01:10:36,570
Although that we do multithreading in Core Data,
虽然我们做多线程的核心数据,

1634
01:10:36,638 --> 01:10:43,110
is each database can have multiple contexts, okay?
每一个数据库可以有多个上下文?

1635
01:10:43,179 --> 01:10:47,247
So, the database underneath, is multithreaded,
所以,下面的数据库,是多线程的,

1636
01:10:47,315 --> 01:10:50,850
it can have multiple contexts writing to it,
它可以有多个上下文编写,

1637
01:10:50,918 --> 01:10:52,784
Okay, completely different context,
好的,完全不同的背景下,

1638
01:10:52,853 --> 01:10:55,820
writing to the same database, in different queue's even, so
写相同的数据库,甚至在不同的队列,所以

1639
01:10:55,889 --> 01:10:57,622
it's fully multithreaded,
它是完全多线程,

1640
01:10:57,691 --> 01:11:00,992
So that means we had to have a context for every queue,
这意味着我们必须为每个队列上下文,

1641
01:11:01,060 --> 01:11:03,361
Whatever queue we're going to access the database,
无论队列我们要访问数据库,

1642
01:11:03,430 --> 01:11:04,896
we have to a context in every queue,
我们必须在每个队列上下文,

1643
01:11:04,964 --> 01:11:07,230
Now I'm gonna show you how to create a context, or
现在我将向您展示如何创建一个上下文,或

1644
01:11:07,299 --> 01:11:07,997
on another queue, so
另一个队列,因此

1645
01:11:08,066 --> 01:11:10,467
you can do something with that queue in a second here,
你可以做一些队列在第二个,

1646
01:11:10,535 --> 01:11:12,101
But first I want to talk about this important
但首先,我想谈谈这一重要

1647
01:11:12,170 --> 01:11:15,471
method in context called performBlock,
方法在上下文中调用performBlock,

1648
01:11:15,539 --> 01:11:17,373
performBlock just takes a closure,
performBlock只需要一个闭包,

1649
01:11:17,441 --> 01:11:18,807
a closure that takes no arguments,
不带参数的一个闭包,

1650
01:11:18,875 --> 01:11:22,677
returns no arguments, and it will ensure, this is
返回没有参数,它将确保,这是

1651
01:11:22,746 --> 01:11:27,381
an insurance method, it will ensure that everything inside
一个保险的方法,它将确保一切里面

1652
01:11:27,450 --> 01:11:32,086
that closure happens on the right queue for that context,
关闭发生在正确的队列上下文,

1653
01:11:32,154 --> 01:11:34,955
Okay, so this, don't get confused,
好吧,这,不感到困惑,

1654
01:11:35,024 --> 01:11:38,125
this method does not dispatch, you know,
这种方法不派遣,你知道,

1655
01:11:38,193 --> 01:11:42,562
cause background thrading, this is just making sure that,
导致背景thrading,这只是确保,

1656
01:11:42,631 --> 01:11:45,998
that closure executes on the right queue,
关闭上执行正确的队列,

1657
01:11:46,067 --> 01:11:48,433
So this is a way that you can kind of be safe,
这是一种你可以是安全的,

1658
01:11:48,502 --> 01:11:50,735
And some might argue you should put performBlock around
和有些人可能会认为你应该把performBlock

1659
01:11:50,804 --> 01:11:53,238
every single call to every Core Data thing you ever do,
每一个叫你曾经所做的每一件核心数据,

1660
01:11:53,307 --> 01:11:56,307
because that will ensure that you'll never have a problem
因为这将确保你永远不会有问题

1661
01:11:56,376 --> 01:11:59,811
where you're accessing the context not on it's queue,
你访问的上下文而不是队列,

1662
01:11:59,879 --> 01:12:01,778
Okay, it accidentally, you got some bad code,
好了,不小心,你有一些糟糕的代码,

1663
01:12:01,847 --> 01:12:06,483
Now, that might be a little bit overkill especially if
现在,特别是如果来说可能有点杀鸡用牛刀

1664
01:12:06,552 --> 01:12:09,352
you're mostly using the main queue anyway, and
你主要使用主队列,

1665
01:12:09,421 --> 01:12:12,355
you really, maybe you only use background queues for
你真的,也许你只使用背景队列

1666
01:12:12,424 --> 01:12:15,324
this tiny little bit of processing on the side,
这个小一点的处理,

1667
01:12:15,393 --> 01:12:17,993
It's not like you have the tons context and
它不像你有吨上下文和

1668
01:12:18,062 --> 01:12:20,695
lots of different queues all going at each other,
很多不同的队列都在彼此,

1669
01:12:20,764 --> 01:12:22,564
So, it might be overkill,
因此,它可能是多余的,

1670
01:12:22,632 --> 01:12:24,466
But if you're doing anything where you have,
但如果你做任何事,你,

1671
01:12:24,534 --> 01:12:27,202
truly have multiple context on multiple queues and
在多个队列和真正有多个上下文

1672
01:12:27,270 --> 01:12:31,572
they're access and things, this is a good way to be safe,
他们访问和事物,这是一个好方法是安全的,

1673
01:12:31,641 --> 01:12:35,175
Okay, so all this does is it makes it so you are safe,
好的,所以这一切都是它所以你是安全的,

1674
01:12:35,243 --> 01:12:39,346
The code inside that block will be executed on the proper
里面的代码块会在适当的执行

1675
01:12:39,415 --> 01:12:40,947
queue for that context,
队列上下文,

1676
01:12:41,015 --> 01:12:43,516
Even if it has to dispatch, it will do it if it has to,
即使它已经派遣,它将做它如果它,

1677
01:12:43,585 --> 01:12:44,917
If it doesn't have to dispatch,
如果它没有派遣,

1678
01:12:44,986 --> 01:12:47,786
if you're on the right queue, it'll just execute it, fine,
如果你在正确的队列,它会执行它,很好,

1679
01:12:47,855 --> 01:12:49,387
But if you're on the wrong queue right now and
但是如果你在错误的队列现在

1680
01:12:49,456 --> 01:12:50,055
you execute this,
你执行这个,

1681
01:12:50,124 --> 01:12:52,056
it will dispatch it to the right queue,
它将派遣正确的队列,

1682
01:12:52,125 --> 01:12:53,991
There's also performBlockAndWait,
还有performBlockAndWait,

1683
01:12:54,060 --> 01:12:55,659
which will get it on the right queue and
这将得到正确的队列和吗

1684
01:12:55,728 --> 01:12:58,062
wait until it's done, and then continue in your queue,
等待它完成,然后继续在您的队列,

1685
01:12:59,298 --> 01:13:01,597
Okay, but this doesn't really talk about,
好的,但这并没有真正谈论,

1686
01:13:01,666 --> 01:13:05,100
how do I get another context in a different thread, right?
我怎么得到另一个背景在一个不同的线程,对吧?

1687
01:13:05,169 --> 01:13:07,969
I wanna do some code on another thread,
我想做一些代码在另一个线程,

1688
01:13:08,038 --> 01:13:09,370
Where do I get a context?
我得到一个上下文在哪里?

1689
01:13:09,439 --> 01:13:12,840
The only context I know how to get right now is viewContext,
我唯一知道如何获得上下文现在viewContext,

1690
01:13:12,909 --> 01:13:14,909
That's the main queue's context,
主队列的背景下,

1691
01:13:14,978 --> 01:13:16,143
that's the only only one I can get,
这是唯一的只有一个我可以得到,

1692
01:13:16,212 --> 01:13:18,812
Okay, well, you're gonna use this really cool method
好的,你会使用这个很酷的方法

1693
01:13:18,881 --> 01:13:20,013
in persistentContainer,
在persistentContainer,

1694
01:13:20,082 --> 01:13:24,050
This is new in iOS 10 and a really cool method,
这是新的iOS 10和一个很酷的方法,

1695
01:13:24,119 --> 01:13:25,185
super cool,
超级酷,

1696
01:13:25,253 --> 01:13:27,954
It makes it really easy to do background process on
这使得它很容易做后台进程

1697
01:13:28,022 --> 01:13:29,188
Core Data,
核心数据,

1698
01:13:29,256 --> 01:13:31,256
It's called performBackgroundTask,
它叫做performBackgroundTask,

1699
01:13:31,324 --> 01:13:34,292
Remember, this is a function on persistentContainer that
persistentContainer,记住,这是一个函数

1700
01:13:34,361 --> 01:13:36,327
you get from the AppDelegate,
你从在AppDelegate,

1701
01:13:36,396 --> 01:13:38,129
And this takes a closure,
这需要一个闭包,

1702
01:13:38,197 --> 01:13:42,866
This closure has one argument, the argument is a context,
这个闭包有一个参数,参数是一个背景下,

1703
01:13:42,935 --> 01:13:45,569
And that context is appropriate for use
上下文是适合使用

1704
01:13:45,638 --> 01:13:49,172
on this other thread that this is going to create for you,
在这另一个线程,这是为您要创建,

1705
01:13:49,240 --> 01:13:52,107
So this performBackgroundTask finds another queue,
所以这performBackgroundTask发现另一个队列,

1706
01:13:52,176 --> 01:13:55,044
not the main queue, some other queue,
不是主队列,其他队列,

1707
01:13:55,113 --> 01:13:58,346
And it creates a context in that other queue, and it
和其他队列创建一个上下文,和它

1708
01:13:58,415 --> 01:14:02,584
executes your closure on that other queue in the background,
执行你的关闭其他队列的背景,

1709
01:14:03,853 --> 01:14:05,153
Now, it's a convenience method,
现在,这是一个方便的方法,

1710
01:14:05,221 --> 01:14:07,855
So if you really needed to control the quality of
所以如果你真的需要控制的质量

1711
01:14:07,923 --> 01:14:10,724
service, for example, the queue and all the, okay, well,
服务,例如,队列,所有的,好吧,好吧,

1712
01:14:10,793 --> 01:14:11,558
you can't use this,
你不能用这个,

1713
01:14:11,626 --> 01:14:14,694
But 99,99% of the time, whatever quality of
但99年,99%的时间,不管质量

1714
01:14:14,762 --> 01:14:17,330
service that queue is getting is the right one for
服务队列越来越是正确的

1715
01:14:17,398 --> 01:14:19,499
Core Data cuz Core Data knows its business,
核心数据因为知道其业务核心数据,

1716
01:14:20,801 --> 01:14:21,633
So you're gonna do it,
所以你要做的,

1717
01:14:21,702 --> 01:14:25,169
Now, inside this closure couple of things really
现在,在这个关闭一些东西

1718
01:14:25,238 --> 01:14:26,037
be careful of,
小心的,

1719
01:14:26,105 --> 01:14:28,839
One, never use viewContext in here,
一个,从不使用viewContext在这里,

1720
01:14:28,908 --> 01:14:32,242
Do you see why that would be horrendously bad to
你知道为什么会可怕地不好

1721
01:14:32,311 --> 01:14:34,911
use viewContext inside this closure?
这个闭包内使用viewContext吗?

1722
01:14:34,980 --> 01:14:37,781
Because this closure by definition is not executing on
因为这个闭包定义不执行

1723
01:14:37,849 --> 01:14:39,415
the main queue,
主要的队列,

1724
01:14:39,484 --> 01:14:41,350
By definition this closure is on a separate
通过定义这个闭包在一个单独的

1725
01:14:41,419 --> 01:14:42,718
queue on a background queue,
在背景队列,队列

1726
01:14:42,787 --> 01:14:44,452
That's the whole point of this thing,
这个东西的目的,

1727
01:14:44,521 --> 01:14:46,121
is to put this thing on another queue,
把这个东西放在另一个队列,

1728
01:14:46,189 --> 01:14:48,255
So never use viewContext in there,
所以不要使用viewContext,

1729
01:14:48,324 --> 01:14:50,257
that's why it's in red, okay?
这就是为什么它是红色的,好吗?

1730
01:14:50,326 --> 01:14:55,062
The second thing is don't forget to save this context,
第二件事是不要忘记保存这样的背景下,

1731
01:14:55,130 --> 01:14:56,629
If you do a whole bunch of stuff in here and
如果你在这里,做一大堆的东西

1732
01:14:56,698 --> 01:14:58,264
you don't save, you just did for
你不救,你所做的

1733
01:14:58,333 --> 01:14:59,699
nothing cuz you did in memory,
因为你在内存中,

1734
01:14:59,768 --> 01:15:02,601
And then this block went away, you're never gonna get that
然后这个块走了,你永远不会得到

1735
01:15:02,670 --> 01:15:05,804
context back again, that data is lost,
上下文回来,数据丢失,

1736
01:15:05,873 --> 01:15:08,507
Which all gonna leave the heap and then nothing ever happens,
所有要离开堆然后什么事也没发生过,

1737
01:15:08,575 --> 01:15:10,875
It never gonna get committed to the database,
它不会被提交到数据库,

1738
01:15:10,944 --> 01:15:12,944
So, don't forget to save before you leave,
所以,在你离开之前别忘了保存,

1739
01:15:14,113 --> 01:15:15,679
Now, when you save,
现在,当你保存,

1740
01:15:15,748 --> 01:15:18,515
it will push it down to the database and
它将数据库和

1741
01:15:18,584 --> 01:15:23,186
your other context like your viewContext will see it, okay?
你的其他上下文如viewContext将看到它,好吗?

1742
01:15:23,255 --> 01:15:26,022
And so these two contexts, the one that's happening on this
所以这两种情况下,在这发生的

1743
01:15:26,091 --> 01:15:27,423
background and the viewContext,
背景和viewContext,

1744
01:15:27,492 --> 01:15:29,291
They're working on the same database, so
他们在相同的数据库,所以

1745
01:15:29,360 --> 01:15:30,192
when this one saves,
当这一保存,

1746
01:15:30,261 --> 01:15:33,027
boom this guys is gonna start seeing those changes,
繁荣这个家伙会开始看到这些变化,

1747
01:15:33,096 --> 01:15:36,430
I'm gonna talk a little bit how react to seeing those
我要谈谈如何看到那些反应

1748
01:15:36,499 --> 01:15:38,266
changes in a minute here,
变化在一分钟,

1749
01:15:39,468 --> 01:15:41,334
Okay, so, everyone understand this?
好的,所以,每个人都明白这一点吗?

1750
01:15:41,403 --> 01:15:43,703
Cuz you're gonna have to do this in assignment five,
因为你要做这个作业五,

1751
01:15:43,772 --> 01:15:47,040
And I want you to do all your loading off the main queue,
我想让你做所有你的加载主队列,

1752
01:15:47,109 --> 01:15:49,709
and all your fetching on the main queue,
和你所有的获取主要的队列,

1753
01:15:50,845 --> 01:15:56,315
All right, Core Data is huge,
核心数据是巨大的,

1754
01:15:56,384 --> 01:15:56,948
Huge,
巨大的,

1755
01:15:58,351 --> 01:15:59,484
I can't cover it all,
我不能掩盖这一切,

1756
01:16:00,686 --> 01:16:02,085
It's got optimistic locking, for
它有乐观锁定,

1757
01:16:02,154 --> 01:16:03,053
those of you that know about database,
你知道的数据库,

1758
01:16:03,121 --> 01:16:06,423
It's got optimistic locking and all that database stuff,
它有乐观锁定和所有数据库的东西,

1759
01:16:06,491 --> 01:16:10,025
It has full undo, redo, which is incredible,
全部撤销,重做,这是难以置信的,

1760
01:16:10,094 --> 01:16:13,462
It obviously knows how to roll back unsaved changes,
显然,它知道如何回滚未保存的更改,

1761
01:16:13,531 --> 01:16:15,330
Okay, if you have changes in memory and
好的,如果你有记忆和变化

1762
01:16:15,398 --> 01:16:16,297
you want to roll some of them back,
你想滚回其中的一些,

1763
01:16:16,366 --> 01:16:17,966
you can do that before you save,
你可以在保存之前,

1764
01:16:18,034 --> 01:16:20,534
It knows about staleness, like, if I make a fetch,
它知道过时,就像,如果我取回,

1765
01:16:20,603 --> 01:16:23,870
how long before I really wanna fetch it again because I don't
多久之前我想取回一遍因为我不

1766
01:16:23,939 --> 01:16:26,206
trust that the data hasn't changed, right?
相信这些数据并没有改变,对吗?

1767
01:16:26,274 --> 01:16:28,574
How long it takes for the data to get stale,
需要多长时间的数据陈旧,

1768
01:16:28,643 --> 01:16:31,710
And a lot of other things in the Core Data,
和很多其他的事情在核心数据,

1769
01:16:31,779 --> 01:16:33,212
So, I can't cover it all,
所以,我不能涵盖一切,

1770
01:16:33,280 --> 01:16:35,247
there's not enough time to do that,
没有足够的时间去做,

1771
01:16:35,316 --> 01:16:37,749
Cuz we're trying to talk about a whole another topic about
因为我们试图讨论另一个话题

1772
01:16:37,818 --> 01:16:39,217
But you'll want to check the documentation, you won't need
但是你要检查文档,你不需要

1773
01:16:39,218 --> 01:16:40,617
Core Data here,
核心数据,

1774
01:16:40,687 --> 01:16:43,521
anything else of this stuff to do your homeworks, of course,
其他的东西去做你的作业,当然,

1775
01:16:43,589 --> 01:16:45,689
I'm just trying to get you started with this,
我只是想让你开始,

1776
01:16:45,757 --> 01:16:48,224
But you need to know that this stuff is in there, so that
但是你需要知道这些东西,所以

1777
01:16:48,293 --> 01:16:52,562
one day when you go out and do some significant iOS database
有一天当你走出去,做一些有意义的iOS数据库

1778
01:16:52,631 --> 01:16:54,764
stuff, you'll know that these features are out there,
东西,你就会知道,这些特性,

1779
01:16:56,300 --> 01:17:01,503
All right, the next topic here is Core Data and UITableView,
好吧,下一个话题是核心数据和UITableView,

1780
01:17:01,572 --> 01:17:05,306
As you can imagine, this is a marriage made in heaven, okay?
你可以想象,这是天作之合,好吗?

1781
01:17:05,375 --> 01:17:06,908
Because you got this database,
因为你有这个数据库,

1782
01:17:06,977 --> 01:17:09,244
got all this big data sets in there and
在那里,所有这些大数据集

1783
01:17:09,312 --> 01:17:13,681
what is the UI we use to show big data sets in iOS?
什么是我们使用的UI显示在iOS大数据集吗?

1784
01:17:13,750 --> 01:17:14,982
UITableView,
UITableView,

1785
01:17:15,051 --> 01:17:18,152
Okay, UITableView is great at showing arbitrary large
好的,UITableView显示任意大型

1786
01:17:19,487 --> 01:17:22,288
data sets in our arbitrary UIs, right?
数据集在我们任意的ui,对吧?

1787
01:17:22,357 --> 01:17:23,655
We can do custom table view cell,
我们可以自定义表视图单元格,

1788
01:17:23,724 --> 01:17:26,191
we can do anything UI we want,
UI我们可以做任何我们想要的,

1789
01:17:26,260 --> 01:17:30,429
So, this is so common that Apple has invented this very
这是如此普遍,苹果发明了这个

1790
01:17:30,497 --> 01:17:33,965
important class called NSFetchedResultsController,
重要的类称为NSFetchedResultsController,

1791
01:17:34,034 --> 01:17:36,333
This is not a viewController, okay?
这不是一个viewController,好吗?

1792
01:17:36,402 --> 01:17:39,403
This is a controller that controls Core Data and
这是一个控制器控制核心数据

1793
01:17:39,472 --> 01:17:40,571
UITableView talking together,
UITableView说在一起,

1794
01:17:40,639 --> 01:17:44,607
but it's not in its fetch results view controller, okay?
但它不是在其获取结果视图控制器,对吧?

1795
01:17:44,676 --> 01:17:47,277
And all this NSFetchedResultsController
所有这些NSFetchedResultsController

1796
01:17:47,346 --> 01:17:50,513
does is it hooks up an NSFetchRequest that you create
会钩起一个NSFetchRequest您创建的吗

1797
01:17:50,582 --> 01:17:52,481
to a UITableView,
UITableView,

1798
01:17:52,550 --> 01:17:55,651
And it hooks them up in such a strong way that if anything
这钩子在这样一个强大的方式,如果有的话

1799
01:17:55,720 --> 01:17:59,087
changes in the database that would cause that fetch request
数据库的变化会导致获取请求

1800
01:17:59,156 --> 01:18:02,090
to return different results, it updates the table
返回不同的结果,它更新表

1801
01:18:02,158 --> 01:18:04,993
automatically, you don't have to do anything,
自动,你不需要做任何事情,

1802
01:18:05,062 --> 01:18:09,096
So this is an active live hookup between
这是一个活跃的生活之间的连接

1803
01:18:09,165 --> 01:18:14,467
the NSFetchRequest and the TableView, okay?
NSFetchRequest TableView,好吗?

1804
01:18:14,536 --> 01:18:17,370
Even if some other context are changing the data, it doesn't
即使其他上下文变化数据,它不是

1805
01:18:17,439 --> 01:18:20,807
matter, it's always keeping that TableView up to date,
事,它总是保持TableView日期,

1806
01:18:21,977 --> 01:18:25,011
So I'm gonna talk about how we do this,
所以我要谈谈我们如何做到这一点,

1807
01:18:25,080 --> 01:18:28,980
how we use an NSFetchedResultsController,
我们如何使用一个NSFetchedResultsController,

1808
01:18:29,049 --> 01:18:31,550
I'm even gonna provide you some kind of free code
我甚至会提供你一些免费的代码

1809
01:18:31,619 --> 01:18:32,984
to do some of it,
做一些,

1810
01:18:33,053 --> 01:18:34,586
You'll have to type in a little bit of the rest of it,
你必须输入一个剩下的,

1811
01:18:34,654 --> 01:18:37,455
But it's, it's pretty easy to do,
但是,它很容易做到,

1812
01:18:39,191 --> 01:18:40,657
So how fundamentally does
那么如何从根本上

1813
01:18:40,726 --> 01:18:42,725
NSFetchedResultsController work?
NSFetchedResultsController工作吗?

1814
01:18:42,794 --> 01:18:46,596
Two ways, one, it has a delegate and
两种方法,一,它有一个委托和

1815
01:18:46,664 --> 01:18:50,600
that delegate you set to be your UITableViewController,
这代表你将UITableViewController,

1816
01:18:50,668 --> 01:18:53,001
And whenever the FetchResultsController sees
每当FetchResultsController看到

1817
01:18:53,070 --> 01:18:53,802
something happening
发生了一些事情

1818
01:18:53,871 --> 01:18:56,638
in the database that would affect that fetchRequest,
fetchRequest数据库中的影响,

1819
01:18:56,706 --> 01:18:59,707
it tells the table view controller, hey, do this,
它讲述了表格视图控制器,嘿,这样做,

1820
01:18:59,776 --> 01:19:02,843
add this row, add a section, reload this row, whatever,
添加这一行,添加一个部分中,重载这一行,无论如何,

1821
01:19:02,911 --> 01:19:09,349
it uses UITableView primitives to update the table, okay?
它使用UITableView原语来更新表,好吗?

1822
01:19:09,418 --> 01:19:10,350
I'm gonna show you,
我要告诉你,

1823
01:19:10,419 --> 01:19:12,318
I'm gonna give you the code that does that part of it,
我要给你这部分的代码,

1824
01:19:12,387 --> 01:19:14,454
that implements the NSFetchedResultsController's
实现NSFetchedResultsController

1825
01:19:14,522 --> 01:19:16,422
delegate, okay, so that's one way it does it,
委托,这是它的一种方式,

1826
01:19:16,491 --> 01:19:18,758
The other way that the NSFetchedResultsController
NSFetchedResultsController的另一种方式

1827
01:19:18,826 --> 01:19:21,493
works is that it provides implementation for
的工作原理是,它提供了实现

1828
01:19:21,562 --> 01:19:24,763
all of your UITableView data sources methods, right?
你所有的UITableView数据源的方法,对吧?

1829
01:19:24,831 --> 01:19:26,631
Because the contents of your table
因为你的表的内容

1830
01:19:26,700 --> 01:19:28,131
are coming out of the database,
的数据库,

1831
01:19:28,200 --> 01:19:30,668
so NSFetchedResultsController lets you know all of them, how
所以NSFetchedResultsController让你知道所有这些,怎么做

1832
01:19:30,736 --> 01:19:33,436
many sections, how many rows and sections all that stuff,
许多部分,多少行和部分所有的东西,

1833
01:19:33,505 --> 01:19:35,204
In fact, this is what it looks like,
事实上,这就是它的样子,

1834
01:19:35,273 --> 01:19:37,874
this is the implementation that you're gonna put in to
这是你要投入实施

1835
01:19:37,942 --> 01:19:41,077
your controller when you have fetchedResultsController,
你的控制器,fetchedResultsController后,

1836
01:19:41,146 --> 01:19:42,077
The first thing you're gonna
你的第一件事

1837
01:19:42,146 --> 01:19:44,212
do is you're gonna create a fetchedResultsController, and
做的是你要创建一个,fetchedResultsController,

1838
01:19:44,281 --> 01:19:46,448
I'm gonna show you how to do that in a moment,
我将向您展示如何在一个时刻,

1839
01:19:46,516 --> 01:19:48,382
And so you're always gonna have a var called
所以你总是会有一个var

1840
01:19:48,451 --> 01:19:50,518
fetchedResultsController, and
,fetchedResultsController,

1841
01:19:50,586 --> 01:19:53,386
it's gonna be of type NSFetchedResultsController,
它会NSFetchedResultsController类型,

1842
01:19:53,455 --> 01:19:56,056
And when you have that var, now you can implement your
当你有var,现在您可以实现您的

1843
01:19:56,125 --> 01:19:59,659
sections, number of sections in TableView by saying return
部分,部分数量TableView说回来

1844
01:19:59,728 --> 01:20:04,731
fetchedResultsController ,sections,count, okay?
,fetchedResultsController、节、计数,好吗?

1845
01:20:04,800 --> 01:20:06,231
Those are a lot of optionals in there, so
这些都是可选的很多,所以

1846
01:20:06,300 --> 01:20:08,934
we'll default to one section,
我们将默认为一个部分,

1847
01:20:09,003 --> 01:20:10,969
And then to get the number of rows in a section,
然后一节的行数,

1848
01:20:11,038 --> 01:20:12,771
you're just gonna say the,
你只会说,

1849
01:20:12,839 --> 01:20:14,539
you're gonna get the sections first by saying
你会得到第一个说的部分

1850
01:20:14,608 --> 01:20:16,640
fetchedResultsController?,sec- tions,
,fetchedResultsController吗?

1851
01:20:16,709 --> 01:20:21,445
And as long as you have some sections, sections,count
只要你有一些部分,部分,计数

1852
01:20:21,514 --> 01:20:24,748
greater than zero, then you're gonna return the sections in
大于零,那么你要返回的部分

1853
01:20:24,817 --> 01:20:27,650
that section that's passed to you number of objects,
这部分传递给你的对象数量,

1854
01:20:27,719 --> 01:20:31,087
Okay, so that code, that's it, that's all of your, those two
好了,这代码,就是这样,这是你的所有,这两个

1855
01:20:31,155 --> 01:20:34,390
methods, that's the entire implementation if you're using
方法,如果你使用全部实现

1856
01:20:34,458 --> 01:20:36,491
a fetchedResultsController, okay?
,fetchedResultsController ?

1857
01:20:36,560 --> 01:20:39,394
And then of course, there's cellForRowAt, okay,
当然,cellForRowAt,好吧,

1858
01:20:39,463 --> 01:20:41,629
you gotta implement that, that one too,
你必须实现,一个也

1859
01:20:41,698 --> 01:20:44,298
you're gonna use fetchedResultsController,
你会使用,fetchedResultsController,

1860
01:20:44,367 --> 01:20:48,869
And the most important thing about cellForRowAt is you need
关于cellForRowAt和最重要的事情是你需要的

1861
01:20:48,938 --> 01:20:53,274
to know what's at that row, which thing in my database is
知道在这一行,这东西在我的数据库

1862
01:20:53,343 --> 01:20:56,909
at that row in that section in my table,
在这一行,部分在我的表,

1863
01:20:56,978 --> 01:21:00,480
And you get that by asking the fetchedResultsController with
通过询问,fetchedResultsController得到

1864
01:21:00,549 --> 01:21:02,481
this method objectAtIndexPath,
这个方法objectAtIndexPath,

1865
01:21:02,550 --> 01:21:05,117
So you just say fetchedResultsController,
你只是说,fetchedResultsController,

1866
01:21:05,186 --> 01:21:08,520
give me the object, and that object is gonna be a tweet, or
给我对象,该对象将是一条微博,或

1867
01:21:08,589 --> 01:21:11,189
a Twitter user, or whatever, some entity,
Twitter用户,等等,一些实体,

1868
01:21:11,258 --> 01:21:13,691
Give me an object at the index path
给我一个对象索引路径

1869
01:21:13,760 --> 01:21:17,262
that cellForRowAt indexPath is asking me for,
,cellForRowAt indexPath问我了,

1870
01:21:17,330 --> 01:21:19,363
So now I have the Twitter user or the tweet,
现在我有推特用户或推特,

1871
01:21:19,432 --> 01:21:21,232
I can easily load up my UI,
我可以很容易地加载UI,

1872
01:21:21,300 --> 01:21:24,667
You know, pass it off to my UI, custom UITableView cell,
你知道,把它从我的UI,定制UITableView细胞,

1873
01:21:24,736 --> 01:21:25,902
or if I have a subtitle cell,
如果我有一个副标题,

1874
01:21:25,971 --> 01:21:27,970
just take a couple of things out of there and
把几件事情,

1875
01:21:28,039 --> 01:21:30,105
put it in the text label in the detailed text label,
把它放在文本标签的详细的文本标签,

1876
01:21:30,174 --> 01:21:31,340
you see what I'm saying?
你看到我在说什么吗?

1877
01:21:31,408 --> 01:21:34,642
But you can see that the fetchedResultsController,
但是你可以看到,fetchedResultsController,

1878
01:21:34,711 --> 01:21:37,512
that code in yellow right there in the middle of
代码用黄色的

1879
01:21:37,581 --> 01:21:39,180
cellForRowAt indexPath,
cellForRowAt indexPath,

1880
01:21:39,249 --> 01:21:42,416
that's doing all the work to figure out what tweet or
这是做所有的工作找出tweet或者什么

1881
01:21:42,485 --> 01:21:45,653
what Twitter user is at this row in the table, okay?
什么是Twitter用户在此表中的行,好吗?

1882
01:21:45,721 --> 01:21:47,120
So those code on the last slide and
这些代码在最后一张幻灯片

1883
01:21:47,189 --> 01:21:49,789
the code on this slide, you'll have to type that code in any
这张幻灯片上的代码,你必须在任何类型的代码

1884
01:21:49,858 --> 01:21:53,392
time you're using an NSFetchedResultsController,
当你使用一个NSFetchedResultsController,

1885
01:21:53,461 --> 01:21:56,028
Now, on the previous slide, one of the things was var
现在,上一张幻灯片,var的一件事

1886
01:21:56,097 --> 01:21:58,330
fetchedResultsController equals something,
,fetchedResultsController等于什么,

1887
01:21:58,399 --> 01:22:00,566
So now let's talk about how we create
现在让我们谈谈我们如何创造

1888
01:22:00,634 --> 01:22:03,001
a fetchedResultsController, okay?
,fetchedResultsController ?

1889
01:22:03,070 --> 01:22:04,769
So this is what the initializer for
这是初始化的

1890
01:22:04,838 --> 01:22:07,304
NSFetchedResultsController looks like here,
NSFetchedResultsController看起来像在这里,

1891
01:22:07,373 --> 01:22:09,273
It takes a request, a context,
这需要一个请求,一个上下文,

1892
01:22:09,342 --> 01:22:11,074
Obviously, it doesn't know what database
显然,它不知道数据库

1893
01:22:11,143 --> 01:22:12,375
we're fetching in,
我们抓取,

1894
01:22:12,444 --> 01:22:15,444
And then it's got a sectionNameKeyPath,
它有一个sectionNameKeyPath,

1895
01:22:15,513 --> 01:22:19,682
That sectionNameKeyPath is the var in
sectionNameKeyPath是var

1896
01:22:19,751 --> 01:22:24,519
that entity that, whose value is a string,
实体,其值是一个字符串,

1897
01:22:24,588 --> 01:22:28,891
which is the title of the section it's in, okay?
这是一节的标题,好吗?

1898
01:22:28,959 --> 01:22:31,425
That's how you do sections with fetchedResultsController,
这就是你,fetchedResultsController部分,

1899
01:22:31,494 --> 01:22:33,928
You just have to, and you might have to invent this or
你只需要,你可能不得不发明这个或

1900
01:22:33,997 --> 01:22:35,195
even calculate this,
即使是计算这个,

1901
01:22:35,264 --> 01:22:38,265
But all of your tweets or all your Twitter users, if they're
但是你所有的微博或者你所有的Twitter用户,如果他们

1902
01:22:38,333 --> 01:22:40,800
gonna be in sections, they all have to have a var,
要的部分,他们都必须有一个var,

1903
01:22:40,869 --> 01:22:43,870
which is a string, which is the section they're in, okay,
它是一个字符串,他们在一节,好吧,

1904
01:22:43,939 --> 01:22:45,738
the name of the section they're in,
他们在一节的名称,

1905
01:22:45,807 --> 01:22:49,341
And as long as they have that, then the fetchedResults will,
只要他们有,那么fetchedResults将,

1906
01:22:49,410 --> 01:22:50,843
will make the sections and
会使部分和

1907
01:22:50,911 --> 01:22:53,344
put them all in there in the right section,
把他们都在正确的部分,

1908
01:22:53,413 --> 01:22:56,681
And we'll talk about cacheName in a second here,
我们会讨论cacheName在第二个,

1909
01:22:56,749 --> 01:22:58,950
So we have to create a fetchRequest to put in here,
所以我们要创建一个fetchRequest放在这里,

1910
01:22:59,019 --> 01:23:00,818
So here's an example of creating a fetchRequest for
这里有一个例子创建fetchRequest

1911
01:23:00,887 --> 01:23:01,719
tweets, right?
微博,对吧?

1912
01:23:01,788 --> 01:23:03,486
So you recognize that first line there,
所以你认识到第一行,

1913
01:23:03,555 --> 01:23:05,655
creating a fetchRequest for tweets,
创建一个fetchRequest推,

1914
01:23:05,723 --> 01:23:09,625
And I'm gonna sort by when the tweets were created, okay,
我将通过创建微博时,好吧,

1915
01:23:09,694 --> 01:23:11,427
when the tweet was tweeted out,
当推了推特,

1916
01:23:11,496 --> 01:23:15,664
And I'm gonna look for all the tweets whose tweeter's name
我要寻找所有的推特的推特的名字

1917
01:23:15,732 --> 01:23:18,734
equals some name, the name, okay?
等于某个名字,这个名字,好吗?

1918
01:23:18,803 --> 01:23:20,468
So it's gonna get all those tweets, and
所以它会得到所有这些推文,

1919
01:23:20,537 --> 01:23:22,903
I'm gonna set that request as the first argument there,
我要设置请求作为第一个参数,

1920
01:23:22,972 --> 01:23:24,471
to NSFetchedResultsController,
NSFetchedResultsController,

1921
01:23:24,540 --> 01:23:27,807
By the way, notice NSFetchedResultsController is
顺便说一下,请注意NSFetchedResultsController

1922
01:23:27,876 --> 01:23:31,612
also a generic type, and NSFetchedResultsController can
也是一个泛型类型,NSFetchedResultsController可以

1923
01:23:31,681 --> 01:23:34,313
only control fetches for a certain type,
只有控制获取特定类型,

1924
01:23:34,382 --> 01:23:36,915
So you have to say what type, okay, what type of entity that
所以你必须说什么类型、什么类型的实体

1925
01:23:36,984 --> 01:23:39,618
your FetchController is doing, and these are the same type of
FetchController做,这些都是同一类型的

1926
01:23:39,687 --> 01:23:41,587
things that are in the rows of your table,
在你的表的行,

1927
01:23:42,956 --> 01:23:45,056
Now that cacheName at the bottom is interesting,
既然cacheName底部很有趣,

1928
01:23:45,124 --> 01:23:48,726
That is actually going to permanently cache the results,
要永久缓存结果,

1929
01:23:48,794 --> 01:23:49,793
it's gonna get the results out of the database and
它会从数据库中得到的结果

1930
01:23:49,794 --> 01:23:50,793
In other words,
换句话说,

1931
01:23:50,863 --> 01:23:55,532
store on disk the result in some internal format,
存储在磁盘上的结果在某些内部格式,

1932
01:23:55,601 --> 01:23:57,667
And that's cool, and that storage, by the way,
,那很酷,存储,顺便说一下,

1933
01:23:57,735 --> 01:23:58,968
if you quit your app and come back,
如果你退出你的应用和回来,

1934
01:23:59,037 --> 01:24:01,904
it will still use that cache, so it's quite efficient,
它仍然会使用缓存,所以它很有效,

1935
01:24:01,973 --> 01:24:03,605
But you have to be a little bit careful,
但你必须小心一点,

1936
01:24:03,674 --> 01:24:06,708
You cannot change anything about your request,
你不能改变任何关于你的要求,

1937
01:24:06,777 --> 01:24:09,578
As soon as you change anything about your request, like
只要你改变任何关于你的要求,

1938
01:24:09,646 --> 01:24:12,713
the name, the tweeter,name that you're searching for, or
推特的名字,名字,你正在寻找,或

1939
01:24:12,782 --> 01:24:15,082
what you're sorting by, or anything,
你排序,或任何

1940
01:24:15,151 --> 01:24:17,718
Now that cache is invalid, and you'll have to invalidate that
现在缓存是无效的,你必须无效

1941
01:24:17,786 --> 01:24:21,354
cache, okay, and there's an API in there for doing that,
缓存,这样做有一个API,

1942
01:24:21,423 --> 01:24:24,057
You can pass nil there if you don't wanna do the caching,
你可以通过nil缓存,如果你不想做

1943
01:24:24,125 --> 01:24:28,027
which for most reasonable sized datasets perfectly fine,
这对于大多数合理大小的数据集非常好,

1944
01:24:28,095 --> 01:24:29,662
you don't really need the caching,
你真的不需要缓存,

1945
01:24:29,730 --> 01:24:31,363
But I just wanna emphasize that if you change your
但我想强调的是,如果你改变

1946
01:24:31,432 --> 01:24:34,700
request, your cache is now invalid,
缓存的请求,你现在是无效的,

1947
01:24:34,768 --> 01:24:38,169
And about that section key thing, something to be careful
和部分关键,要小心

1948
01:24:38,237 --> 01:24:42,006
about there, too, is that whatever your sortDescriptors
大概在这里,无论你sortDescriptors

1949
01:24:42,075 --> 01:24:46,410
say that your rows would sort in, that has to be
会说你行,

1950
01:24:46,478 --> 01:24:51,515
exactly the same order that your sections was sorted in,
相同的订单,你的部分是按照,

1951
01:24:51,583 --> 01:24:53,484
In other words, the FetchedResultsController
换句话说,,FetchedResultsController

1952
01:24:53,552 --> 01:24:55,918
doesn't know how to like move things around
不知道如何像四处移动

1953
01:24:55,987 --> 01:24:58,521
because they sort out of order of their sections,
因为他们解决的部分,

1954
01:24:58,590 --> 01:25:00,556
That's why a lot of times that we're doing sections,
这就是为什么很多时候我们做的部分,

1955
01:25:00,624 --> 01:25:04,360
the first sortDescriptor will be sort by the section key
第一sortDescriptor将是关键的部分

1956
01:25:04,428 --> 01:25:05,927
name var, right?
var名字,对吧?

1957
01:25:05,996 --> 01:25:08,163
And then the second one will be sort by what we
然后第二个将由我们

1958
01:25:08,231 --> 01:25:10,865
really wanna sort by, because we have to make sure
真的想排序,因为我们必须确保

1959
01:25:10,934 --> 01:25:13,935
that our entire table is sorted in section order,
节中,我们整个表排序顺序,

1960
01:25:15,338 --> 01:25:16,269
You see why?
你知道为什么吗?

1961
01:25:16,338 --> 01:25:17,737
Cuz otherwise it's just weird,
因为否则就奇怪,

1962
01:25:17,806 --> 01:25:19,072
things would all be in the wrong places,
事情都是在错误的地方,

1963
01:25:20,274 --> 01:25:22,208
So keyThatSaysWhichAttributeIsTh-
因此keyThatSaysWhichAttributeIsTh -

1964
01:25:22,276 --> 01:25:24,810
eSectionName has to sort in the same order as your
eSectionName必须在相同的顺序进行排序

1965
01:25:24,878 --> 01:25:26,044
sortDescriptors,
sortDescriptors,

1966
01:25:27,847 --> 01:25:32,216
Okay, now, I told you that NSFetchedResultsController
好的,现在,我告诉你,NSFetchedResultsController

1967
01:25:32,285 --> 01:25:33,817
watches Core Data,
手表的核心数据,

1968
01:25:33,886 --> 01:25:36,953
It sees changes happening in there, and it updates it,
它看到变化,更新它,

1969
01:25:37,022 --> 01:25:38,888
And it does that with its delegate, okay?
和它的委托,对吧?

1970
01:25:38,957 --> 01:25:40,489
Its delegate wants to be the tableView,
它代表想要表视图,

1971
01:25:40,558 --> 01:25:42,124
be the tableViewController, rather,
有这个表,

1972
01:25:42,193 --> 01:25:44,360
Cuz it's gonna tell the tableViewController, and
因为它会告诉表,

1973
01:25:44,429 --> 01:25:45,627
it sends messages like this,
这样发送消息,

1974
01:25:45,696 --> 01:25:48,663
So this is a typical NSFetchedResultsController
这是一个典型的NSFetchedResultsController

1975
01:25:48,731 --> 01:25:50,031
delegate method,
委托方法,

1976
01:25:50,099 --> 01:25:53,200
Controller did change add indexPath for change type, and
控制器做了添加indexPath改变类型,

1977
01:25:53,269 --> 01:25:55,202
here's the new indexPath,
这是新的indexPath,

1978
01:25:55,271 --> 01:25:58,105
Okay, and these change types might be deleted or
好了,这些可能被删除或者改变类型

1979
01:25:58,173 --> 01:26:00,973
inserted or modified or whatever,
插入或修改,

1980
01:26:01,042 --> 01:26:04,176
Now, you have to put the code in there that would call
现在,你必须把代码放进去,电话

1981
01:26:04,245 --> 01:26:07,480
the right methods on the tableView to get the sections
正确的方法tableView部分

1982
01:26:07,549 --> 01:26:10,449
inserted or deleted or rows added or whatever,
插入或删除或添加行,

1983
01:26:10,518 --> 01:26:13,819
But I'm gonna give you that code for free, okay, and
但我还是要给你免费代码,好的,

1984
01:26:13,888 --> 01:26:16,120
the demo that I'm gonna do on Wednesday,
周三我要做的演示,

1985
01:26:16,189 --> 01:26:19,757
I'm gonna have a class called fetchedResultsTableViewContro-
我要上课叫fetchedResultsTableViewContro -

1986
01:26:19,826 --> 01:26:21,759
ller, which is gonna be a class,
噢,这是一个类,

1987
01:26:21,827 --> 01:26:25,796
And you can make that to be the super class of your
你可以让你的超类

1988
01:26:25,864 --> 01:26:28,598
UITableViewController,
UITableViewController,

1989
01:26:28,667 --> 01:26:32,001
And you'll just inherit this implementation of
你会继承这个实现的

1990
01:26:32,070 --> 01:26:36,039
the delegate, okay?
委托,对吧?

1991
01:26:36,107 --> 01:26:38,107
Yes, cuz that's what I just said,
是的,因为这就是我刚才说的,

1992
01:26:38,176 --> 01:26:41,276
Okay, so when you're using core data in UITableView,
好的,所以当你在UITableView使用核心数据,

1993
01:26:41,345 --> 01:26:44,079
the things to remember are, you're going to subclass
要记住的事情是,你将子类

1994
01:26:44,148 --> 01:26:46,347
fetchedResultsTableViewContro- ller,
fetchedResultsTableViewContro——噢,

1995
01:26:46,416 --> 01:26:48,950
the thing I'm gonna give you, so that you implement
我要的东西给你,以便你实现

1996
01:26:49,019 --> 01:26:51,585
NSFetchedResultsController delegate,
NSFetchedResultsController委托,

1997
01:26:51,654 --> 01:26:54,621
You're going to add a var to your UITableViewController
你要添加一个var UITableViewController

1998
01:26:54,690 --> 01:26:56,856
called fetchedResultsController, and
叫,fetchedResultsController,

1999
01:26:56,925 --> 01:26:58,557
you're gonna set its value to be
你要设置它的值

2000
01:26:58,626 --> 01:27:01,995
an NSFetchedResultsController with the fetchRequest that you
一个NSFetchedResultsController fetchRequest你

2001
01:27:02,063 --> 01:27:05,464
want, okay, that you want to populate your table,
想要的,好吧,你想填充表,

2002
01:27:05,532 --> 01:27:08,700
Then you're gonna implement your UITableView data source
然后你会实现你的UITableView数据源

2003
01:27:08,769 --> 01:27:11,770
methods using fetchedResultsController var
使用,fetchedResultsController var的方法

2004
01:27:11,839 --> 01:27:14,405
methods, just like I showed you in the slides,
方法,就像我给你的幻灯片,

2005
01:27:14,474 --> 01:27:15,907
character for character,
字符的字符,

2006
01:27:15,975 --> 01:27:18,910
you can use the exact same things that are on the slide,
您可以使用相同的事情在幻灯片上,

2007
01:27:18,978 --> 01:27:21,679
Okay, and then it's all gonna magically work, all you'll
好了,然后它会神奇地工作,你会

2008
01:27:21,747 --> 01:27:24,014
have to do is inside your cellForRowAt indexPath,
要做的就是在你cellForRowAt indexPath,

2009
01:27:24,082 --> 01:27:25,748
you'll have the object, the tweet,
你有对象,推特,

2010
01:27:25,817 --> 01:27:28,284
or the Twitter user, you just gotta load up your UI,
或Twitter用户,您只需要加载UI,

2011
01:27:29,454 --> 01:27:30,919
After you have all this set up,
所有这些设置后,

2012
01:27:30,988 --> 01:27:34,022
then you can proceed to using the fetchedResultsController
然后你可以继续使用,fetchedResultsController

2013
01:27:34,091 --> 01:27:35,890
in your tableViewController,
在你的表,

2014
01:27:35,959 --> 01:27:38,826
First thing you have to do is perform fetch on
你首先要做的就是执行获取

2015
01:27:38,895 --> 01:27:40,161
the fetchedResultsController,
,fetchedResultsController,

2016
01:27:40,229 --> 01:27:43,431
That will cause it to go out and do your NSFetchRequest,
这将导致出去你NSFetchRequest呢,

2017
01:27:43,499 --> 01:27:44,564
basically,
基本上,

2018
01:27:44,633 --> 01:27:46,766
It's not gonna pull all the data over, but
它不会把所有的数据,但是

2019
01:27:46,835 --> 01:27:49,836
it's going to basically bring over, do the same thing as if
基本上它会带过来,如果做同样的事情

2020
01:27:49,905 --> 01:27:52,404
you had executed the fetchRequest yourself, and
你执行了fetchRequest自己,

2021
01:27:52,473 --> 01:27:55,508
then you're gonna wanna do tableView View,reloadData,
然后你会想做tableView看来,reloadData,

2022
01:27:55,576 --> 01:27:59,144
And that's because you want all of your datasource
因为你想要你所有的数据源

2023
01:27:59,213 --> 01:28:03,481
methods to be called, and you know that we've implemented
方法被调用,你知道我们已经实现了

2024
01:28:03,549 --> 01:28:07,118
all of them in terms of our fetch results controller as
我们所有人而言,获取结果控制器

2025
01:28:07,187 --> 01:28:09,720
showed on the previous slides there,
显示在前面的幻灯片,

2026
01:28:09,788 --> 01:28:12,556
And the only other thing you want to remember to do
唯一的另一件事你要记住

2027
01:28:12,625 --> 01:28:15,692
is set your fetch results controller's delegate to be
设置你的获取结果控制器的委托是什么

2028
01:28:15,761 --> 01:28:19,663
yourself and, again, we use that fetch results table view
自己,再一次,我们使用,获取结果表视图

2029
01:28:19,731 --> 01:28:22,732
controller code that added the delegate methods for
控制器添加的委托方法的代码

2030
01:28:22,801 --> 01:28:26,302
the fetch results controller to the UITableView controller
获取结果控制器UITableView控制器

2031
01:28:26,370 --> 01:28:29,638
until we can do all the things that is necessary to
直到我们可以做所有的事情是必要的

2032
01:28:29,707 --> 01:28:33,074
be a fetchedResultsController delegate,
是一个,fetchedResultsController委托,

2033
01:28:33,143 --> 01:28:36,077
And what that buys you is that anytime in the database
你购买是随时在数据库中

2034
01:28:36,146 --> 01:28:39,046
changes that would affect the NSFetchedRequest
这将影响NSFetchedRequest变化

2035
01:28:39,115 --> 01:28:42,383
that you wired up to your fetchedResultsController,
你连接到你的,fetchedResultsController,

2036
01:28:42,452 --> 01:28:45,218
Then, it will use that delegate to ask the table view
然后,它将使用委托问表视图

2037
01:28:45,287 --> 01:28:47,154
to update the rows or sections,
更新行或部分,

2038
01:28:47,223 --> 01:28:49,623
whatever happened to change,
无论发生了什么变化,

2039
01:28:49,691 --> 01:28:52,258
So let me talk a little bit about what's coming up here,
让我谈谈即将发生的事,

2040
01:28:52,327 --> 01:28:55,027
on Wednesday, I'm gonna do a big demo that shows you all of
周三,我要做一个演示程序,展示了你的所有

2041
01:28:55,095 --> 01:28:56,828
this stuff, as usual,
这个东西,像往常一样,

2042
01:28:56,897 --> 01:28:58,530
Assignment five is going out on Wednesday,
作业五是周三,

2043
01:28:58,599 --> 01:28:59,831
it'll be due the next Wednesday,
由于下一个周三,

2044
01:28:59,899 --> 01:29:03,300
It's going to be to add Core Data stuff to your Smashtag,
这将是添加Smashtag核心数据,

2045
01:29:03,369 --> 01:29:08,839
On Friday, very relevant section,
周五,相关部门,

2046
01:29:08,908 --> 01:29:12,276
It's using CloudKit to do a database,
这是使用CloudKit数据库,

2047
01:29:12,344 --> 01:29:15,145
Okay? Now, Core Data and CloudKit,
好吧?

2048
01:29:15,214 --> 01:29:17,380
what, what are they, how are they related?
它们是什么,它们是如何联系起来的?

2049
01:29:17,448 --> 01:29:19,515
Well, Core Data is for
核心数据

2050
01:29:19,584 --> 01:29:22,285
doing things that you would do with a relational database,
做你会做的事与关系数据库中,

2051
01:29:22,353 --> 01:29:25,354
these powerful queries and searches and things like that,
这些强大的查询和搜索之类的东西,

2052
01:29:25,423 --> 01:29:28,056
Cloud Kit is, what if you wanted to have a database
云设备,如果你想要一个数据库

2053
01:29:28,125 --> 01:29:30,692
on the network, in the cloud, okay?
在网络上,在云中,好吗?

2054
01:29:30,760 --> 01:29:34,028
A network that's being shared between multiple people or
网络在多个人之间共享的或

2055
01:29:34,097 --> 01:29:35,996
even by a single person on multiple,
即使是一个人在多个,

2056
01:29:36,065 --> 01:29:38,198
on multiple of their devices, or whatever,
在多个设备,等等,

2057
01:29:38,267 --> 01:29:40,934
So there quite different in the way they approach things,
因此,他们做事的方式完全不同,

2058
01:29:41,002 --> 01:29:44,971
In Core Data, we do the schema using this visual mapper,
核心数据,我们使用这种视觉映射器的模式,

2059
01:29:45,040 --> 01:29:48,607
In CloudKit, it's essentially schema on the fly,
在CloudKit,它本质上是模式,

2060
01:29:48,676 --> 01:29:51,310
As you start saving vars,
当你开始储蓄增值,

2061
01:29:51,378 --> 01:29:54,980
it starts making this schema up for you, so
为你开始制作这个模式,所以

2062
01:29:55,049 --> 01:29:57,816
it's a very different kind of way of thinking about,
这是一个非常不同的思考方式,

2063
01:29:57,885 --> 01:30:00,618
You don't think of it from a scheme of design point,
你不把它从方案的设计角度,

2064
01:30:00,687 --> 01:30:03,788
In advance, there's kind of more organic as you go and
提前,有更多的有机你去

2065
01:30:03,857 --> 01:30:04,655
also you don't have to,
你也不需要,

2066
01:30:04,723 --> 01:30:07,590
you know, kind of create this whole scheme of front and
你知道,创建前后的整个计划

2067
01:30:07,659 --> 01:30:10,560
describe it, you can describe it as you use it essentially,
描述它,你可以描述它本质上使用它,

2068
01:30:10,629 --> 01:30:14,531
So it's a very interesting comparison between the two,
这是一个非常有趣的两者之间的比较,

2069
01:30:14,599 --> 01:30:16,265
I wish I had time to do CloudKit,
我希望我有时间做CloudKit,

2070
01:30:16,334 --> 01:30:18,067
Last quarter, I had the extra lectures,
上个季度,我有额外的讲座,

2071
01:30:18,135 --> 01:30:20,035
I was able to do CloudKit as a whole lecture but,
我能够做CloudKit讲座作为一个整体,但

2072
01:30:20,104 --> 01:30:23,205
we'll have to do it as a Friday section this week so,
我们必须做本周周五部分,

2073
01:30:23,273 --> 01:30:24,538
don't miss that,
不要错过,

2074
01:30:24,607 --> 01:30:26,640
Next Monday is a holiday,
下星期一是假期,

2075
01:30:26,709 --> 01:30:28,542
So no lecture and then next Wednesday,
所以没有课,然后在下周三,

2076
01:30:28,611 --> 01:30:30,111
I'm gonna go over your requirements for
我要超过你的要求

2077
01:30:30,179 --> 01:30:31,979
the final project, which are required to do,
的最后一个项目,需要做什么,

2078
01:30:32,047 --> 01:30:35,915
And I'm also gonna have a lecture as well on AutoLayout,
我也会有一个讲座在自动布局,

2079
01:30:35,984 --> 01:30:38,417
We'll finally get to Autolayout and
我们最后会自动布局

2080
01:30:38,486 --> 01:30:41,654
how do that Autolayout stuff,
如何自动布局的东西,

2081
01:30:41,723 --> 01:30:43,522
I'd say, I just wanted to show you that and
我想说,我只是想告诉你,

2082
01:30:43,591 --> 01:30:46,025
I will see you all on Wednesday,
周三我将看到你所有,

2083
01:30:46,093 --> 01:30:56,401
>> For more please visit us on Stanford,edu,
> >更多信息请访问我们在斯坦福,edu,
